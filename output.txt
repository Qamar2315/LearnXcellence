const express = require("express");
const app = express();
const cors = require("cors");
const mongoose = require("mongoose");
const { notFound, errorHandler } = require("./middlewares/ErrorHandler");

// Importing Routes
const courseRoutes = require("./routes/courseRoutes");
const projectRoutes = require("./routes/projectRoutes");
const remarkRoutes = require("./routes/remarkRoutes");
const statusRoutes = require("./routes/statusRoutes");
const vivaRoutes = require("./routes/vivaRoutes");
const annoucementRoutes = require("./routes/annoucementRoutes");
const authRoutes = require("./routes/authRoutes");
const proctoringRoutes = require("./routes/proctoringRoutes");
const quizRoutes = require("./routes/quizRoutes");
const assignmentRoutes = require("./routes/assignmentRoutes");
const submissionRoutes = require("./routes/submissionRoutes");
const lectureRoutes = require("./routes/lectureRoutes");
const pollRoutes = require("./routes/pollRoutes");

// Load environment variables from .env file
require('dotenv').config();

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static("public"));

// Routes
app.use("/api/auth", authRoutes);
app.use("/api/course", courseRoutes);
app.use("/api/project", projectRoutes);
app.use("/api/remarks", remarkRoutes);
app.use("/api/status", statusRoutes);
app.use("/api/viva", vivaRoutes);
app.use("/api/announcements", annoucementRoutes);
app.use('/api/ai-protoring',proctoringRoutes);
app.use('/api/quiz', quizRoutes);
app.use('/api/assignments', assignmentRoutes);
app.use('/api/submissions', submissionRoutes);
app.use('/api/lectures', lectureRoutes);
app.use('/api/polls', pollRoutes);

app.use(notFound);
app.use(errorHandler);

main().catch((err) => console.log(err));
async function main() {
  await mongoose.connect(process.env.MONGODB_URL);
  console.log("connected");
}

// Server
const port = process.env.PORT || 8080;
app.listen(port, () => {
  console.log(`APP IS LISTENING ON PORT ${port}`);
});

const asyncHandler = require("../utilities/CatchAsync");
const announcementService = require("../services/announcementService");

const sendCourseAnnouncement = asyncHandler(async (req, res) => {
    const { courseId } = req.params;
    const announcement = await announcementService.sendCourseAnnouncement(courseId, req.body, req.user._id);
    res.status(201).json({
        success: true,
        message: "Announcement sent successfully",
        data: announcement
    });
});

const deleteAnnouncement = asyncHandler(async (req, res) => {
    const { announcementId } = req.params;
    await announcementService.deleteAnnouncement(announcementId);
    res.status(200).json({
        success: true,
        message: "Announcement deleted successfully"
    });
});

const updateAnnouncement = asyncHandler(async (req, res) => {
    const { announcementId } = req.params;
    const updatedAnnouncement = await announcementService.updateAnnouncement(announcementId, req.body);
    res.status(200).json({
        success: true,
        message: "Announcement updated successfully",
        data: updatedAnnouncement
    });
});

const getAllCourseAnnouncements = asyncHandler(async (req, res) => {
    const { courseId } = req.params;
    const courseAnnouncements = await announcementService.getAllCourseAnnouncements(courseId);
    res.status(200).json({
        success: true,
        message: "Announcements fetched successfully",
        data: courseAnnouncements
    });
});

module.exports = {
    sendCourseAnnouncement,
    deleteAnnouncement,
    updateAnnouncement,
    getAllCourseAnnouncements
};

const assignmentService = require("../services/assignmentService");
const asyncHandler = require("../utilities/CatchAsync");
const path = require("path");

const createAssignment = asyncHandler(async (req, res) => {
  const { title, description,deadline } = req.body;
  const { courseId } = req.params;
  const teacherId = req.user._id;
  let document_id;
  if (req.file) {
    document_id = req.file.filename;
  }
  const assignment = await assignmentService.addAssignment(
    courseId,
    teacherId,
    title,
    description,
    deadline,
    document_id
  );
  res.status(201).json({
    success: true,
    message: "Assignment created successfully",
    data: assignment,
  });
});

const getAssignments = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const assignments = await assignmentService.getAssignmentsByCourse(courseId);
  res.status(200).json(assignments);
});

const getAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  const assignment = await assignmentService.getAssignment(
    courseId,
    assignmentId
  );
  res.status(200).json(assignment);
});

const updateAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  const { title, description, deadline } = req.body;
  const document_id = req.file ? req.file.filename : null;

  const updatedAssignment = await assignmentService.updateAssignment(
    courseId,
    assignmentId,
    title,
    description,
    deadline,
    document_id
  );
  res.status(200).json({
    success: true,
    message: "Assignment updated successfully",
    data: updatedAssignment,
  });
});

const deleteAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  await assignmentService.deleteAssignment(courseId, assignmentId);
  res.status(201).json({ message: "Assignment deleted successfully" });
});

const downloadAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;

  // Get the assignment details
  const assignment = await assignmentService.getAssignment(courseId, assignmentId);

  if (!assignment.document_id) {
    return res.status(404).json({ error: "Assignment document not found" });
  }

  // Construct the file path
  const filePath = path.join(__dirname, "..", "uploads", "assignments", assignment.document_id);

  // Send the file as a response
  res.download(filePath, (err) => {
    if (err) {
      return res.status(500).json({ error: "Failed to download the file" });
    }
  });
});

module.exports = {
  createAssignment,
  getAssignments,
  getAssignment,
  updateAssignment,
  deleteAssignment,
  downloadAssignment,
};

const asyncHandler = require("../utilities/CatchAsync");
const authService = require("../services/authService");
const AppError = require("../utilities/AppError");

const registerStudent = asyncHandler(async (req, res) => {
  const { name, email, pass } = req.body;
  const student = await authService.registerStudent(name, email, pass);
  res.status(201).json(student);
});

const loginStudent = asyncHandler(async (req, res) => {
  const { email, pass } = req.body;
  const student = await authService.loginStudent(email, pass);
  res.status(200).json(student);
});

const registerTeacher = asyncHandler(async (req, res) => {
  const { name, email, pass } = req.body;
  const teacher = await authService.registerTeacher(name, email, pass);
  res.status(201).json(teacher);
});

const loginTeacher = asyncHandler(async (req, res) => {
  const { email, pass } = req.body;
  const teacher = await authService.loginTeacher(email, pass);
  res.status(200).json(teacher);
});

const updateStudentPassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  const studentId = req.user._id;
  const updatedStudent = await authService.updateStudentPassword(
    studentId,
    currentPassword,
    newPassword
  );
  res.status(200).json(updatedStudent);
});

const updateStudentName = asyncHandler(async (req, res) => {
  const { newName } = req.body;
  const studentId = req.user._id;
  const updatedStudent = await authService.updateStudentName(
    studentId,
    newName
  );
  res.status(200).json(updatedStudent);
});

const updateTeacherPassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  const teacherId = req.user._id;
  const updatedTeacher = await authService.updateTeacherPassword(
    teacherId,
    currentPassword,
    newPassword
  );
  res.status(200).json(updatedTeacher);
});

const updateTeacherName = asyncHandler(async (req, res) => {
  const { newName } = req.body;
  const teacherId = req.user._id;
  const updatedTeacher = await authService.updateTeacherName(
    teacherId,
    newName
  );
  res.status(200).json(updatedTeacher);
});

const getStudentInfo = asyncHandler(async (req, res) => {
  const studentId = req.params.id;
  const studentInfo = await authService.getStudentInfo(studentId);
  res.status(200).json(studentInfo);
});

const getTeacherInfo = asyncHandler(async (req, res) => {
  const teacherId = req.params.id;
  const teacherInfo = await authService.getTeacherInfo(teacherId);
  res.status(200).json(teacherInfo);
});

const uploadStudentImage = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }
  const studentId = req.user._id;
  const imageName = req.file.filename;

  const student = await authService.uploadStudentImage(studentId, imageName);
  res.status(200).json(student);
});

const uploadTeacherImage = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }
  const teacherId = req.user._id;
  const imageName = req.file.filename;

  const teacher = await authService.uploadTeacherImage(teacherId, imageName);
  res.status(200).json(teacher);
});

const generateOtp = asyncHandler(async (req, res) => {
  const account_id = req.user.account;
  const otp = await authService.generateOtp(account_id); // Call service to generate OTP and send it
  if (!otp) {
    throw new AppError("Failed to generate OTP", 404);
  }
  res.status(200).json({ message: "OTP sent successfully" });
});

const verifyOtp = asyncHandler(async (req, res) => {
  const { otp } = req.body;
  const account_id = req.user.account;
  await authService.verifyOtp(account_id, otp); // Call service to verify OTP and update the account
  res.status(200).json({ message: "Email verified successfully" });
});

const registerStudentFace = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }
  const studentId = req.user._id; // Assuming you have middleware to authenticate and set req.user
  const imagePath = req.file.path; // Path of the uploaded image

  await authService.registerStudentFace(studentId, imagePath);
  res
    .status(200)
    .json({ success: true, message: "Face data registered successfully" });
});

const verifyStudentFace = asyncHandler(async (req, res) => {
  if(!req.file){
    throw new AppError("Please provide an image")
  }
  const studentId = req.user._id; // Assuming `req.user` is set by authentication middleware
  const imagePath = req.file.path; // Path of the uploaded image
  const encoding = req.user.face_biometric_data
  const result = await authService.verifyStudentFace(
    studentId,
    imagePath,
    encoding
  );
  res.status(200).json(result);
});

module.exports = {
  registerStudent,
  loginStudent,
  registerTeacher,
  loginTeacher,
  updateStudentPassword,
  updateStudentName,
  updateTeacherPassword,
  updateTeacherName,
  getStudentInfo,
  getTeacherInfo,
  uploadStudentImage,
  uploadTeacherImage,
  generateOtp,
  verifyOtp,
  registerStudentFace,
  verifyStudentFace,
};

const asyncHandler = require("../utilities/CatchAsync");
const courseService = require("../services/courseService");

const createCourse = asyncHandler(async (req, res) => {
  const data = req.body;
  const result = await courseService.createCourse(req.user._id, data);
  res.status(201).json({
    success: true,
    message: "Course Created",
    data: result,
  });
});

const joinCourse = asyncHandler(async (req, res) => {
  const result = await courseService.joinCourse(req.user._id, req.query.courseCode);
  res.status(201).json({
    success: true,
    message: "Course Joined",
    data: result,
  });
});

const updateCourseName = asyncHandler(async (req, res) => {
  await courseService.updateCourseName(req.params.courseId, req.query.courseName);
  res.status(201).json({
    success: true,
    message: "Course Name Updated",
  });
});

const deleteCourse = asyncHandler(async (req, res) => {
  await courseService.deleteCourse(req.params.courseId, req.user._id);
  res.status(201).json({
    success: true,
    message: "Course Deleted",
  });
});

const leaveCourse = asyncHandler(async (req, res) => {
  await courseService.leaveCourse(req.params.courseId, req.user._id);
  res.status(201).json({
    success: true,
    message: "Course Left",
  });
});

const updateProjectSchedule = asyncHandler(async (req, res) => {
  const result = await courseService.updateProjectSchedule(req.params.courseId, req.body.startDate, req.body.endDate);
  res.status(201).json({
    success: true,
    message: "Project Schedule Updated",
    data: result,
  });
});

const updateVivaSchedule = asyncHandler(async (req, res) => {
  const result = await courseService.updateVivaSchedule(req.params.courseId, req.body.startDate, req.body.endDate);
  res.status(201).json({
    success: true,
    message: "Viva Schedule Updated",
    data: result,
  });
});

const sendAllCourses = asyncHandler(async (req, res) => {
  const result = await courseService.sendAllCourses(req.user.id);
  res.status(201).json({
    success: true,
    data: result,
  });
});

const sendCourse = asyncHandler(async (req, res) => {
  const result = await courseService.sendCourse(req.params.courseId);
  res.status(201).json({
    success: true,
    data: result,
  });
});

const updateCourse = asyncHandler(async (req, res) => {
  const result = await courseService.updateCourse(req.params.courseId, req.body);
  res.status(201).json({
    success: true,
    message: "Course Updated",
    data: result,
  });
});

const regenerateCourseCode = asyncHandler(async (req, res) => {
  const result = await courseService.regenerateCourseCode(req.params.courseId);
  res.status(201).json({
    success: true,
    message: "Course Code Regenerated",
    data: result,
  });
});

const addStudentToCourse = asyncHandler(async (req, res) => {
  const studentId = req.body.studentId;
  const courseId = req.params.courseId;
  const result = await courseService.addStudentToCourse(courseId, studentId);
  res.status(201).json({
    success: true,
    message: "Student Added to Course",
    data: result,
  });
});

const removeStudentFromCourse = asyncHandler(async (req, res) => {
  const studentId = req.body.studentId;
  const courseId = req.params.courseId;
  await courseService.removeStudentFromCourse(courseId, studentId);
  res.status(201).json({
    success: true,
    message: "Student Removed from Course",
  });
});

const searchStudent = asyncHandler(async (req, res) => {
  const studentEmail = req.query.search;
  const result = await courseService.searchStudent(studentEmail);
  res.status(201).json({
    success: true,
    data: result,
  });
});

module.exports = {
  createCourse,
  joinCourse,
  deleteCourse,
  updateCourseName,
  updateProjectSchedule,
  updateVivaSchedule,
  leaveCourse,
  sendAllCourses,
  sendCourse,
  updateCourse,
  regenerateCourseCode,
  addStudentToCourse,
  removeStudentFromCourse,
  searchStudent,
};

const lectureService = require("../services/lectureService");
const asyncHandler = require("../utilities/CatchAsync");
const path = require("path");

const createLecture = asyncHandler(async (req, res) => {
  const { title, description } = req.body;
  const { courseId } = req.params;
  const teacherId = req.user._id;
  let video_id;
  if (req.file) {
    video_id = req.file.filename;
  }
  const lecture = await lectureService.addLecture(
    courseId,
    teacherId,
    title,
    description,
    video_id
  );
  res.status(201).json({
    success: true,
    message: "Lecture created successfully",
    data: lecture,
  });
});

const getLectures = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const lectures = await lectureService.getLecturesByCourse(courseId);
  res.status(200).json(lectures);
});

const getLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;
  const lecture = await lectureService.getLecture(courseId, lectureId);
  res.status(200).json(lecture);
});

const updateLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;
  const { title, description } = req.body;
  const video_id = req.file ? req.file.filename : null;
  const updatedLecture = await lectureService.updateLecture(
    courseId,
    lectureId,
    title,
    description,
    video_id
  );
  res.status(200).json({
    success: true,
    message: "Lecture updated successfully",
    data: updatedLecture,
  });
});

const deleteLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;
  await lectureService.deleteLecture(courseId, lectureId);
  res.status(201).json({ message: "Lecture deleted successfully" });
});

const downloadLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;

  const lecture = await lectureService.getLecture(courseId, lectureId);

  if (!lecture.video_id) {
    return res.status(404).json({ error: "Lecture video not found" });
  }

  const filePath = path.join(
    __dirname,
    "..",
    "uploads",
    "lectures",
    lecture.video_id
  );

  res.download(filePath, (err) => {
    if (err) {
      return res.status(500).json({ error: "Failed to download the file" });
    }
  });
});

module.exports = {
  createLecture,
  getLectures,
  getLecture,
  updateLecture,
  deleteLecture,
  downloadLecture,
};

const pollService = require("../services/pollService");
const asyncHandler = require("../utilities/CatchAsync");


const createPoll = asyncHandler(async (req, res) => {
  const { title, description, options } = req.body;
  const { courseId } = req.params;
  const teacherId = req.user._id;

  const poll = await pollService.addPoll(courseId, teacherId, title, description, options);
  res.status(201).json({
    success: true,
    message: "Poll created successfully",
    data: poll,
  });
});

const getPolls = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const polls = await pollService.getPollsByCourse(courseId);
  res.status(200).json(polls);
});

const getPoll = asyncHandler(async (req, res) => {
  const { courseId, pollId } = req.params;
  const poll = await pollService.getPoll(courseId, pollId);
  res.status(200).json(poll);
});

const votePoll = asyncHandler(async (req, res) => {
  const { courseId, pollId } = req.params;
  const { option } = req.body;
  const studentId = req.user._id;

  const poll = await pollService.votePoll(courseId, pollId, studentId, option);
  res.status(200).json({
    success: true,
    message: "Voted successfully",
    data: poll,
  });
});

const deletePoll = asyncHandler(async (req, res) => {
  const { courseId, pollId } = req.params;
  await pollService.deletePoll(courseId, pollId);
  res.status(200).json({ message: "Poll deleted successfully" });
});

module.exports = {
  createPoll,
  getPolls,
  getPoll,
  votePoll,
  deletePoll,
};

const asyncHandler = require("../utilities/CatchAsync");
const axios = require("axios");
const AppError = require("../utilities/AppError");
const proctoringService = require("../services/proctoringService");



const analyzeImage = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }
  
  const studentId = req.user._id; // Get the student ID from the authenticated user
  const quizId = req.params.quizId; // Get the quiz ID from the route parameters
  const imagePath = req.file.path; // Path of the uploaded image

  // Check if the quiz submission exists and is within the allowed time frame
  const result = await proctoringService.analyzeImage(studentId, quizId, imagePath);
  
  res.status(200).json(result);
});

const generateReport = asyncHandler(async (req, res) => {
  const { courseId, quizId, studentId } = req.params;

  // Generate PDF report
  const pdfBuffer = await proctoringService.generatePdfReport(courseId, quizId, studentId);

  // Send the generated PDF as a response
  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', `attachment; filename=report_${studentId}.pdf`);
  res.send(pdfBuffer);
});


module.exports = {
  analyzeImage,
  generateReport,
};

const asyncHandler = require("../utilities/CatchAsync");
const projectService = require("../services/projectService");

const createProject = asyncHandler(async (req, res) => {
  const projectData = req.body;
  const userId = req.user._id;
  const project = await projectService.createProject(userId, projectData);
  res.status(201).json({
    success: true,
    message: "Project Created Successfully",
    data: project,
  });
});

const updateProject = asyncHandler(async (req, res) => {
  const projectId = req.params.projectId;
  const projectData = req.body;
  const updatedProject = await projectService.updateProject(
    projectId,
    projectData
  );
  res.status(201).json({
    success: true,
    message: "Updated Successfully",
    data: updatedProject,
  });
});

const sendProject = asyncHandler(async (req, res) => {
  const projectId = req.params.projectId;
  const project = await projectService.getProjectById(projectId);
  res.status(201).json({
    success: true,
    message: "Project Found",
    data: project,
  });
});

const addMember = asyncHandler(async (req, res) => {
  const { projectId, courseId } = req.params;
  const { email } = req.body;
  const project = await projectService.addMemberToProject(
    projectId,
    email,
    courseId
  );
  res.status(200).json({
    success: true,
    message: "Member added successfully",
    data: project,
  });
});

const removeMember = asyncHandler(async (req, res) => {
  const { projectId, memberId } = req.params;
  const project = await projectService.removeMemberFromProject(
    projectId,
    memberId
  );
  res.status(200).json({
    success: true,
    message: "Member removed successfully",
    data: project,
  });
});


const deleteProject = asyncHandler(async (req, res) => {
  const projectId = req.params.projectId;
  const userId = req.user._id; // Assume the user's ID is available in the request
  await projectService.deleteProject(projectId, userId);
  res.status(200).json({
      success: true,
      message: "Project deleted successfully"
  });
});

module.exports = {
  createProject,
  updateProject,
  sendProject,
  addMember,
  removeMember,
  deleteProject
};

const asyncHandler = require("../utilities/CatchAsync");
const quizService = require("../services/quizService");

const createQuiz = asyncHandler(async (req, res) => {
  const { title, topic, questions, deadline, duration, number_of_questions } =
    req.body;
  const { courseId } = req.params;
  const quiz = await quizService.createQuiz(
    courseId,
    title,
    topic,
    questions,
    deadline,
    duration,
    number_of_questions
  );
  res.status(201).json({
    success: true,
    message: "Quiz created successfully",
    data: {
      quiz,
    },
  });
});

const updateQuiz = asyncHandler(async (req, res) => {
  const { title, topic, questions, deadline, duration, number_of_questions } =
    req.body;
  const { id } = req.params;
  const quiz = await quizService.updateQuiz(
    id,
    title,
    topic,
    questions,
    deadline,
    duration,
    number_of_questions
  );
  res.status(200).json({
    success: true,
    message: "Quiz updated successfully",
    data: { quiz },
  });
});

const deleteQuiz = asyncHandler(async (req, res) => {
  const { id, courseId } = req.params;
  await quizService.deleteQuiz(id, courseId);
  res.status(200).json({
    success: true,
    message: "Quiz deleted successfully",
  });
});

const getQuiz = asyncHandler(async (req, res) => {
  const { id, courseId } = req.params;
  const quiz = await quizService.getQuiz(id, courseId);
  res.status(200).json(quiz);
});

const getQuizStudent = asyncHandler(async (req, res) => {
  const { id, courseId } = req.params;
  const quiz = await quizService.getQuizStudent(id, courseId);
  res.status(200).json(quiz);
});

const getQuizzesByCourse = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const quizzes = await quizService.getQuizzesByCourse(courseId);
  res.status(200).json(quizzes);
});

const startQuiz = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const studentId = req.user._id;
  const submission = await quizService.startQuiz(id, studentId);
  res.status(200).json({
    success: true,
    message: "Quiz started successfully",
    data: submission,
  });
});

const submitQuiz = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const studentId = req.user._id;
  const { answers } = req.body;
  const submission = await quizService.submitQuiz(id, studentId, answers);
  res.status(200).json({
    success: true,
    message: "Quiz submitted successfully",
    data: { submission },
  });
});

const updateSubmissionMarks = asyncHandler(async (req, res) => {
  const { courseId, quizId, submissionId } = req.params;
  const {newScore} = req.body;
  const submission = await quizService.updateSubmissionMarks(courseId, quizId, submissionId, newScore);
  res.status(200).json({
    success: true,
    message: "Quiz submission marks updated successfully",
    data: { submission },
  });
});

// Update the isFlagged status of a submission
const updateSubmissionFlag = asyncHandler(async (req, res) => {
  const { courseId, quizId, submissionId } = req.params;
  const { isFlagged } = req.body;

  // Call the service to update the flag status
  const updatedSubmission = await quizService.updateSubmissionFlag(courseId, quizId, submissionId, isFlagged);

  res.status(200).json({
      success: true,
      message: 'Submission flag status updated successfully',
      data: {
          submission: updatedSubmission,
      },
  });
});


module.exports = {
  createQuiz,
  updateQuiz,
  deleteQuiz,
  getQuiz,
  getQuizzesByCourse,
  getQuizStudent,
  startQuiz,
  submitQuiz,
  updateSubmissionMarks,
  updateSubmissionFlag
};

const asyncHandler = require("../utilities/CatchAsync");
const remarkService = require("../services/remarkService");

const addRemarkToViva = asyncHandler(async (req, res) => {
  const { courseId, projectId } = req.params;
  const data = await remarkService.addRemarkToViva(
    courseId,
    projectId,
    req.body
  );
  res.status(201).json({
    success: true,
    message: "Remark Added Successfully",
    data,
  });
});

const updateRemark = asyncHandler(async (req, res) => {
  const { remarkId } = req.params;
  const updatedRemark = await remarkService.updateRemark(remarkId, req.body);
  res.status(201).json({
    success: true,
    message: "updated successfully",
    data: updatedRemark,
  });
});

const sendRemark = asyncHandler(async (req, res) => {
  const { remarkId, projectId, courseId } = req.params;
  const remark = await remarkService.sendRemark(remarkId, projectId, courseId);
  res.status(201).json({
    success: true,
    message: "Remark Sent Successfully",
    data: remark,
  });
});

//For Submissions
const addRemarkToSubmission = asyncHandler(async (req, res) => {
  const { courseId, submissionId } = req.params;
  const data = await remarkService.addRemarkToSubmission(
    courseId,
    submissionId,
    req.body
  );
  res.status(201).json({
    success: true,
    message: "Remark Added Successfully",
    data,
  });
});

const updateSubmissionRemark = asyncHandler(async (req, res) => {
  const { remarkId } = req.params;
  const updatedRemark = await remarkService.updateRemark(remarkId, req.body); // Assuming you reuse the updateRemark service function
  res.status(201).json({
    success: true,
    message: "Remark updated successfully",
    data: updatedRemark,
  });
});

const readSubmissionRemark = asyncHandler(async (req, res) => {
  const { remarkId, submissionId } = req.params;
  const studentId = req.user._id;
  const remark = await remarkService.readSubmissionRemark(
    remarkId,
    submissionId,
    studentId
  );
  res.status(201).json({
    success: true,
    message: "Remark retrieved successfully",
    data: remark,
  });
});

module.exports = {
  addRemarkToViva,
  updateRemark,
  sendRemark,
  addRemarkToSubmission,
  updateSubmissionRemark,
  readSubmissionRemark,
};

const asyncHandler = require("../utilities/CatchAsync");
const statusService = require("../services/statusService");

const addStatus = asyncHandler(async (req, res) => {
    const { courseId, projectId } = req.params;
    const statusData = req.body;
    const status = await statusService.addStatus(courseId, projectId, statusData);
    res.status(201).json({
        success: true,
        message: "Added Successfully",
        data: status
    });
});

const updateStatus = asyncHandler(async (req, res) => {
    const { statusId } = req.params;
    const statusData = req.body;
    const status = await statusService.updateStatus(statusId, statusData);
    res.status(201).json({
        success: true,
        message: "Updated Successfully",
        data: status
    });
});

const sendStatus = asyncHandler(async (req, res) => {
    const { statusId } = req.params;
    const status = await statusService.getStatusById(statusId);
    res.status(201).json({
        success: true,
        message: "Status Found",
        data: status
    });
});

module.exports = {
    addStatus,
    updateStatus,
    sendStatus
};

const submissionService = require("../services/submissionService");
const asyncHandler = require("../utilities/CatchAsync");
const path = require("path");

const createSubmission = asyncHandler(async (req, res) => {
  if (!req.file) {
    res.status(400);
    throw new Error("No file uploaded");
  }
  const { courseId, assignmentId } = req.params;
  const document_id = req.file.filename;
  const studentId = req.user._id;
  const submission = await submissionService.addSubmission(
    courseId,
    assignmentId,
    studentId,
    document_id
  );

  res.status(201).json({
    success: true,
    message: "Submission created successfully",
    data: submission,
  });
});

const getSubmissions = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  const submissions = await submissionService.getSubmissionsByAssignment(
    courseId,
    assignmentId
  );
  res.status(200).json(submissions);
});

const getSubmission = asyncHandler(async (req, res) => {
  const { assignmentId, submissionId } = req.params;
  const studentId = req.user._id;
  const submission = await submissionService.getSubmission(
    assignmentId,
    submissionId,
    studentId
  );
  res.status(200).json(submission);
});

const updateSubmission = asyncHandler(async (req, res) => {
  if (!req.file) {
    res.status(400);
    throw new Error("No file uploaded");
  }
  const { assignmentId, submissionId } = req.params;
  const document_id = req.file.filename;
  const studentId = req.user._id;

  const updatedSubmission = await submissionService.updateSubmission(
    assignmentId,
    submissionId,
    studentId,
    document_id
  );

  res.status(200).json({
    success: true,
    message: "Submission updated successfully",
    data: updatedSubmission,
  });
});

const deleteSubmission = asyncHandler(async (req, res) => {
  const { assignmentId, submissionId } = req.params;
  const studentId = req.user._id;
  await submissionService.deleteSubmission(assignmentId, submissionId, studentId);
  res.status(200).json({ message: "Submission deleted successfully" });
});

const downloadSubmission = asyncHandler(async (req, res) => {
  const { assignmentId, submissionId } = req.params;
  const studentId = req.user._id;
  const submission = await submissionService.getSubmission(
    assignmentId,
    submissionId,
    studentId
  );
  res.download(path.join(__dirname, "../uploads", "submissions", submission.document_id));
});

const downloadSubmissionTeacher = asyncHandler(async (req, res) => {
  const { courseId, submissionId } = req.params;
  const submission = await submissionService.getSubmissionTeacher(submissionId);
  res.download(path.join(__dirname, "../uploads", "submissions", submission.document_id));
});

module.exports = {
  createSubmission,
  getSubmissions,
  getSubmission,
  updateSubmission,
  deleteSubmission,
  downloadSubmission,
  downloadSubmissionTeacher,
};

const asyncHandler = require('../utilities/CatchAsync');
const vivaService = require('../services/vivaService');

const addViva = asyncHandler(async (req, res) => {
    const { courseId, projectId } = req.params;
    const viva = await vivaService.addViva(courseId, projectId);
    res.status(201).json({
        success: true,
        message: "Viva added successfully",
        data:viva,
    });
});

const updateViva = asyncHandler(async (req, res) => {
    const { vivaId } = req.params;
    const updatedViva = await vivaService.updateViva(vivaId, req.body);
    res.status(201).json({
        success: true,
        message: "Viva updated successfully",
        data: updatedViva,
    });
});

const sendViva = asyncHandler(async (req, res) => {
    const { vivaId } = req.params;
    const viva = await vivaService.sendViva(vivaId);
    res.status(201).json({
        success: true,
        message: "Viva sent successfully",
        data: viva,
    });
});

const getTodaysViva = asyncHandler(async (req, res) => {
    const { courseId } = req.params;
    const vivas = await vivaService.getTodaysViva(courseId);
    res.status(201).json({
        success: true,
        message: "Today's vivas fetched successfully",
        data: vivas,
    });
});

const getAllVivas = asyncHandler(async (req, res) => {
    const { courseId } = req.params;
    const vivas = await vivaService.getAllVivas(courseId);
    res.status(201).json({
        success: true,
        message: "All vivas fetched successfully",
        data: vivas,
    });
});

module.exports = {
    addViva,
    updateViva,
    sendViva,
    getTodaysViva,
    getAllVivas,
};

const Student = require("../models/Student");
const Teacher = require("../models/Teacher");
const Project = require("../models/Project");
const asyncHandler = require("../utilities/CatchAsync");
const AppError = require("../utilities/AppError");
const Course = require("../models/Course");

const isTeacher = asyncHandler(async (req, res, next) => {
  const teacher = await Teacher.findById(req.user._id);
  if (!teacher) {
    throw new AppError("Not Authorized", 401);
  }
  next();
});
const isStudent = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.user._id);
  if (!student) {
    throw new AppError("Not Authorized", 401);
  }
  next();
});

const isCourseCreator = asyncHandler(async (req, res, next) => {
  const courseId = req.params.courseId;
  const getCourse = await Course.findById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 401);
  }
  const teacher = await Teacher.findById(req.user._id);
  if (getCourse.teacher._id != teacher.id) {
    throw new AppError(
      "Not Authorized only course creator can perform this action",
      401
    );
  }
  next();
});

const isCourseStudent = asyncHandler(async (req, res, next) => {
  var isStudent = false;
  const courseId = req.body.courseId || req.params.courseId;

  for (const course_ of req.user.courses) {
    if (course_ == courseId) {
      isStudent = true;
    }
  }
  if (isStudent) {
    next();
  } else {
    throw new AppError("Not Authorized Not Student Of This Course", 401);
  }
});

const isProjectCreator = asyncHandler(async (req, res, next) => {
  const { projectId } = req.params;
  const project = await Project.findById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 401);
  } else {
    if (project.projectLeader._id != req.user.id) {
      throw new AppError(
        "Not Authorized Only Project Leader Of This Project Can Change",
        401
      );
    }
  }
  next();
});

const isProjectGroupMember = asyncHandler(async (req, res, next) => {
  const { projectId } = req.params;
  const project = await Project.findById(projectId);
  if (project.projectLeader._id == req.user.id) {
    next();
    return;
  }
  var isMember = false;
  if (!project) {
    throw new AppError("Project Not Found", 401);
  } else {
    for (let member of project.members) {
      if (member == req.user.id) {
        isMember = true;
        break;
      }
    }
  }
  if (isMember) {
    next();
  } else {
    throw new AppError(
      "Not Authorized Only Group Members Of Project Can View The Status",
      401
    );
  }
});

const isCourseCreatorOrCourseStudent = asyncHandler(async (req, res, next) => {
  const { courseId } = req.params;

  // Find the course by ID
  const course = await Course.findById(courseId).populate("teacher");
  if (!course) {
    throw new AppError("Course Not Found", 404);
  }

  const userId = req.user._id;

  // Check if the user is the course creator (teacher)
  if (course.teacher._id.toString() === userId.toString()) {
    return next();
  }

  // Check if the user is a student in the course
  const isStudent = course.students.some(
    (studentId) => studentId.toString() === userId.toString()
  );

  if (isStudent) {
    return next();
  }

  // If neither, throw an authorization error
  throw new AppError(
    "Not Authorized: You must be either the course creator or a student of this course",
    401
  );
});

module.exports = {
  isTeacher,
  isStudent,
  isCourseCreator,
  isCourseStudent,
  isProjectCreator,
  isProjectGroupMember,
  isCourseCreatorOrCourseStudent,
};

const AppError = require("../utilities/AppError")

const notFound= (req,res,next)=>{
    const error= new AppError("Requested Source Not Found",404);
    next(error);
}

const errorHandler=(err,req,res,next)=>{
    const status= err.status || 500;
    res.status(status).json({
        message:err.message
    })
}

module.exports={notFound,errorHandler}
const asyncHandler = require("../utilities/CatchAsync");
const AppError = require("../utilities/AppError");
const authRepository = require("../repositories/authRepository");

const isEmailVerified = asyncHandler(async (req, res, next) => {
  const userId = req.user._id; // Assuming `req.user` is set by authentication middleware

  // First, check if the user is a student
  let student = await authRepository.findStudentById(userId);
  if (student) {
    const account = await authRepository.findAccountById(student.account);
    if (!account) {
      return next(new AppError("Account not found", 404));
    }
    if (!account.email_verified) {
      return next(new AppError("Email not verified", 403));
    }
    return next(); // Proceed if the email is verified
  }

  // If not a student, check if the user is a teacher
  let teacher = await authRepository.findTeacherById(userId);
  if (teacher) {
    const account = await authRepository.findAccountById(teacher.account);
    if (!account) {
      return next(new AppError("Account not found", 404));
    }
    if (!account.email_verified) {
      return next(new AppError("Email not verified", 403));
    }
    return next(); // Proceed if the email is verified
  }

  // If not a student or teacher
  return next(new AppError("User not found", 404));
});

module.exports = { isEmailVerified };

const jwt= require('jsonwebtoken')
const Student= require('../models/Student')
const Teacher= require('../models/Teacher')
const asyncHandler=require('../utilities/CatchAsync');
const AppError = require('../utilities/AppError');

const isLogin= asyncHandler(async (req,res,next)=>{
    let token;
    if(
        req.headers.authorization &&
        req.headers.authorization.startsWith("Bearer")
    ){
        try{
            token=req.headers.authorization.split(" ")[1];
            const decoded= jwt.verify(token,"hi");
            const teacher=await Teacher.findById(decoded.id);
            const student=await Student.findById(decoded.id);
            if(teacher){
                req.user=teacher;
            }else if(student){
                req.user=student;
            }else{
                throw new AppError("NOT AUTHORIZED, TOKEN FAILED!",201);
            }
            next();
        }catch(error){
            throw new AppError("NOT AUTHORIZED, TOKEN FAILED!",201);
        }
    }
    if(!token){
        throw new AppError("NOT AUTHORIZED, NO TOKEN");
    }
})

module.exports={
    isLogin
};
const { registerSchema, loginSchema,updateNameSchema,updatePasswordSchema,otpSchema,emailSchema } = require("../schemas/authSchema");
const { courseSchema } = require("../schemas/courseSchema");
const { dateSchema } = require("../schemas/dateSchema");
const { projectSchema } = require("../schemas/projectSchema");
const { remarkSchema } = require("../schemas/remarkSchema");
const { statusSchema } = require("../schemas/statusSchema");
const { vivaSchema } = require("../schemas/vivaSchema");
const { reviewSchema } = require("../schemas/reviewSchema");
const { announcementSchema } = require("../schemas/announcementSchema");
const { quizSchema } = require("../schemas/quizSchema");
const {updateSubmissionMarksSchema} = require("../schemas/updateSubmissionMarksSchema");
const {updateSubmissionFlagSchema} = require("../schemas/updateSubmissionFlagSchema");
const { assignmentSchema } = require("../schemas/assignmentSchema");
const { pollSchema } = require("../schemas/pollSchema");
const { addRemoveStudentSchema } = require("../schemas/addRemoveStudentSchema");

const AppError = require("../utilities/AppError");

module.exports.validateRegister = (req, res, next) => {
  const { error } = registerSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateLogin = (req, res, next) => {
  const { error } = loginSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateCourse = (req, res, next) => {
  // console.log(req.body);
  const { error } = courseSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateDate = (req, res, next) => {
  // console.log(req.body);
  const { error } = dateSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateProject = (req, res, next) => {
  // console.log(req.body);
  const { error } = projectSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateRemark = (req, res, next) => {
  // console.log(req.body);
  const { error } = remarkSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateStatus = (req, res, next) => {
  // console.log(req.body);
  const { error } = statusSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateViva = (req, res, next) => {
  // console.log(req.body);
  const { error } = vivaSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateReview = (req, res, next) => {
  // console.log(req.body);
  const { error } = reviewSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateAnnouncement = (req, res, next) => {
  // console.log(req.body);
  const { error } = announcementSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdatePassword = (req, res, next) => {
  const { error } = updatePasswordSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdateName = (req, res, next) => {
  const { error } = updateNameSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateOtp = (req, res, next) => {
  const { error } = otpSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateQuiz = (req, res, next) => {
  const { error } = quizSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdateQuizScore = (req,res,next) =>{
  const { error } = updateSubmissionMarksSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdateSubmissionFlag = (req,res,next) =>{
  const { error } = updateSubmissionFlagSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};


module.exports.validateAssignment = (req, res, next) => {
  const { error } = assignmentSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validatePoll = (req, res, next) => {
  const { error } = pollSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateAddRemoveStudent = (req, res, next) => {
  const { error } = addRemoveStudentSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};
const multer = require("multer");
const path = require("path");
const fs = require("fs");

const assignment_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "assignments"
);

if (!fs.existsSync(assignment_dataDir)) {
  fs.mkdirSync(assignment_dataDir, { recursive: true });
}

const assignmentStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, assignment_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const assignmentStorageFilter = (req, file, cb) => {
  const allowedTypes = /doc|docx|pdf/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadAssignment = multer({
    storage: assignmentStorage,
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter: assignmentStorageFilter,
});

module.exports = {
    uploadAssignment,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const face_images_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "face_biometric_data"
);

if (!fs.existsSync(face_images_dataDir)) {
  fs.mkdirSync(face_images_dataDir, { recursive: true });
}

const faceBiometricDataStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, face_images_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const faceBiometricDataStorageFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadFaceBiometricData = multer({
  storage: faceBiometricDataStorage,
  limits: { fileSize: 1 * 1024 * 1024 },
  fileFilter: faceBiometricDataStorageFilter,
});

module.exports = {
  uploadFaceBiometricData,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const lectureDataDir = path.join(__dirname, "..", "..", "uploads", "lectures");

if (!fs.existsSync(lectureDataDir)) {
  fs.mkdirSync(lectureDataDir, { recursive: true });
}

const lectureStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, lectureDataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const lectureStorageFilter = (req, file, cb) => {
  const allowedTypes = /mp4|avi|mkv/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only video files are allowed (mp4, avi, mkv)"));
  }
};

const uploadLecture = multer({
  storage: lectureStorage,
  limits: { fileSize: 100 * 1024 * 1024 }, // 100 MB limit
  fileFilter: lectureStorageFilter,
});

module.exports = {
  uploadLecture,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const proctor_images_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "proctor_images_data"
);

if (!fs.existsSync(proctor_images_dataDir)) {
  fs.mkdirSync(proctor_images_dataDir, { recursive: true });
}

const proctoringImageStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, proctor_images_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const proctoringImageStorageFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadProctoringImage = multer({
  storage: proctoringImageStorage,
  limits: { fileSize: 1 * 1024 * 1024 },
  fileFilter: proctoringImageStorageFilter,
});

module.exports = {
  uploadProctoringImage,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const profilePicturesDir = path.join(
  __dirname,
  "..",
  "..",
  "public",
  "profile_pictures"
);

if (!fs.existsSync(profilePicturesDir)) {
  fs.mkdirSync(profilePicturesDir, { recursive: true });
}

// Configuration for logo uploads
const profileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, profilePicturesDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const profileStorageFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadProfile = multer({
  storage: profileStorage,
  limits: { fileSize: 1 * 1024 * 1024 },
  fileFilter: profileStorageFilter,
});

module.exports = { uploadProfile };

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const submission_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "submissions"
);

if (!fs.existsSync(submission_dataDir)) {
  fs.mkdirSync(submission_dataDir, { recursive: true });
}

const submissionStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, submission_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const submissionStorageFilter = (req, file, cb) => {
  const allowedTypes = /doc|docx|pdf/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadSubmission = multer({
    storage: submissionStorage,
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter: submissionStorageFilter,
});

module.exports = {
    uploadSubmission,
};

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const accountSchema = new schema({
  email: String,
  username: String,
  profile_picture:String,
  password: String,
  email_verified: Boolean,
  notifications: [
    {
      type: schema.Types.ObjectId,
      ref: "Notification",
    },
  ],
  created_at: Date,
  updated_at: Date,
  otp:{
    type: schema.Types.ObjectId,
    ref: 'Otp'
  }
});
module.exports = mongoose.model("Account", accountSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const announcementSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  teacher: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  content: String,
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Announcement", announcementSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const assignmentSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  teacher: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  description: String,
  document_id: String,
  deadline: Date,
  submissions: [
    {
      type: schema.Types.ObjectId,
      ref: "Submission",
    },
  ],
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Assignment", assignmentSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const courseSchema = new schema({
  courseCode: String,
  courseName: String,
  description: String,
  projectRequirements: String,
  teacher: {
    type: schema.Types.ObjectId,
    ref: "Teacher",
  },
  vivas: [
    {
      type: schema.Types.ObjectId,
      ref: "Viva",
    },
  ],
  projects: [
    {
      type: schema.Types.ObjectId,
      ref: "Project",
    },
  ],
  announcements: [
    {
      type: schema.Types.ObjectId,
      ref: "Announcement",
    },
  ],
  polls: [
    {
      type: schema.Types.ObjectId,
      ref: "Poll",
    },
  ],
  lectures: [
    {
      type: schema.Types.ObjectId,
      ref: "Lecture",
    },
  ],
  assignments: [
    {
      type: schema.Types.ObjectId,
      ref: "Assignment",
    },
  ],
  quizzes:[
    {
      type: schema.Types.ObjectId,
      ref: "Quiz",  
    }
  ],
  students: [
    {
      type: schema.Types.ObjectId,
      ref: "Student",
    },
  ],
  projectStartDate: Date,
  projectEndDate: Date,
  vivaStartDate: Date,
  vivaEndDate: Date,
});
module.exports = mongoose.model("Course", courseSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const lectureSchema = new schema({
  course_id: { type: schema.Types.ObjectId, ref: "Course" },
  teacher_id: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  description: String,
  video_id: String,
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Lecture", lectureSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const notificationSchema = new schema({
  account: { type: schema.Types.ObjectId, ref: "Account" },
  content: String,
  read: Boolean,
  created_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Notification", notificationSchema);

// otpModel.js
const mongoose = require('mongoose');
const schema = mongoose.Schema;

const otpSchema = new schema({
  otp: Number,
  createdAt: { type: Date, default: Date.now } // Add createdAt field
});

module.exports = mongoose.model('Otp', otpSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const pollSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  teacher: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  description: String,
  options: {
    type: [{
      type: String,
      minlength: 1,
      maxlength: 100
    }],
    validate: {
      validator: function(options) {
        return options.length >= 2 && options.length <= 3;
      },
      message: "Options should have 2 to 3 elements."
    }
  },
  votes: [{ type: schema.Types.ObjectId, ref: "Vote" }],
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});
  
  module.exports = mongoose.model("Poll", pollSchema);
  
const mongoose = require("mongoose");
const schema = mongoose.Schema;

// Define the AIProctoringReport schema
const aiProctoringReportSchema = new schema({
    images: [{ type: schema.Types.ObjectId, ref: "ProctoringImage" }],
    cheating_indicators: {
      mobile_phone: Number,
      extra_person: Number,
      mouth_open: Number,
      no_person: Number,
      eye_left_right: Number
    },
    cheating_probability: Number,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
  });

module.exports = mongoose.model("AIProctoringReport", aiProctoringReportSchema);

const mongoose = require('mongoose');
const schema=mongoose.Schema;

const projectSchema=new schema({
    name:String,
    scope:String,
    members:[
        {
            type: schema.Types.ObjectId,
            ref:'Student',
            min:1,
            max:4
        }
    ],
    projectLeader:{
        type: schema.Types.ObjectId,
        ref:'Student'
    },
    course:{
        type: schema.Types.ObjectId,
        ref:'Course'
    },
    status:
    {
        type: schema.Types.ObjectId,
        ref:'Status'
    },
    viva:{
        type: schema.Types.ObjectId,
        ref:'Viva'
    }
});
module.exports=mongoose.model('Project',projectSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

// Define the ProctoringImage schema
const proctoringImageSchema = new schema({
  image_id: String,
  timestamp: { type: Date, default: Date.now },
  cheating_indicators: {
    mobile_phone: Boolean,
    extra_person: Boolean,
    mouth_open: Boolean,
    no_person: Boolean,
    eye_gaze: String
  },
});

module.exports = mongoose.model("ProctoringImage", proctoringImageSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const questionSchema = new schema({
  content: String,
  options: [{
    type:String,
    min: 4,
    max: 4
  }],
  correct_option: String,
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Question", questionSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const quizSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  title: String,
  topic:String,
  questions: [{ type: schema.Types.ObjectId, ref: "Question" }],
  duration: Number,
  number_of_questions: Number,
  deadline: Date,
  submissions: [{ type: schema.Types.ObjectId, ref: "QuizSubmission" }],
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Quiz", quizSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const submissionSchema = new schema({
  quiz: { type: schema.Types.ObjectId, ref: "Quiz" },
  student: { type: schema.Types.ObjectId, ref: "Student" },
  proctoringReport: { type: schema.Types.ObjectId, ref: "AIProctoringReport" },
  answers: [
    {
      question: { type: schema.Types.ObjectId, ref: "Question" },
      selectedOption: String,
    },
  ],
  score: Number,
  startedAt: { type: Date, default: Date.now },
  endTime: { type: Date },
  submittedAt: { type: Date },
  isCompleted: { type: Boolean, default: false },
  isFlagged: { type: Boolean, default: false },
});

module.exports = mongoose.model("QuizSubmission", submissionSchema);

const mongoose = require('mongoose');
const schema=mongoose.Schema;

const remarkSchema=new schema({
    overallPerformance: { type: String, enum: ['Bad', 'Poor', 'Fair', 'Good', 'Excellent'] },
    feedback: String,
    obtainedMarks: Number,
    totalMarks: Number,
    dateCreated: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
});
module.exports=mongoose.model('Remarks',remarkSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const statusSchema=new schema({
    status:{
        type:String,
        enum:['approved','pending','disapproved']
    },
    description:String
});
module.exports=mongoose.model('Status',statusSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const studentSchema=new schema({
    name:String,
    isGroupLeader:Boolean,
    face_biometric_data:[Number],
    courses :[{
        type: schema.Types.ObjectId,
        ref:'Course'
    }],
    account:{
        type: schema.Types.ObjectId,
        ref:'Account'
    }
});
module.exports=mongoose.model('Student',studentSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const submissionSchema = new schema({
  student: { type: schema.Types.ObjectId, ref: "Student" },
  assignment: { type: schema.Types.ObjectId, ref: "Assignment" },
  document_id: String,
  remarks: {type: schema.Types.ObjectId, ref: "Remarks"},
  submitted_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Submission", submissionSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const teacherSchema=new schema({
    name:String,
    courses:[{
        type: schema.Types.ObjectId,
        ref:'Course'
    }],
    account:{
        type: schema.Types.ObjectId,
        ref:'Account'
    }
});
module.exports=mongoose.model('Teacher',teacherSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const vivaSchema=new schema({
    status:{
        type:String,
        enum:['scheduled','taken']
    },
    remarks:{
        type: schema.Types.ObjectId,
        ref:'Remarks'
    },
    dateCreated:{
        type:Date
    },
    vivaDate:{
        type:Date
    }
});
module.exports=mongoose.model('Viva',vivaSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const voteSchema = new schema({
  poll: { type: schema.Types.ObjectId, ref: "Poll", required: true },
  student: { type: schema.Types.ObjectId, ref: "Student", required: true },
  option: { type: String, required: true },
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Vote", voteSchema);

const Course = require("../models/Course");
const Announcement = require("../models/Announcement");

const findCourseById = (courseId) => Course.findById(courseId);
const findCourseByIdWithAnnouncements = (courseId) => Course.findById(courseId).populate('announcements');
const createAnnouncement = (announcementData) => Announcement.create(announcementData);
const deleteAnnouncementById = (announcementId) => Announcement.findByIdAndDelete(announcementId);
const updateAnnouncementById = (announcementId, updateData) => Announcement.findByIdAndUpdate(announcementId, updateData, { new: true });
const findAnnouncementById = (announcementId) => Announcement.findById(announcementId);

module.exports = {
    findCourseById,
    findCourseByIdWithAnnouncements,
    createAnnouncement,
    deleteAnnouncementById,
    updateAnnouncementById,
    findAnnouncementById
};

const Assignment = require("../models/Assisgnment");

const createAssignment = async (assignmentData) => {
  const assignment = new Assignment(assignmentData);
  return await assignment.save();
};

const getAssignments = async (courseId) => {
  return await Assignment.find({ course: courseId });
};

const getAssignmentById = async (assignmentId) => {
  return await Assignment.findById(assignmentId);
};

const getAssignmentByTitleAndCourse = async (title, courseId) => {
  return await Assignment.findOne({
    title,
    course: courseId,
  });
};

const deleteAssignmentById = async (assignmentId) => {
  return await Assignment.findByIdAndDelete(assignmentId);
};

const saveAssignment = async (assignment) => {
  return await assignment.save();
};

module.exports = {
  createAssignment,
  getAssignments,
  getAssignmentById,
  getAssignmentByTitleAndCourse,
  deleteAssignmentById,
  saveAssignment,
};

const Account = require('../models/Account');
const Student = require('../models/Student');
const Teacher = require('../models/Teacher');
const Otp = require('../models/OtpModel');

const findAccountByEmail = (email) => Account.findOne({ email });
const findStudentByAccountId = (accountId) => Student.findOne({ account: accountId });
const findTeacherByAccountId = (accountId) => Teacher.findOne({ account: accountId });
const createAccount = (email, password) => Account.create({ email, password });
const createStudent = (name, accountId) => Student.create({ name, account: accountId, isGroupLeader: false });
const createTeacher = (name, accountId) => Teacher.create({ name, account: accountId });
const findStudentById = (studentId) => Student.findById(studentId).populate('account');
const findTeacherById = (teacherId) => Teacher.findById(teacherId).populate('account');
const findAccountById = (accountId) => Account.findById(accountId).populate('otp');
const updateAccountEmailVerification = (id, isVerified) => Account.findByIdAndUpdate(id, { email_verified: isVerified });
const getExistingOtp = (email) => {
    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
    return Otp.findOne({ email, createdAt: { $gt: thirtyMinutesAgo } });
};
const createNewOtp = (otp) => Otp.create({  otp });
const deleteOtp = (id) => Otp.findByIdAndDelete(id);
const setAccountOtpToNull = (accountId) => Account.findByIdAndUpdate(accountId, { otp: null });

module.exports = {
    findAccountByEmail,
    findStudentByAccountId,
    findTeacherByAccountId,
    createAccount,
    createStudent,
    createTeacher,
    findStudentById,
    findTeacherById,
    findAccountById,
    updateAccountEmailVerification,
    getExistingOtp,
    createNewOtp,
    deleteOtp,
    setAccountOtpToNull
};

const Student = require("../models/Student");
const Teacher = require("../models/Teacher");
const Course = require("../models/Course");
const Viva = require("../models/Viva");
const Project = require("../models/Project");

const findTeacherById = (id) => Teacher.findById(id);
const findStudentById = (id) => Student.findById(id);
const findCourseByName = (name) => Course.findOne({ courseName: name });
const findAllCourses = () => Course.find({});
const createCourse = (courseData) => Course.create(courseData);
const findCourseBycourseCode = (courseCode) =>
  Course.findOne({ courseCode });
const findCourseById = (id) => Course.findById(id);
const updateCourseName = (courseId, courseName) =>
  Course.findByIdAndUpdate(courseId, { courseName: courseName });
const deleteVivaById = (id) => Viva.findByIdAndDelete(id);
const deleteProjectById = (id) => Project.findByIdAndDelete(id);
const removeCourseFromTeacher = (teacherId, courseId) =>
  Teacher.findByIdAndUpdate(teacherId, { $pull: { courses: courseId } });
const deleteCourseById = (id) => Course.findByIdAndDelete(id);
const removeStudentFromCourse = (courseId, studentId) =>
  Course.findByIdAndUpdate(courseId, { $pull: { students: studentId } });
const removeCourseFromStudent = (studentId, courseId) =>
  Student.findByIdAndUpdate(studentId, { $pull: { courses: courseId } });
const getStudentFromCourse = (courseId, studentId) =>
  Student.findOne({ _id: studentId, courses: courseId });
const getCourseById = (courseId) => Course.findById(courseId);


module.exports = {
  findTeacherById,
  findStudentById,
  findCourseByName,
  findAllCourses,
  createCourse,
  findCourseBycourseCode,
  findCourseById,
  updateCourseName,
  deleteVivaById,
  deleteProjectById,
  removeCourseFromTeacher,
  deleteCourseById,
  removeStudentFromCourse,
  removeCourseFromStudent,
  getStudentFromCourse,
  getCourseById,
};

const Lecture = require("../models/Lecture");

const createLecture = async (lectureData) => {
  const lecture = new Lecture(lectureData);
  return await lecture.save();
};

const getLectures = async (courseId) => {
  return await Lecture.find({ course: courseId });
};

const getLectureById = async (lectureId) => {
  return await Lecture.findById(lectureId);
};

const getLectureByTitleAndCourse = async (title, courseId) => {
  return await Lecture.findOne({
    title,
    course: courseId,
  });
};

const deleteLectureById = async (lectureId) => {
  return await Lecture.findByIdAndDelete(lectureId);
};

const saveLecture = async (lecture) => {
  return await lecture.save();
};

module.exports = {
  createLecture,
  getLectures,
  getLectureById,
  getLectureByTitleAndCourse,
  deleteLectureById,
  saveLecture,
};

const Poll = require("../models/Poll");

const createPoll = async (pollData) => {
  const poll = new Poll(pollData);
  return await poll.save();
};

const getPolls = async (courseId) => {
  return await Poll.find({ course: courseId });
};

const getPollById = async (pollId) => {
  return await Poll.findById(pollId).populate("votes");
};

const deletePollById = async (pollId) => {
  return await Poll.findByIdAndDelete(pollId);
};

const savePoll = async (poll) => {
  return await poll.save();
};


module.exports = {
  createPoll,
  getPolls,
  getPollById,
  deletePollById,
  savePoll,
};

const AIProctoringReport = require("../models/ProctoringReport");
const ProctoringImage = require("../models/ProtoringImage");
const AppError = require("../utilities/AppError");

const createProctoringReport = async (reportData) => {
  return await AIProctoringReport.create(reportData);
};

const getProctoringReportById = async(id) => {
  return await AIProctoringReport.findById(id);
}

// Function to create a proctoring image and update the report
const updateProctoringReport = async (
  reportId,
  { imageId, cheatingIndicators }
) => {
  const proctoringImage = await ProctoringImage.create({
    image_id: imageId,
    cheating_indicators: cheatingIndicators,
  });

  const report = await AIProctoringReport.findById(reportId);
  if (!report) {
    throw new AppError("Proctoring report not found", 404);
  }

  // Add the new image to the report
  report.images.push(proctoringImage._id);

  // Update the cheating indicators in the report
  report.cheating_indicators.mobile_phone += cheatingIndicators.mobile_phone
    ? 1
    : 0;
  report.cheating_indicators.extra_person += cheatingIndicators.extra_person
    ? 1
    : 0;
  report.cheating_indicators.mouth_open += cheatingIndicators.mouth_open
    ? 1
    : 0;
  report.cheating_indicators.no_person += cheatingIndicators.no_person ? 1 : 0;

  report.cheating_indicators.eye_left_right += cheatingIndicators.eye_gaze == "center" ? 0 :1; 
  report.updated_at = new Date();

  await report.save();

  return report;
};

module.exports = {
  createProctoringReport,
  updateProctoringReport,
  getProctoringReportById
};

const ProctoringImage = require('../models/ProtoringImage');

const createProtoringImage = (image_id , cheaing_indicators) => ProctoringImage.create({image_id , cheaing_indicators});

module.exports = {
    createProtoringImage
};

const Student = require("../models/Student");
const Course = require("../models/Course");
const Project = require("../models/Project");
const Status = require("../models/Status");

const findStudentById = (id) => Student.findById(id);
const findCourseById = (id) => Course.findById(id);
const findProjectByName = (name) => Project.findOne({ name });
const findProjectByLeaderAndCourse = (student, courseInstance) => Project.findOne({
    projectLeader: student,
    course: courseInstance
});
const createProject = (projectData) => Project.create(projectData);
const createStatus = (statusData) => Status.create(statusData);
const findProjectById = (id) => Project.findById(id).populate("members").populate("projectLeader");
const updateProjectById = (id, updateData) => Project.findByIdAndUpdate(id, updateData, { new: true });
const findProjectByIdAndCourse = (projectId, courseId) => Project.findOne({
    _id: projectId,
    course: courseId
});

const findProjectByNameAndCourse = (name, courseId) => Project.findOne({
    name,
    course: courseId
});

const findProjectByMemberAndCourse = (member, courseInstance) => Project.findOne({
    members: member._id,
    course: courseInstance
});
const deleteProjectById = (id) => Project.findByIdAndDelete(id);

module.exports = {
    findStudentById,
    findCourseById,
    findProjectByName,
    findProjectByLeaderAndCourse,
    createProject,
    createStatus,
    findProjectById,
    updateProjectById,
    findProjectByIdAndCourse,
    findProjectByNameAndCourse,
    findProjectByMemberAndCourse,
    deleteProjectById
};

const Question = require('../models/Question');

// Find a question by its content
const findQuestionByContent = async (content) => {
    return await Question.findOne({ content });
};

// Create a new question
const createQuestion = async (questionData) => {
    return await Question.create(questionData);
};

module.exports = {
    findQuestionByContent,
    createQuestion,
};

const Quiz = require("../models/Quiz");

// Create a new quiz
const createQuiz = async (quizData) => {
  return await Quiz.create(quizData);
};

const getQuizById = async (quizId) => {
  return await Quiz.findById(quizId);
};

// Find a quiz by its ID
const findQuizById = async (quizId) => {
  return await Quiz.findById(quizId).populate("questions");
};

const getQuizzesByCourse = async (courseId) => {
  return await Quiz.find({ course: courseId });
};

// Update a quiz by its ID
const updateQuizById = async (quizId, updateData) => {
  return await Quiz.findByIdAndUpdate(quizId, updateData, { new: true });
};

// Delete a quiz by its ID
const deleteQuizById = async (quizId) => {
  return await Quiz.findByIdAndDelete(quizId);
};

module.exports = {
  createQuiz,
  findQuizById,
  updateQuizById,
  deleteQuizById,
  getQuizById,
  getQuizzesByCourse,
};

const QuizSubmission = require('../models/QuizSubmission');

const createSubmission = async (submissionData) => {
    return await QuizSubmission.create(submissionData);
};

const findSubmission = async (quizId, studentId) => {
    return await QuizSubmission.findOne({ quiz: quizId, student: studentId });
};

const findSubmissionById= async (submissionId)=>{
    return await QuizSubmission.findById(submissionId);
}
module.exports = {
    createSubmission,
    findSubmission,
    findSubmissionById
};

const Project = require('../models/Project');
const Remark = require('../models/Remarks');
const Viva = require('../models/Viva');

const findProjectByIdAndCourseId = (projectId, courseId) => Project.findOne({ _id: projectId, course: courseId }).populate('viva');
const createRemark = (remarkData) => Remark.create(remarkData);
const saveProject = (project) => project.save();
const findRemarkById = (remarkId) => Remark.findById(remarkId);
const updateRemark = (remarkId, updateData) => Remark.findByIdAndUpdate(remarkId, updateData, { new: true });
const saveViva = (viva) => viva.save();

module.exports = {
    findProjectByIdAndCourseId ,
    createRemark,
    saveProject,
    findRemarkById,
    updateRemark,
    saveViva
};

const Status = require("../models/Status");

const createStatus = (statusData) => Status.create(statusData);
const findStatusById = (id) => Status.findById(id);
const updateStatusById = (id, updateData) => Status.findByIdAndUpdate(id, updateData, { new: true });
// Delete a status by ID
const deleteStatus = (id) => Status.findByIdAndDelete(id);

module.exports = {
    createStatus,
    findStatusById,
    updateStatusById,
    deleteStatus
};

const Submission = require("../models/Submission");

const createSubmission = async (submissionData) => {
  const submission = new Submission(submissionData);
  return await submission.save();
};

const getSubmissionsByAssignmentId = async (assignmentId) => {
  return await Submission.find({ assignment: assignmentId }).populate(
    "remarks"
  );
};

const getSubmissionById = async (submissionId) => {
  return await Submission.findById(submissionId).populate("remarks");
};

const deleteSubmissionsByAssignmentId = async (assignmentId) => {
  return await Submission.deleteMany({ assignment: assignmentId });
};

const saveSubmission = async (submission) => {
  return await submission.save();
};

const getSubmissionByAssignmentAndStudent = async (assignmentId, studentId) => {
  return await Submission.findOne({ assignment: assignmentId, student: studentId });
};

const deleteSubmissionById = async (submissionId) => {
  return await Submission.findByIdAndDelete(submissionId);
}

module.exports = {
  createSubmission,
  getSubmissionsByAssignmentId,
  getSubmissionById,
  deleteSubmissionsByAssignmentId,
  saveSubmission,
  getSubmissionByAssignmentAndStudent,
  deleteSubmissionById,

};

const Project = require('../models/Project');
const Viva = require('../models/Viva');
const Course = require('../models/Course');

const findProjectById = (projectId) => Project.findById(projectId).populate('status');
const findVivaByProjectId = (projectId) => Viva.findOne({ project: projectId });
const findCourseById = (courseId) => Course.findById(courseId).populate('vivas');
const createViva = (vivaData) => Viva.create(vivaData);
const saveProject = (project) => project.save();
const saveCourse = (getCourse) => getCourse.save();
const findVivaById = (vivaId) => Viva.findById(vivaId).populate('remarks');
const updateViva = (vivaId, updateData) => Viva.findByIdAndUpdate(vivaId, updateData);
const deleteVivaById = (vivaId) => Viva.findByIdAndDelete(vivaId);

module.exports = {
    findProjectById,
    findVivaByProjectId,
    findCourseById,
    createViva,
    saveProject,
    saveCourse,
    findVivaById,
    updateViva,
    deleteVivaById
};

const Vote = require("../models/Vote");

const createVote = async (voteData) => {
  const vote = new Vote(voteData);
  return await vote.save();
};

const getVoteByPollAndStudent = async (pollId, studentId) => {
  return await Vote.findOne({ poll: pollId, student: studentId });
};

const updateVote = async (voteId, option) => {
  return await Vote.findByIdAndUpdate(
    voteId,
    { option, updated_at: Date.now() },
    { new: true }
  );
};

const deleteVoteById = async (voteId) => {
  return await Vote.findByIdAndDelete(voteId);
};

const getVotesByPollId = async (pollId) => {
  return await Vote.find({ poll: pollId });
};

const saveVote = async (vote) => {
  return await vote.save();
};

module.exports = {
  createVote,
  getVoteByPollAndStudent,
  updateVote,
  deleteVoteById,
  getVotesByPollId,
  saveVote,
};

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { validateAnnouncement } = require("../middlewares/schemaValidator");
const { isTeacher, isCourseCreator, isCourseCreatorOrCourseStudent } = require("../middlewares/authorization");
const announcementController = require("../controllers/announcementController");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

router
  .route("/:courseId")
  .get(isLogin,isEmailVerified,isCourseCreatorOrCourseStudent, announcementController.getAllCourseAnnouncements)
  .post(
    isLogin,
    isTeacher,
    isCourseCreator,
    validateAnnouncement,
    announcementController.sendCourseAnnouncement
  );

router
  .route("/:courseId/announcement/:announcementId")
  .delete(
    isLogin,
    isTeacher,
    isCourseCreator,
    announcementController.deleteAnnouncement
  )
  .patch(
    isLogin,
    isTeacher,
    isCourseCreator,
    validateAnnouncement,
    announcementController.updateAnnouncement
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const assignmentController = require("../controllers/assignmentController");
const { uploadAssignment } = require("../middlewares/multer/uploadAssignment");
const { isCourseCreator, isTeacher } = require("../middlewares/authorization");
const { isLogin } = require("../middlewares/isLogin");
const { validateAssignment } = require("../middlewares/schemaValidator");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

router
  .route("/:courseId")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    assignmentController.getAssignments
  )
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    uploadAssignment.single("assignment_document"),
    assignmentController.createAssignment
  );

router
  .route("/:courseId/assignment/:assignmentId/download")
  .get(isLogin, isEmailVerified, assignmentController.downloadAssignment);

router
  .route("/:courseId/assignment/:assignmentId")
  .get(isLogin, isEmailVerified, assignmentController.getAssignment)
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    uploadAssignment.single("assignment_document"),
    assignmentController.updateAssignment
  )
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    assignmentController.deleteAssignment
  );

module.exports = router;

const express = require("express");
const router = express.Router();

// body validator middlewares
const {
  validateRegister,
  validateLogin,
  validateUpdatePassword,
  validateUpdateName,
  validateOtp,
} = require("../middlewares/schemaValidator");
// auth controller
const authController = require("../controllers/authController");
const { isLogin } = require("../middlewares/isLogin");
const { isStudent, isTeacher } = require("../middlewares/authorization");
const { uploadProfile } = require("../middlewares/multer/uploadProfile");
const { uploadFaceBiometricData } = require("../middlewares/multer/uploadFace");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

router.route("/generate-otp").post(isLogin, authController.generateOtp);

router
  .route("/verify-otp")
  .post(isLogin, validateOtp, authController.verifyOtp);

router
  .route("/register")
  .post(validateRegister, authController.registerStudent);

router.route("/login").post(validateLogin, authController.loginStudent);

router
  .route("/teacher/register")
  .post(validateRegister, authController.registerTeacher);

router.route("/teacher/login").post(validateLogin, authController.loginTeacher);

router
  .route("/student/update-password")
  .patch(
    isLogin,
    isEmailVerified,
    isStudent,
    validateUpdatePassword,
    authController.updateStudentPassword
  );

router
  .route("/student/update-name")
  .patch(
    isLogin,
    isEmailVerified,
    isStudent,
    validateUpdateName,
    authController.updateStudentName
  );

router
  .route("/teacher/update-password")
  .patch(
    isLogin,
    isEmailVerified,
    isTeacher,
    validateUpdatePassword,
    authController.updateTeacherPassword
  );

router
  .route("/teacher/update-name")
  .patch(
    isLogin,
    isEmailVerified,
    isTeacher,
    validateUpdateName,
    authController.updateTeacherName
  );

router
  .route("/student/upload-image")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    uploadProfile.single("profileImage"),
    authController.uploadStudentImage
  );

router
  .route("/teacher/upload-image")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    uploadProfile.single("profileImage"),
    authController.uploadTeacherImage
  );

router
  .route("/student/:id")
  .get(isLogin, isEmailVerified, authController.getStudentInfo);

router
  .route("/teacher/:id")
  .get(isLogin, isEmailVerified, authController.getTeacherInfo);

router
  .route("/student/register-face")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    uploadFaceBiometricData.single("face_image"),
    authController.registerStudentFace
  );

router
  .route("/student/verify-face")
  .post(
    uploadFaceBiometricData.single("face_image"),
    isLogin,
    isStudent,
    isEmailVerified,
    authController.verifyStudentFace
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const {
  validateCourse,
  validateDate,
  validateAddRemoveStudent,
} = require("../middlewares/schemaValidator");
const {
  isTeacher,
  isStudent,
  isCourseCreator,
  isCourseStudent,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");
const courseController = require("../controllers/courseController");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

router
  .route("/create")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    validateCourse,
    courseController.createCourse
  );

router
  .route("/getAll")
  .get(isLogin, isEmailVerified, courseController.sendAllCourses);

router
  .route("/updateViva/:courseId")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateDate,
    courseController.updateVivaSchedule
  );

router
  .route("/updateProject/:courseId")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateDate,
    courseController.updateProjectSchedule
  );

  
router
  .route("/search-student")
  .get(isLogin, isEmailVerified, isTeacher, courseController.searchStudent);

router
  .route("/:courseId")
  .get(
    isLogin,
    isEmailVerified,
    isCourseCreatorOrCourseStudent,
    courseController.sendCourse
  )
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    courseController.updateCourseName
  )
  .patch(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateCourse,
    courseController.updateCourse
  )
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    courseController.deleteCourse
  );

router
  .route("/:courseId/leave")
  .put(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    courseController.leaveCourse
  );

router
  .route("/:courseId/regenerate-course-code")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    courseController.regenerateCourseCode
  );

//to do add and leave student
router
  .route("/:courseId/add")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateAddRemoveStudent,
    courseController.addStudentToCourse
  );

router
  .route("/:courseId/remove")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateAddRemoveStudent,
    courseController.removeStudentFromCourse
  );

router
  .route("/join")
  .post(isLogin, isEmailVerified, isStudent, courseController.joinCourse);

module.exports = router;

const express = require("express");
const lectureController = require("../controllers/lectureController");
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  isTeacher,
  isCourseCreator,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");
const { uploadLecture } = require("../middlewares/multer/uploadLecture");

const router = express.Router();

router
  .route("/:courseId")
  .get(isLogin, isEmailVerified, lectureController.getLectures)
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    uploadLecture.single("lecture_video"),
    lectureController.createLecture
  );

router
  .route("/:courseId/lecture/:lectureId")
  .get(
    isLogin,
    isEmailVerified,
    isCourseCreatorOrCourseStudent,
    lectureController.getLecture
  )
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    uploadLecture.single("lecture_video"),
    lectureController.updateLecture
  )
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    lectureController.deleteLecture
  );

router
  .route("/:courseId/lecture/:lectureId/download")
  .get(isLogin, isEmailVerified,isCourseCreatorOrCourseStudent, lectureController.downloadLecture);

module.exports = router;

const express = require("express");
const router = express.Router();
const pollController = require("../controllers/pollController");
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const { isTeacher, isCourseCreator, isStudent, isCourseStudent, isCourseCreatorOrCourseStudent } = require("../middlewares/authorization");
const { validatePoll } = require("../middlewares/schemaValidator");
router
  .route("/:courseId")
  .get(isLogin, isEmailVerified,isCourseCreatorOrCourseStudent, pollController.getPolls)
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validatePoll,
    pollController.createPoll
  );

router
  .route("/:courseId/poll/:pollId")
  .get(isLogin, isEmailVerified,isCourseCreatorOrCourseStudent, pollController.getPoll)
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    pollController.deletePoll
  );

router
  .route("/:courseId/poll/:pollId/vote")
  .post(isLogin, isEmailVerified,isStudent,isCourseStudent, pollController.votePoll);

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const {
  isStudent,
  isTeacher,
  isCourseCreator,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  uploadProctoringImage,
} = require("../middlewares/multer/uploadProctoringImage");
const proctoringController = require("../controllers/proctoringController");
router
  .route("/:courseId/:quizId/analyze-image")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    uploadProctoringImage.single("proctor_image"),
    proctoringController.analyzeImage
  );

router
  .route("/:courseId/:quizId/generate-report/:studentId")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    proctoringController.generateReport
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { validateProject } = require("../middlewares/schemaValidator");
const {
  isStudent,
  isCourseStudent,
  isProjectCreator,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const projectController = require("../controllers/projectController");

router
  .route("/create")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    validateProject,
    projectController.createProject
  );

router
  .route("/:courseId/:projectId/add-member")
  .put(isLogin,isEmailVerified,isCourseStudent,isProjectCreator,projectController.addMember)

router
  .route("/:courseId/:projectId/:memberId/remove-member")
  .put(isLogin,isEmailVerified,isCourseStudent,isProjectCreator,projectController.removeMember)

router
  .route("/:courseId/:projectId")
  .get(
    isLogin,
    isEmailVerified,
    isCourseCreatorOrCourseStudent,
    projectController.sendProject
  )
  .put(
    isLogin,
    isEmailVerified,
    isStudent,
    isProjectCreator,
    validateProject,
    projectController.updateProject
  )
  .delete(isLogin,isEmailVerified,isCourseCreatorOrCourseStudent, projectController.deleteProject);

module.exports = router;

const express = require("express");
const router = express.Router();
const quizController = require("../controllers/quizController");
const { isLogin } = require("../middlewares/isLogin");
const {
  isTeacher,
  isCourseCreator,
  isCourseStudent,
  isStudent,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  validateQuiz,
  validateUpdateQuizScore,
  validateUpdateSubmissionFlag
} = require("../middlewares/schemaValidator");

router
  .route("/:courseId/create")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateQuiz,
    quizController.createQuiz
  );

router
  .route("/course/:courseId")
  .get(isLogin, isEmailVerified, quizController.getQuizzesByCourse);

router
  .route("/:courseId/:id/get")
  .get(
    isLogin,
    isEmailVerified,
    isCourseStudent,
    isCourseStudent,
    quizController.getQuizStudent
  );

router
  .route("/:courseId/:id/start")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    quizController.startQuiz
  );

router
  .route("/:courseId/:id/submit")
  .post(isLogin, isEmailVerified, isStudent, quizController.submitQuiz);

router
  .route("/:courseId/:quizId/update-marks/:submissionId")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    validateUpdateQuizScore,
    quizController.updateSubmissionMarks
  );

router
  .route("/:courseId/:quizId/update-flag/:submissionId")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    validateUpdateSubmissionFlag,
    quizController.updateSubmissionFlag
  );

router
  .route("/:courseId/:id")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    quizController.getQuiz
  )
  .patch(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateQuiz,
    quizController.updateQuiz
  )
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    quizController.deleteQuiz
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const { validateRemark } = require("../middlewares/schemaValidator");
const {
  isTeacher,
  isCourseCreator,
  isStudent,
  isProjectGroupMember,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");
const remarkController = require("../controllers/remarkController");

router
  .route("/viva/:courseId/:projectId/add")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.addRemarkToViva
  );

router
  .route("/viva/:courseId/:projectId/:remarkId")
  .get(isLogin,isEmailVerified, isStudent, isProjectGroupMember, remarkController.sendRemark)
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.updateRemark
  );

// Add remark to a submission
router
  .route("/submission/:courseId/:submissionId/add")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.addRemarkToSubmission
  );

// Get, update remark on a submission
router
  .route("/submission/:courseId/:submissionId/:remarkId")
  .get(isLogin, isStudent,isCourseCreatorOrCourseStudent, remarkController.readSubmissionRemark)
  .put(
    isLogin,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.updateSubmissionRemark
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { validateStatus } = require("../middlewares/schemaValidator");
const { isTeacher, isCourseCreator, isCourseCreatorOrCourseStudent } = require("../middlewares/authorization");

const statusController = require("../controllers/statusController");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

router
  .route("/:courseId/:projectId/add")
  .post(
    isLogin,
    isTeacher,
    isEmailVerified,
    isCourseCreator,
    validateStatus,
    statusController.addStatus
  );

router
  .route("/:courseId/:projectId/:statusId")
  .get(isLogin,isEmailVerified,isCourseCreatorOrCourseStudent, statusController.sendStatus)
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateStatus,
    statusController.updateStatus
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const submissionController = require("../controllers/submissionController");
const { isLogin } = require("../middlewares/isLogin");
const {
  isStudent,
  isTeacher,
  isCourseCreator,
  isCourseStudent,
} = require("../middlewares/authorization");
const { validateSubmission } = require("../middlewares/schemaValidator");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const { uploadSubmission } = require("../middlewares/multer/uploadSubmission");

router
  .route("/:courseId/submission/:submissionId/download")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    submissionController.downloadSubmissionTeacher
  );

router
  .route("/:courseId/assignment/:assignmentId")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    submissionController.getSubmissions
  )
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    uploadSubmission.single("submision_document"),
    submissionController.createSubmission
  );

router
  .route("/assignment/:assignmentId/submissions/:submissionId/download")
  .get(
    isLogin,
    isEmailVerified,
    isStudent,
    submissionController.downloadSubmission
  );

router
  .route("/assignment/:assignmentId/submissions/:submissionId")
  .get(isLogin, isEmailVerified, isStudent, submissionController.getSubmission)
  .put(
    isLogin,
    isEmailVerified,
    isStudent,
    uploadSubmission.single("submision_document"),
    submissionController.updateSubmission
  )
  .delete(isLogin, isStudent, submissionController.deleteSubmission);

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { validateViva } = require("../middlewares/schemaValidator");
const {
  isTeacher,
  isStudent,
  isCourseCreator,
  isProjectCreator,
  isCourseStudent,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const vivaController = require("../controllers/vivaController");

router
  .route("/:courseId/:projectId/add")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    isProjectCreator,
    vivaController.addViva
  );

router
  .route("/:courseId/getTodayVivas")
  .get(isLogin, isEmailVerified, vivaController.getTodaysViva);

router
  .route("/:courseId/getAllVivas")
  .get(isLogin, isEmailVerified,isCourseCreator, vivaController.getAllVivas);

router
  .route("/:courseId/:vivaId")
  .get(isLogin, vivaController.sendViva)
  .put(
    isLogin,
    isTeacher,
    isCourseCreator,
    validateViva,
    vivaController.updateViva
  );

module.exports = router;

const Joi = require("joi");

module.exports.addRemoveStudentSchema = Joi.object({
  studentId: Joi.string().required(),
});

const Joi= require('joi')

module.exports.announcementSchema = Joi.object(
    {
        title:Joi.string().required(),
        content:Joi.string().required()
    }
)
const Joi= require('joi')

module.exports.assignmentSchema = Joi.object(
    {
        title: Joi.string().required(),
        description: Joi.string().required(),
    }
);
const Joi = require("joi");

module.exports.registerSchema = Joi.object({
  name: Joi.string().required(),
  email: Joi.string().required(),
  pass: Joi.string().required(),
});
module.exports.loginSchema = Joi.object({
  email: Joi.string().required(),
  pass: Joi.string().required(),
});

module.exports.updatePasswordSchema = Joi.object({
  currentPassword: Joi.string().required(),
  newPassword: Joi.string().required(),
});

module.exports.updateNameSchema = Joi.object({
  newName: Joi.string().required(),
});

module.exports.otpSchema = Joi.object({
  otp: Joi.string().required(),
});

const Joi= require('joi')

module.exports.courseSchema = Joi.object(
    {
        courseName: Joi.string().required(),
        description: Joi.string().required(),
        projectRequirements: Joi.string().required().default("Requirements Coming Soon"),
    }
)
const Joi= require('joi')

module.exports.dateSchema = Joi.object(
    {
        startDate: Joi.date().required(),
        endDate: Joi.date().required()
    }
)
const Joi = require("joi");

module.exports.pollSchema = Joi.object({
  title: Joi.string().required(), // Title is required and should be a string
  description: Joi.string().optional(), // Description is optional
  options: Joi.array()
    .items(
      Joi.string().min(1).max(100) // Options should be strings with a length between 1 and 100
    )
    .min(2)
    .max(3)
    .required()
    .messages({
      "array.min": "Options should have at least 2 elements.",
      "array.max": "Options should have at most 3 elements.",
    }),
  created_at: Joi.date().default(Date.now),
});

const Joi= require('joi')

module.exports.projectSchema = Joi.object(
    {
        name: Joi.string().required(),
        scope: Joi.string().required(),
        members:Joi.array().required().min(1).max(4),
        courseId:Joi.string().required()
    }
)
const Joi = require('joi');

module.exports.quizSchema = Joi.object({
  title: Joi.string().required(),
  topic: Joi.string().required(),
  questions: Joi.array().items(
    Joi.object({
      content: Joi.string().required(),
      options: Joi.array().items(Joi.string().required()).min(2).required(),
      correct_option: Joi.string().required()
    })
  ).required(),
  number_of_questions: Joi.number().required(),
  deadline: Joi.date().required(),
  duration: Joi.number().required()
});

const Joi = require('joi');

const remarkSchema = Joi.object({
  overallPerformance: Joi.string()
    .valid('Bad', 'Poor', 'Fair', 'Good', 'Excellent')
    .required(),
  feedback: Joi.string().trim().required(),
  obtainedMarks: Joi.number().min(0).required(), 
  totalMarks: Joi.number().min(0).required(), 
});

module.exports = { remarkSchema };
const Joi= require('joi')

module.exports.reviewSchema = Joi.object({
    difficulty: Joi.number().integer().min(1).max(5).required(),
    relevence: Joi.number().integer().min(1).max(5).required(),
    clarity: Joi.number().integer().min(1).max(5).required(),
    conceptual: Joi.number().integer().min(1).max(5).required(),
    overallFeedback: Joi.number().integer().min(1).max(5).required()
});
const Joi = require('joi');

const statusSchema = Joi.object({
    status: Joi.string().valid('approved','unsatisfactory','disapproved').required(),
    description: Joi.string().required()
});

module.exports.statusSchema = statusSchema;
const Joi = require("joi");

const updateSubmissionFlagSchema = Joi.object({
    isFlagged: Joi.boolean().required(),
});

module.exports.updateSubmissionFlagSchema = updateSubmissionFlagSchema;
const Joi = require('joi');

const updateSubmissionMarksSchema = Joi.object({
    newScore: Joi.number().required(),
});

module.exports.updateSubmissionMarksSchema = updateSubmissionMarksSchema;
const Joi= require('joi')

module.exports.vivaSchema = Joi.object(
    {
        status: Joi.string().valid('taken','scheduled'),
        vivaDate:Joi.date()
    }
)
const announcementRepository = require("../repositories/announcementRepository");
const AppError = require("../utilities/AppError");

const sendCourseAnnouncement = async (courseId, announcementData, teacherId) => {
    const course = await announcementRepository.findCourseById(courseId);
    if (!course) {
        throw new AppError("Course not found", 400);
    }
    const announcement = await announcementRepository.createAnnouncement({
        ...announcementData,
        course: courseId,
        teacher: teacherId
    });
    course.announcements.push(announcement._id);
    await course.save();
    // TODO: Notify students of the new announcement
    return {
        _id: announcement._id,
        title: announcement.title,
        message: announcement.content
    };
};

const deleteAnnouncement = async (announcementId) => {
    const announcement = await announcementRepository.findAnnouncementById(announcementId);
    if (!announcement) {
        throw new AppError("Announcement not found", 404);
    }
    await announcementRepository.deleteAnnouncementById(announcementId);
};

const updateAnnouncement = async (announcementId, updateData) => {
    const announcement = await announcementRepository.findAnnouncementById(announcementId);

    if (!announcement) {
        throw new AppError("Announcement not found", 404);
    }
    await announcementRepository.updateAnnouncementById(announcementId, updateData);

    return announcement;
};

const getAllCourseAnnouncements = async (courseId) => {
    const course = await announcementRepository.findCourseByIdWithAnnouncements(courseId);
    if (!course) {
        throw new AppError("Course not found", 400);
    }
    return course.announcements;
};

module.exports = {
    sendCourseAnnouncement,
    deleteAnnouncement,
    updateAnnouncement,
    getAllCourseAnnouncements
};

const assignmentRepository = require("../repositories/assignmentRepository");
const courseRepository = require("../repositories/courseRepository");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
const submissionRepository = require("../repositories/submissionRepository");
const path = require("path");
const moment = require('moment-timezone');

const addAssignment = async (
  courseId,
  teacherId,
  title,
  description,
  deadline,
  document_id
) => {
  if (!title || !description || !deadline) {
    throw new Error("Title, description and deadline are required");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const isAssignmentExist =
    await assignmentRepository.getAssignmentByTitleAndCourse(title, courseId);
  if (isAssignmentExist) {
    throw new Error(
      "Assignment with the same title already exists in the same course"
    );
  }
  const formattedDate = moment.tz(deadline, 'DD/MM/YYYY', 'your_time_zone').utc().toDate();
  const assignmentData = {
    course: courseId,
    teacher: teacherId,
    title,
    description,
    deadline:formattedDate,
    document_id,
  };
  const assignment = await assignmentRepository.createAssignment(
    assignmentData
  );
  course.assignments.push(assignment._id);
  await course.save();
  return assignment;
};

const getAssignmentsByCourse = async (courseId) => {
  return await assignmentRepository.getAssignments(courseId);
};

const getAssignment = async (courseId, assignmentId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (course.assignments.indexOf(assignmentId) === -1) {
    throw new Error("Assignment not found in the course");
  }
  return assignment;
};

const updateAssignment = async (
  courseId,
  assignmentId,
  title,
  description,
  deadline,
  document_id
) => {
  const assignment = await getAssignment(courseId, assignmentId);
  if (!courseId || !assignmentId) {
    throw new AppError("course id and assignment id must be in params");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new AppError("course not found");
  }
  if (course.assignments.indexOf(assignmentId) === -1) {
    throw new AppError("assignment not found in the course");
  }
  if (document_id) {
    deleteFileByPath(
      path.join(
        __dirname,
        "../",
        "uploads",
        "assignments",
        assignment.document_id
      )
    );
  }
  const formattedDate = moment.tz(deadline, 'DD/MM/YYYY', 'your_time_zone').utc().toDate();
  assignment.title = title || assignment.title;
  assignment.description = description || assignment.description;
  assignment.document_id = document_id || assignment.document_id;
  assignment.deadline=formattedDate;
  assignment.updated_at = Date.now();

  return await assignmentRepository.saveAssignment(assignment);
};

const deleteAssignment = async (courseId, assignmentId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }

  if (course.assignments.indexOf(assignmentId) === -1) {
    throw new Error("Assignment not found in the course");
  }
  if (assignment.document_id) {
    try {
      deleteFileByPath(
        path.join(
          __dirname,
          "../",
          "uploads",
          "assignments",
          assignment.document_id
        )
      );
    } catch (err) {
      console.log(err);
    }
  }
  // Delete associated submissions
  await submissionRepository.deleteSubmissionsByAssignmentId(assignmentId);

  // Delete the assignment
  await assignmentRepository.deleteAssignmentById(assignmentId);

  // Remove the assignment reference from the course
  course.assignments = course.assignments.filter(
    (id) => id.toString() !== assignmentId.toString()
  );
  await course.save();
};

module.exports = {
  addAssignment,
  getAssignmentsByCourse,
  getAssignment,
  updateAssignment,
  deleteAssignment,
};

const authRepository = require("../repositories/authRepository");
const bcrypt = require("bcrypt");
const AppError = require("../utilities/AppError");
const generateToken = require("../utilities/GetToken");
const axios = require("axios");
const {
  verifyStudentEmail,
  verifyTeacherEmail,
} = require("../utilities/MailVerification");
const { deleteFile } = require("../utilities/removeFile");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
require("dotenv").config();

const registerStudent = async (name, email, pass) => {
  if (!name || !email || !pass) {
    throw new AppError("Enter all the required fields", 400);
  }
  if (!verifyStudentEmail(email)) {
    throw new AppError("This Is Not A Student Email", 400);
  }
  const account = await authRepository.findAccountByEmail(email);
  if (account) {
    const studentExists = await authRepository.findStudentByAccountId(
      account._id
    );
    if (studentExists) {
      throw new AppError("Student Already Registered", 400);
    }
  }
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(pass, salt);
  const studentAccount = await authRepository.createAccount(
    email,
    hashedPassword
  );
  const student = await authRepository.createStudent(name, studentAccount._id);
  return {
    _id: student._id,
    name: student.name,
    email: studentAccount.email,
    password: studentAccount.password,
    token: generateToken(student._id),
  };
};

const loginStudent = async (email, pass) => {
  if (!verifyStudentEmail(email)) {
    throw new AppError("This Is Not A Student Email", 400);
  }
  const studentAccount = await authRepository.findAccountByEmail(email);
  if (!studentAccount) {
    throw new AppError("Student Account Not Found", 400);
  }
  const isMatch = await bcrypt.compare(pass, studentAccount.password);
  if (!isMatch) {
    throw new AppError("Wrong Email Or Password", 400);
  }
  const student = await authRepository.findStudentByAccountId(
    studentAccount._id
  );
  return {
    _id: student._id,
    name: student.name,
    email: studentAccount.email,
    token: generateToken(student._id),
  };
};

const registerTeacher = async (name, email, pass) => {
  if (!name || !email || !pass) {
    throw new AppError("Enter all the required fields", 400);
  }
  if (!verifyTeacherEmail(email)) {
    throw new AppError("This Is Not A Faculty Email", 400);
  }
  const account = await authRepository.findAccountByEmail(email);
  if (account) {
    const teacherExists = await authRepository.findTeacherByAccountId(
      account._id
    );
    if (teacherExists) {
      throw new AppError("Teacher Already Registered", 400);
    }
  }
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(pass, salt);
  const teacherAccount = await authRepository.createAccount(
    email,
    hashedPassword
  );
  const teacher = await authRepository.createTeacher(name, teacherAccount._id);
  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacherAccount.email,
    password: teacherAccount.password,
    token: generateToken(teacher._id),
  };
};

const loginTeacher = async (email, pass) => {
  if (!verifyTeacherEmail(email)) {
    throw new AppError("This Is Not A Faculty Email", 400);
  }
  const teacherAccount = await authRepository.findAccountByEmail(email);
  if (!teacherAccount) {
    throw new AppError("Teacher Account Not Found", 400);
  }
  const isMatch = await bcrypt.compare(pass, teacherAccount.password);
  if (!isMatch) {
    throw new AppError("Wrong Email Or Password", 400);
  }
  const teacher = await authRepository.findTeacherByAccountId(
    teacherAccount._id
  );
  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacherAccount.email,
    token: generateToken(teacher._id),
  };
};

const updateStudentPassword = async (
  studentId,
  currentPassword,
  newPassword
) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }

  const studentAccount = await authRepository.findAccountById(student.account);
  const isMatch = await bcrypt.compare(
    currentPassword,
    studentAccount.password
  );
  if (!isMatch) {
    throw new AppError("Incorrect Current Password", 400);
  }

  const salt = await bcrypt.genSalt(10);
  const hashedNewPassword = await bcrypt.hash(newPassword, salt);
  studentAccount.password = hashedNewPassword;
  await studentAccount.save();

  return { message: "Password Updated Successfully" };
};

const updateStudentName = async (studentId, newName) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }

  student.name = newName;
  await student.save();

  return {
    _id: student._id,
    name: student.name,
    email: student.account.email,
  };
};

const updateTeacherPassword = async (
  teacherId,
  currentPassword,
  newPassword
) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher Not Found", 404);
  }

  const teacherAccount = await authRepository.findAccountById(teacher.account);
  const isMatch = await bcrypt.compare(
    currentPassword,
    teacherAccount.password
  );
  if (!isMatch) {
    throw new AppError("Incorrect Current Password", 400);
  }

  const salt = await bcrypt.genSalt(10);
  const hashedNewPassword = await bcrypt.hash(newPassword, salt);
  teacherAccount.password = hashedNewPassword;
  await teacherAccount.save();

  return { message: "Password Updated Successfully" };
};

const updateTeacherName = async (teacherId, newName) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher Not Found", 404);
  }

  teacher.name = newName;
  await teacher.save();

  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacher.account.email,
  };
};

const getStudentInfo = async (studentId) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student not found", 404);
  }
  return {
    _id: student._id,
    name: student.name,
    email: student.account.email,
    profile_picture: student.account.profile_picture,
  };
};

const getTeacherInfo = async (teacherId) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher not found", 404);
  }
  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacher.account.email,
  };
};

const uploadStudentImage = async (studentId, imageName) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student not found", 404);
  }
  const studentAccount = await authRepository.findAccountById(student.account);
  if (studentAccount.profile_picture) {
    deleteFile(studentAccount.profile_picture);
  }
  studentAccount.profile_picture = imageName;
  await studentAccount.save();
  student.account = studentAccount;
  return student;
};

const uploadTeacherImage = async (teacherId, imageName) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher not found", 404);
  }
  const teacherAccount = await authRepository.findAccountById(teacher.account);
  if (teacherAccount.profile_picture) {
    deleteFile(teacherAccount.profile_picture);
  }
  teacherAccount.profile_picture = imageName;
  await teacherAccount.save();
  teacher.account = teacherAccount;
  return teacher;
};

const generateOtp = async (account_id) => {
  const account = await authRepository.findAccountById(account_id);

  if (!account) {
    throw new AppError("Account Not Found ", 400);
  }
  if (account.email_verified) {
    throw new AppError("Email Already Verified", 400);
  }
  if (account && account.otp) {
    const existingOtp = account.otp;
    const now = new Date();
    const otpCreatedAt = new Date(existingOtp.createdAt);
    const expiryTime = 30 * 60 * 1000; // 30 minutes in milliseconds

    // Check if the existing OTP is still valid
    if (now - otpCreatedAt < expiryTime) {
      return existingOtp.otp; // Return the existing valid OTP
    }

    // If the existing OTP is expired, delete it
    await authRepository.deleteOtp(existingOtp._id);
    account.otp = null;
    await account.save();
  }

  // Call Flask API to generate a new OTP if necessary
  const response = await axios.post(`${process.env.FLASK_URL}/generate-otp`, {
    email:account.email,
  });
  if (!response.data.success) {
    throw new Error("Failed to generate OTP from Flask API");
  }
  const otp = response.data.otp;
  // Save the new OTP in the database
  const newOtp = await authRepository.createNewOtp(otp);

  // Associate the new OTP with the account
  if (account) {
    account.otp = newOtp._id;
    await account.save();
  } else {
    throw new AppError("Account not found", 404);
  }
  return newOtp.otp;
};

const verifyOtp = async (account_id, otp) => {
  const account = await authRepository.findAccountById(account_id);
  if(account.email_verified){
    throw new AppError("Email Already Verified", 400);
  }
  if (!account) {
    throw new AppError("Account not found", 404);
  }

  if (!account.otp) {
    throw new AppError("No OTP associated with this account", 400);
  }

  const existingOtp = account.otp;
  const now = new Date();
  const otpCreatedAt = new Date(existingOtp.createdAt);
  const expiryTime = 30 * 60 * 1000; // 30 minutes in milliseconds

  if (existingOtp.otp !== parseInt(otp, 10)) {
    throw new AppError("Invalid OTP", 400);
  }

  if (now - otpCreatedAt >= expiryTime) {
    throw new AppError("Expired OTP", 400);
  }

  // OTP is valid, proceed with email verification
  await authRepository.updateAccountEmailVerification(account_id, true);
  await authRepository.deleteOtp(existingOtp._id);
  await authRepository.setAccountOtpToNull(account._id);

  return { success: true, message: "Email verified successfully" };
};

const registerStudentFace = async (studentId, imagePath) => {
  const student = await authRepository.findStudentById(studentId);
  // console.log(student)
  if (!student) {
      throw new AppError("Student Not Found", 404);
  }
  // Call Flask API to get face encoding
  const response = await axios.post(`${process.env.FLASK_URL}/register-face`, { image_path: imagePath });
  if (!response.data.success) {
      throw new AppError(response.data.error, 400);
  }
  // Save face encoding to student document
  student.face_biometric_data = response.data.encoding;
  await student.save();
  deleteFileByPath(imagePath);
};

const verifyStudentFace = async (studentId, imagePath, encoding) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
      throw new AppError("Student Not Found", 404);
  }
  // Call Flask API for face verification
  const response = await axios.post(`${process.env.FLASK_URL}/verify-face`, {
      image_path: imagePath,
      known_face_encoding:encoding
  });
  deleteFileByPath(imagePath);
  if (!response.data.success) {
      throw new AppError(response.data.error, 400);
  }
  // console.log(response.data)
  const { success, match } = response.data;

  if (success) {
      return { success, match};
  } else {
      throw new AppError("Face not matched", 400);
  }

};


module.exports = {
  registerStudent,
  loginStudent,
  registerTeacher,
  loginTeacher,
  updateStudentPassword,
  updateStudentName,
  updateTeacherPassword,
  updateTeacherName,
  getStudentInfo,
  getTeacherInfo,
  uploadStudentImage,
  uploadTeacherImage,
  generateOtp,
  verifyOtp,
  registerStudentFace,
  verifyStudentFace,
};

const courseRepository = require("../repositories/courseRepository");
const authRepository = require("../repositories/authRepository");
const announcementRepository = require("../repositories/announcementRepository");
const pollRepository = require("../repositories/pollRepository");
const vivaRepository = require("../repositories/vivaRepository");
const projectRepository = require("../repositories/projectRepository");
const lectureRepository = require("../repositories/lectureRepository");
const quizRepository = require("../repositories/quizRepository");
const assignmentRepository = require("../repositories/assignmentRepository");
const pollService = require("../services/pollService");

const { parseDate } = require("../utilities/dateHelper");

const { generateCourseCode } = require("../utilities/GenerateCode");
const AppError = require("../utilities/AppError");

const createCourse = async (teacherId, data) => {
  const teacher = await courseRepository.findTeacherById(teacherId);
  const checkCourse = await courseRepository.findCourseByName(data.courseName);
  if (checkCourse) {
    throw new AppError("Course Already Exists With The Same Name", 400);
  }
  const courses = await courseRepository.findAllCourses();
  const courseCode = generateCourseCode(courses);
  const newCourse = await courseRepository.createCourse({
    courseCode,
    courseName: data.courseName,
    teacher,
    description: data.description,
    projectRequirements: data.projectRequirements,
  });
  teacher.courses.push(newCourse);
  await teacher.save();
  return {
    _id: newCourse._id,
    courseCode: newCourse.courseCode,
    courseName: newCourse.courseName,
    description: newCourse.description,
    projectRequirements: newCourse.projectRequirements,
    teacher: newCourse.teacher,
  };
};

const joinCourse = async (studentId, courseCode) => {
  if (!courseCode) {
    throw new AppError("Send Course Code To Join", 201);
  }
  const student = await courseRepository.findStudentById(studentId);
  const getCourse = await courseRepository.findCourseBycourseCode(courseCode);
  if (getCourse) {
    await getCourse.populate("students");
    for (const stu of getCourse.students) {
      if (stu.id == student.id) {
        throw new AppError("Student Already Joined", 201);
      }
    }
    student.courses.push(getCourse);
    await student.save();
    getCourse.students.push(student);
    await getCourse.save();
    return {
      _id: getCourse._id,
      courseCode: getCourse.courseCode,
      courseName: getCourse.courseName,
      students: getCourse.students,
    };
  } else {
    throw new AppError("Course Not Found Wrong Code", 201);
  }
};

const updateCourseName = async (courseId, courseName) => {
  if (!courseName || courseName.trim() === "") {
    throw new AppError("Course Name Can't Be Empty", 400);
  }
  const checkCourse = await courseRepository.findCourseByName(courseName);
  if (checkCourse) {
    throw new AppError("Course Already Exists With The Same Name", 400);
  }
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  } else {
    await courseRepository.updateCourseName(courseId, courseName);
  }
};

const deleteCourse = async (courseId, teacherId) => {
  // Find the course by ID
  const course = await courseRepository.findCourseById(courseId);
  if (!course) throw new AppError("Course Not Found", 400);

  // Delete related Vivases
  for (const vivaId of course.vivas) {
    await vivaRepository.deleteVivaById(vivaId);
  }

  // Delete related Projects
  for (const projectId of course.projects) {
    const project = await projectRepository.findProjectById(projectId);
    if (project) {
      await projectRepository.deleteProjectById(projectId);
    }
  }

  // Delete related Announcements
  for (const announcementId of course.announcements) {
    await announcementRepository.deleteAnnouncementById(announcementId);
  }

  // Delete related Polls
  for (const pollId of course.polls) {
    await pollService.deletePoll(course._id, pollId);
  }

  // Delete related Lectures
  for (const lectureId of course.lectures) {
    await lectureRepository.deleteLectureById(lectureId);
  }

  // Delete related Assignments
  for (const assignmentId of course.assignments) {
    await assignmentRepository.deleteAssignmentById(assignmentId);
  }

  // Delete related Quizzes
  for (const quizId of course.quizzes) {
    await quizRepository.deleteQuizById(quizId);
  }

  // Remove references to the course from students
  for (const studentId of course.students) {
    await courseRepository.removeCourseFromStudent(studentId, courseId);
  }

  // Remove course from teacher
  await courseRepository.removeCourseFromTeacher(teacherId, courseId);

  // Finally, delete the course
  await courseRepository.deleteCourseById(courseId);
};

const leaveCourse = async (courseId, studentId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  const student = await courseRepository.getStudentFromCourse(
    courseId,
    studentId
  );
  console.log(student);
  if (!student) {
    throw new AppError("Student Not Found in Course", 400);
  }
  await courseRepository.removeStudentFromCourse(courseId, studentId);
  await courseRepository.removeCourseFromStudent(studentId, courseId);
};

const updateProjectSchedule = async (courseId, startDate, endDate) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  if (startDate == endDate) {
    throw new AppError("Start and End Date cannot be Same", 400);
  } else if (startDate > endDate) {
    throw new AppError("Start Date cannot be After The End Date", 400);
  } else {
    getCourse.projectStartDate = startDate;
    getCourse.projectEndDate = endDate;
    await getCourse.save();
    return {
      _id: getCourse._id,
      courseId: getCourse.courseId,
      courseName: getCourse.courseName,
      projectStartDate: getCourse.projectStartDate,
      projectEndDate: getCourse.projectEndDate,
    };
  }
};

const updateVivaSchedule = async (courseId, startDate, endDate) => {
  const startDate_ = parseDate(startDate);
  const endDate_ = parseDate(endDate);
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Reset time to midnight to only compare dates

  // Validation checks
  if (startDate_ < today) {
    throw new AppError("Viva Start Date cannot be before today", 400);
  }
  if (endDate_ < today) {
    throw new AppError("Viva End Date cannot be before today", 400);
  }
  if (startDate_ > endDate_) {
    throw new AppError("Viva Start Date cannot be after Viva End Date", 400);
  }
  if (startDate === endDate) {
    throw new AppError("Start and End Date cannot be the same", 400);
  }

  // Find the course
  const course = await courseRepository.findCourseById(courseId);
  if (!course) {
    throw new AppError("Course not found", 400);
  }

  // Update course schedule
  course.vivaStartDate = startDate_;
  course.vivaEndDate = endDate_;
  await course.save();

  // Return the updated course details
  return {
    _id: course._id,
    courseId: course.courseId,
    courseName: course.courseName,
    vivaStartDate: course.vivaStartDate,
    vivaEndDate: course.vivaEndDate,
  };
};

const sendAllCourses = async (userId) => {
  let user = await courseRepository.findStudentById(userId);
  if (!user) {
    user = await courseRepository.findTeacherById(userId);
    if (!user) {
      throw new AppError("User Not Found", 400);
    }
  }
  await user.populate({
    path: "courses",
    populate: {
      path: "teacher",
      model: "Teacher", // Replace 'Teacher' with your actual model name
    },
  });
  return { courses: user.courses };
};

const sendCourse = async (courseId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 201);
  }
  await getCourse.populate({
    path: "projects",
    populate: {
      path: "projectLeader status",
    },
  });
  await getCourse.populate("students");
  await getCourse.populate("vivas");
  return {
    _id: getCourse._id,
    courseCode: getCourse.courseCode,
    courseName: getCourse.courseName,
    description: getCourse.description,
    projectRequirements: getCourse.projectRequirements,
    students: getCourse.students,
    projects: getCourse.projects,
    vivas: getCourse.vivas,
    projectStartDate: getCourse.projectStartDate,
    projectEndDate: getCourse.projectEndDate,
    vivaStartDate: getCourse.vivaStartDate,
    courseNotifications: getCourse.courseNotifications,
    vivaNotifications: getCourse.vivaNotifications,
    vivaEndDate: getCourse.vivaEndDate,
  };
};

const updateCourse = async (courseId, body) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  for (const key in body) {
    getCourse[key] = body[key];
  }
  await getCourse.save();
  return getCourse;
};

const regenerateCourseCode = async (courseId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  const courses = await courseRepository.findAllCourses();
  const courseCode = generateCourseCode(courses);
  getCourse.courseCode = courseCode;
  await getCourse.save();
  return getCourse;
};

const addStudentToCourse = async (courseId, studentId) => {
  const student = await courseRepository.findStudentById(studentId);
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  if (!student) {
    throw new AppError("Student Not Found", 400);
  }
  await student.populate("account", "-password -otp");
  if (student.account.email_verified == false) {
    throw new AppError("Student Email Not Verified", 400);
  }
  await getCourse.populate("students");
  for (const stu of getCourse.students) {
    if (stu.id == student.id) {
      throw new AppError("Student Already Joined", 201);
    }
  }
  student.courses.push(courseId);
  await student.save();
  getCourse.students.push(studentId);
  await getCourse.save();
  return {
    _id: getCourse._id,
    courseCode: getCourse.courseCode,
    courseName: getCourse.courseName,
    students: getCourse.students,
  };
};

const removeStudentFromCourse = async (courseId, studentId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  const student = await courseRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student Not Found", 400);
  }
  if (!getCourse.students.includes(studentId)) {
    throw new AppError("Student Not Found in Course", 400);
  }
  await courseRepository.removeStudentFromCourse(courseId, studentId);
  await courseRepository.removeCourseFromStudent(studentId, courseId);
};

const searchStudent = async (studentEmail) => {
  const account = await authRepository.findAccountByEmail(studentEmail);
  if (!account) {
    throw new AppError("Student Not Found", 400);
  }
  const student = await authRepository.findStudentByAccountId(account._id);
  if (!student) {
    throw new AppError("Student Not Found", 400);
  }
  await student.populate("account", "-password -otp");
  return student;
};

module.exports = {
  createCourse,
  joinCourse,
  updateCourseName,
  deleteCourse,
  leaveCourse,
  updateProjectSchedule,
  updateVivaSchedule,
  sendAllCourses,
  sendCourse,
  updateCourse,
  regenerateCourseCode,
  addStudentToCourse,
  removeStudentFromCourse,
  searchStudent,
};

const lectureRepository = require("../repositories/lectureRepository");
const courseRepository = require("../repositories/courseRepository");
const { deleteFileByPath } = require("../utilities/deleteFilesByPath");
const path = require("path");

const addLecture = async (courseId, teacherId, title, description, video_id) => {
  if (!title || !description) {
    throw new Error("Title and description are required");
  }

  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const isLectureExist = await lectureRepository.getLectureByTitleAndCourse(
    title,
    courseId
  );
  if (isLectureExist) {
    throw new Error(
      "Lecture with the same title already exists in the same course"
    );
  }

  const lectureData = {
    course: courseId,
    teacher: teacherId,
    title,
    description,
    video_id,
  };
  const lecture = await lectureRepository.createLecture(lectureData);
  course.lectures.push(lecture._id);
  await course.save();
  return lecture;
};

const getLecturesByCourse = async (courseId) => {
  const course = await courseRepository.getCourseById(courseId);
  await course.populate('lectures');
  return course.lectures;
};

const getLecture = async (courseId, lectureId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const lecture = await lectureRepository.getLectureById(lectureId);
  if (!lecture) {
    throw new Error("Lecture not found");
  }
  if (course.lectures.indexOf(lectureId) === -1) {
    throw new Error("Lecture not found in the course");
  }
  return lecture;
};

const updateLecture = async (
  courseId,
  lectureId,
  title,
  description,
  video_id,
  
) => {
  const lecture = await getLecture(courseId, lectureId);
  if (!courseId || !lectureId) {
    throw new Error("Course id and lecture id must be in params");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  if (course.lectures.indexOf(lectureId) === -1) {
    throw new Error("Lecture not found in the course");
  }
  if (video_id) {
    deleteFileByPath(
      path.join(__dirname, "..", "uploads", "lectures", lecture.video_id)
    );
  }

  lecture.title = title || lecture.title;
  lecture.description = description || lecture.description;
  lecture.video_id = video_id || lecture.video_id;
  lecture.updated_at = Date.now();

  return await lectureRepository.saveLecture(lecture);
};

const deleteLecture = async (courseId, lectureId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const lecture = await lectureRepository.getLectureById(lectureId);
  if (!lecture) {
    throw new Error("Lecture not found");
  }

  if (course.lectures.indexOf(lectureId) === -1) {
    throw new Error("Lecture not found in the course");
  }

  if (lecture.video_id) {
    try {
      deleteFileByPath(
        path.join(__dirname, "..", "uploads", "lectures", lecture.video_id)
      );
    } catch (err) {
      console.log(err);
    }
  }

  await lectureRepository.deleteLectureById(lectureId);

  course.lectures = course.lectures.filter(
    (id) => id.toString() !== lectureId.toString()
  );
  await course.save();
};

module.exports = {
  addLecture,
  getLecturesByCourse,
  getLecture,
  updateLecture,
  deleteLecture,
};

const pollRepository = require("../repositories/pollRepository");
const courseRepository = require("../repositories/courseRepository");
const voteRepository = require("../repositories/voteRepository");
const AppError = require("../utilities/AppError");

const addPoll = async (courseId, teacherId, title, description, options) => {
  if (!title || !options || options.length < 2 || options.length > 3) {
    throw new Error("Title and valid options (between 2 and 3) are required.");
  }

  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const pollData = {
    course: courseId,
    teacher: teacherId,
    title,
    description,
    options,
  };

  const poll = await pollRepository.createPoll(pollData);
  course.polls.push(poll._id);
  await course.save();

  return poll;
};

const getPollsByCourse = async (courseId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  return await pollRepository.getPolls(courseId);
};

const getPoll = async (courseId, pollId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const poll = await pollRepository.getPollById(pollId);
  if (!poll) {
    throw new Error("Poll not found");
  }

  if (poll.course.toString() !== courseId.toString()) {
    throw new Error("Poll not found in this course");
  }

  return poll;
};

const votePoll = async (courseId, pollId, studentId, option) => {
  if (!option) {
    throw new AppError("Option is required", 400);
  }
  const poll = await pollRepository.getPollById(pollId);

  if (!poll) {
    throw new AppError("Poll not found", 404);
  }

  if (poll.course.toString() !== courseId.toString()) {
    throw new AppError("Poll not found in this course", 404);
  }
  if (poll.options.indexOf(option) === -1) {
    throw new AppError("Invalid option", 400);
  }
  const existingVote = await voteRepository.getVoteByPollAndStudent(
    pollId,
    studentId
  );

  if (existingVote) {
    if (existingVote.option === option) {
      return poll;
    } else {
      // Update the existing vote
      existingVote.option = option;
      await voteRepository.saveVote(existingVote);
      poll.updated_at = Date.now();
      await pollRepository.savePoll(poll);
      // Retrieve the updated poll from the database
      const updatedPoll = await pollRepository.getPollById(poll._id);

      // Return the updated poll
      return updatedPoll;
    }
  } else {
    // Create a new vote
    const newVote = await voteRepository.createVote({
      poll: pollId,
      student: studentId,
      option,
    });
    poll.votes.push(newVote._id);
    poll.updated_at = Date.now();
    await pollRepository.savePoll(poll);
    return poll;
  }
};

const deletePoll = async (courseId, pollId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const poll = await pollRepository.getPollById(pollId);
  if (!poll) {
    throw new Error("Poll not found");
  }
  for (const voteId of poll.votes) {
    await voteRepository.deleteVoteById(voteId);
  }

  await pollRepository.deletePollById(pollId);

  course.polls = course.polls.filter(
    (id) => id.toString() !== pollId.toString()
  );
  await course.save();
};

module.exports = {
  addPoll,
  getPollsByCourse,
  getPoll,
  votePoll,
  deletePoll,
};

const axios = require("axios");
const proctoringReportRepository = require("../repositories/proctoringReportRepository");
const quizSubmissionRepository = require("../repositories/quizSubmissionRepository");
const quizRepository = require("../repositories/quizRepository");
const AppError = require("../utilities/AppError");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
const path = require("path");
const PDFDocument = require("pdfkit");
const fs = require("fs");

const analyzeImage = async (studentId, quizId, imagePath) => {
  const submission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );

  if (!submission) {
    throw new AppError("No submission found quiz not started yet", 404);
  }

  if (submission.isCompleted) {
    throw new AppError("Quiz has already been completed", 400);
  }

  const currentTime = new Date();
  const timeRemaining = submission.endTime - currentTime;

  // Check if at least 40 seconds remain before the quiz ends
  if (timeRemaining < 40000) {
    throw new AppError("Cannot take image, quiz about to end", 400);
  }

  // Call Flask API to analyze the image
  const response = await axios.post(`${process.env.FLASK_URL}/analyze-image`, {
    image_path: imagePath,
  });

  if (!response.data.success) {
    throw new AppError(response.data.error, 400);
  }

  // Append the proctoring image to the submission's proctoring report
  const updatedReport = await proctoringReportRepository.updateProctoringReport(
    submission.proctoringReport,
    {
      imageId: "result_" + path.basename(imagePath),
      cheatingIndicators: response.data.data,
    }
  );

  deleteFileByPath(imagePath);

  return {
    success: true,
    message: "Image analyzed successfully",
    updatedReport,
  };
};

const generatePdfReport = async (courseId, quizId, studentId) => {
  // Fetch the quiz and submission details
  const quiz = await quizRepository.findQuizById(quizId);
  if (!quiz || !quiz.course.equals(courseId)) {
    throw new AppError("Quiz not found for the given course", 404);
  }

  const submission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );

  if (!submission) {
    throw new AppError("Submission not found", 404);
  }

  if (!submission.isCompleted) {
    throw new AppError("Quiz is not completed yet", 400);
  }
  await submission.populate("student");

  // Fetch the AI proctoring report
  const proctoringReport =
    await proctoringReportRepository.getProctoringReportById(
      submission.proctoringReport
    );

  if (!proctoringReport) {
    throw new AppError("Proctoring report not found", 404);
  }

  await proctoringReport.populate("images");

  const formattedDateTime = new Date(submission.submittedAt).toLocaleString('en-GB', {
    dateStyle: 'short',
    timeStyle: 'medium',
  });

  // Generate the PDF report
  const doc = new PDFDocument();
  let buffers = [];
  doc.on("data", buffers.push.bind(buffers));
  doc.on("end", () => {});

  // Report Title
  doc.fontSize(22).text("Quiz Report", { align: "center", underline: true });
  doc.moveDown(1);

  // Quiz Details Section
  doc.fontSize(16).text("Quiz Details", { underline: true });
  doc.moveDown(0.5);
  doc.fontSize(14).text(`Student Name: ${submission.student.name}`);
  doc.fontSize(14).text(`Student ID: ${submission.student._id}`);
  doc.fontSize(14).text(`Quiz Title: ${quiz.title}`);
  doc.text(`Topic: ${quiz.topic}`);
  doc.text(`Submitted At: ${formattedDateTime}`);
  doc.moveDown(1);

  // Proctoring Report Section
  doc.fontSize(16).text("Proctoring Report", { underline: true });
  doc.moveDown(0.5);
  doc
    .fontSize(14)
    .text(`Cheating Probability: ${proctoringReport.cheating_probability}%`);
  doc.moveDown(1);

  // Adding Images to the PDF
  doc.fontSize(16).text("Proctoring Images", { underline: true });

  for (let i = 0; i < proctoringReport.images.length; i++) {
    const image = proctoringReport.images[i];
    const imagePath = path.join(
      __dirname,
      "../uploads/proctoring_result_db",
      image.image_id
    );

    if (fs.existsSync(imagePath)) {
      if (i === 0) {
        // First image on the first page
        doc.image(imagePath, {
          fit: [480, 640],
          align: "center",
          valign: "center",
        });
        doc.addPage(); // Add a new page after the first image
      } else {
        if ((i - 1) % 2 === 0) {
          // Add the first image of the new page
          doc.image(imagePath, {
            fit: [480, 640],
            align: "center",
            valign: "center",
          });
          doc.moveDown(50); // Space before the second image
        } else {
          // Add the second image on the same page
          doc.image(imagePath, {
            fit: [480, 640],
            align: "center",
            valign: "center",
          });
          doc.addPage(); // Add a new page after placing two images
        }
      }
    }
  }

  doc.end();

  // Wait until the PDF is generated
  return new Promise((resolve, reject) => {
    doc.on("end", () => {
      const pdfData = Buffer.concat(buffers);
      resolve(pdfData);
    });
    doc.on("error", (err) => {
      reject(err);
    });
  });
};

module.exports = {
  analyzeImage,
  generatePdfReport,
};

const projectRepository = require("../repositories/projectRepository");
const authRepository = require("../repositories/authRepository");
const statusRepository = require("../repositories/statusRepository");

const AppError = require("../utilities/AppError");

const createProject = async (userId, projectData) => {
  const { name, scope, members, courseId } = projectData;

  // Validate student and course existence
  const student = await projectRepository.findStudentById(userId);
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }

  const checkCourse = await projectRepository.findCourseById(courseId);
  if (!checkCourse) {
    throw new AppError("Course Not Found", 404);
  }

  // Validate project uniqueness within the course
  const existingProject = await projectRepository.findProjectByNameAndCourse(
    name,
    courseId
  );
  if (existingProject) {
    throw new AppError(
      "Project with the same name already exists in this course",
      409
    );
  }

  // Ensure the student is not already leading another project in the same course
  const existingLeaderProject =
    await projectRepository.findProjectByLeaderAndCourse(student, checkCourse);
  if (existingLeaderProject) {
    throw new AppError("You are already leading a group in this course", 409);
  }

  // Validate all members
  for (const member of members) {
    const groupMember = await projectRepository.findStudentById(member);
    console.log(groupMember);
    if (!groupMember) {
      throw new AppError(`Member with ID ${member} not found`, 404);
    }

    // Ensure member is enrolled in the course
    if (!groupMember.courses.includes(courseId)) {
      throw new AppError(
        `Member ${groupMember.name} is not part of the course`,
        400
      );
    }

    // Check if the member is already part of another group in the same course
    const isMemberInAnotherGroup =
      await projectRepository.findProjectByMemberAndCourse(
        groupMember,
        checkCourse
      );
    if (isMemberInAnotherGroup) {
      throw new AppError(
        `Member ${groupMember.name} is already in another group for this course`,
        409
      );
    }
  }

  // Create the project
  const project = await projectRepository.createProject({
    name,
    scope,
    projectLeader: student,
    course: checkCourse,
  });

  // Set student as group leader
  student.isGroupLeader = true;
  await student.save();

  // Add members to the project
  for (const member of members) {
    const groupMember = await projectRepository.findStudentById(member);
    project.members.push(groupMember);
  }

  // Create and assign initial project status
  const status = await projectRepository.createStatus({
    status: "pending",
    description: "",
  });
  if (!status) {
    throw new AppError("Failed to save status due to an internal error", 500);
  }
  project.status = status;

  // Save the project and update course with the new project
  await project.save();
  checkCourse.projects.push(project);
  await checkCourse.save();

  // Return the created project details
  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course._id,
  };
};

const updateProject = async (projectId, projectData) => {
  const { name, scope, members, courseId } = projectData;

  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }

  // Validate and collect new members
  const validMembers = [];
  for (const memberId of members) {
    const member = await projectRepository.findStudentById(memberId);
    if (!member) {
      throw new AppError(`Member with ID ${memberId} not found`, 404);
    }

    // Ensure member is enrolled in the course
    if (!member.courses.includes(courseId)) {
      throw new AppError(
        `Member ${member.name} is not part of the course`,
        400
      );
    }

    // Check if the member is already part of another group in the same course
    const isMemberInAnotherGroup =
      await projectRepository.findProjectByMemberAndCourse(member, courseId);
    if (
      isMemberInAnotherGroup &&
      isMemberInAnotherGroup._id.toString() !== projectId.toString()
    ) {
      throw new AppError(
        `Member ${member.name} is already in another group for this course`,
        409
      );
    }

    validMembers.push(member);
  }

  // Update the project with new data
  const updatedProject = await projectRepository.updateProjectById(projectId, {
    name,
    scope,
    members: validMembers,
  });

  return {
    _id: updatedProject._id,
    name: updatedProject.name,
    scope: updatedProject.scope,
    members: updatedProject.members,
    projectLeader: updatedProject.projectLeader,
    course: updatedProject.course,
  };
};

const getProjectById = async (projectId) => {
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 400);
  }

  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course,
  };
};

const addMemberToProject = async (projectId, email, courseId) => {
  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }
  if (project.members.length > 4) {
    throw new AppError("You cannot add more then 4 members", 400);
  }
  // Find the student by email
  const account = await authRepository.findAccountByEmail(email);
  const member = await authRepository.findStudentByAccountId(account._id);
  if (!member) {
    throw new AppError(`Member with email ${email} not found`, 404);
  }

  // Ensure the member is enrolled in the course
  if (!member.courses.includes(courseId)) {
    throw new AppError(`Member ${member.name} is not part of the course`, 400);
  }

  // Check if the member is already part of another group in the same course
  const isMemberInAnotherGroup =
    await projectRepository.findProjectByMemberAndCourse(member, courseId);
  if (isMemberInAnotherGroup) {
    throw new AppError(
      `Member ${member.name} is already in another group for this course`,
      409
    );
  }

  // Add the member to the project
  project.members.push(member);
  await project.save();

  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course._id,
  };
};

const removeMemberFromProject = async (projectId, memberId) => {
  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }
  if (project.members.length == 0) {
    throw new AppError("Cannot remove you are only on member", 400);
  }

  // Check if the member is part of the project
  const memberIndex = project.members.findIndex(
    (member) => member._id.toString() === memberId
  );
  if (memberIndex === -1) {
    throw new AppError("Member not found in this project", 404);
  }

  // Remove the member from the project
  project.members.splice(memberIndex, 1);
  await project.save();

  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course._id,
  };
};

const deleteProject = async (projectId, userId) => {
  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }

  // Find the course associated with the project
  const course = await projectRepository.findCourseById(project.course._id);
  if (!course) {
    throw new AppError("Course Not Found", 404);
  }

  // Ensure the user is either the course creator or the project leader
  const isCourseCreator = course.teacher.toString() === userId.toString();
  const isProjectLeader =
    project.projectLeader._id.toString() === userId.toString();
  if (!isCourseCreator && !isProjectLeader) {
    throw new AppError(
      "Unauthorized: Only the course creator or project leader can delete this project",
      403
    );
  }

  // Remove the project from the course's project list
  course.projects.pull(projectId);
  await course.save();

  // Delete the project's status
  if (project.status) {
    await statusRepository.deleteStatus(project.status._id);
  }

  // Delete the project
  await projectRepository.deleteProjectById(projectId);
};

module.exports = {
  createProject,
  updateProject,
  getProjectById,
  addMemberToProject,
  removeMemberFromProject,
  deleteProject
};

const quizRepository = require("../repositories/quizRepository");
const questionRepository = require("../repositories/questionRepository");
const courseRepository = require("../repositories/courseRepository");
const quizSubmissionRepository = require("../repositories/quizSubmissionRepository");
const proctoringReportRepository = require("../repositories/proctoringReportRepository");
const { calculateQuizScore } = require("../utilities/calculateQuizScore");
const _ = require("lodash");
const AppError = require("../utilities/AppError");
const axios = require("axios");

const createQuiz = async (
  courseId,
  title,
  topic,
  questions,
  deadline,
  duration,
  number_of_questions
) => {
  if (
    !courseId ||
    !title ||
    !questions ||
    !topic ||
    !deadline ||
    !duration ||
    !number_of_questions
  ) {
    throw new AppError("Input all required fields", 400);
  }
  if (new Date(deadline) < new Date()) {
    throw new AppError("Deadline must be in the future", 400);
  }
  let course = await courseRepository.getCourseById(courseId);

  if (!course) {
    throw new AppError("Course not found", 404);
  }
  const questionIds = [];
  for (const questionData of questions) {
    let question = await questionRepository.findQuestionByContent(
      questionData.content
    );
    if (!question) {
      question = await questionRepository.createQuestion(questionData);
    }
    questionIds.push(question._id);
  }

  const quiz = await quizRepository.createQuiz({
    course,
    title,
    deadline,
    topic,
    duration,
    number_of_questions,
    questions: questionIds,
  });
  course.quizzes.push(quiz._id);
  await course.save();

  return quiz;
};

const updateQuiz = async (
  quizId,
  title,
  topic,
  questions,
  deadline,
  duration,
  number_of_questions
) => {
  if (
    !quizId ||
    !title ||
    !questions ||
    !topic ||
    !deadline ||
    !duration ||
    !number_of_questions
  ) {
    throw new AppError("Input all required fields", 400);
  }

  const quiz = await quizRepository.getQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }
  if (new Date(deadline) < new Date()) {
    throw new AppError("Deadline must be in the future", 400);
  }
  const questionIds = [];
  for (const questionData of questions) {
    let question = await questionRepository.findQuestionByContent(
      questionData.content
    );
    if (!question) {
      question = await questionRepository.createQuestion(questionData);
    }
    questionIds.push(question._id);
  }

  quiz.title = title;
  quiz.topic = topic;
  quiz.deadline = deadline;
  quiz.duration = duration;
  quiz.number_of_questions = number_of_questions;
  quiz.questions = questionIds;
  await quiz.save();
  return quiz;
};

const deleteQuiz = async (quizId, courseId) => {
  const quiz = await quizRepository.getQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  if (courseId !== quiz.course.toString()) {
    throw new AppError("Course ID does not match", 400);
  }
  // Delete quiz
  await quizRepository.deleteQuizById(quizId);
  // Remove the quiz reference from the associated course
  const course = await courseRepository.getCourseById(quiz.course);
  if (!course) {
    throw new AppError("Course not found", 404);
  }
  course.quizzes.pull(quizId);
  await course.save();
};

const getQuiz = async (id, courseId) => {
  const quiz = await quizRepository.findQuizById(id);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }
  if (quiz.course.toString() !== courseId) {
    throw new AppError("Course ID does not match", 400);
  }
  return quiz;
};

const getQuizStudent = async (id, courseId) => {
  const quiz = await quizRepository.findQuizById(id);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }
  if (quiz.course.toString() !== courseId) {
    throw new AppError("Course ID does not match", 400);
  }

  // Shuffle the questions
  const shuffledQuestions = _.shuffle(quiz.questions);

  // Get the number of questions stated in the quiz model
  const numberOfQuestions = quiz.number_of_questions;

  // Return the specified number of questions
  const selectedQuestions = shuffledQuestions.slice(0, numberOfQuestions);

  // If you need to return the entire quiz object with the modified questions
  return { ...quiz.toObject(), questions: selectedQuestions };
};

const getQuizzesByCourse = async (courseId) => {
  const quizzes = await quizRepository.getQuizzesByCourse(courseId);
  return quizzes;
};

const startQuiz = async (quizId, studentId) => {
  const quiz = await quizRepository.getQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  const existingSubmission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );
  if (existingSubmission && !existingSubmission.isCompleted) {
    throw new AppError("Quiz is already started and not completed", 400);
  }

  const startTime = new Date();
  const endTime = new Date(startTime.getTime() + quiz.duration * 60000);

  const newSubmission = await quizSubmissionRepository.createSubmission({
    quiz: quizId,
    student: studentId,
    startedAt: startTime,
    endTime: endTime,
  });

  quiz.submissions.push(newSubmission._id);
  await quiz.save();

  // Create the proctoring report and link it to the submission
  const proctoringReport =
    await proctoringReportRepository.createProctoringReport({
      images: [],
      cheating_indicators: {
        mobile_phone: 0,
        extra_person: 0,
        mouth_open: 0,
        no_person: 0,
        eye_left_right: 0,
      },
    });

  newSubmission.proctoringReport = proctoringReport;
  await newSubmission.save();

  return newSubmission;
};

const submitQuiz = async (quizId, studentId, answers) => {
  // Find the submission for the given quiz and student
  const submission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );

  // Validate if answers are provided
  if (!answers) {
    throw new AppError("Input answers");
  }

  // Fetch the quiz details by ID
  const quiz = await quizRepository.findQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  // Check if the submission exists
  if (!submission) {
    throw new AppError("Submission not found", 404);
  }

  // Check if the quiz has already been submitted
  if (submission.isCompleted) {
    throw new AppError("Quiz already submitted", 400);
  }

  // Ensure the submission is within the allowed time
  const currentTime = new Date();
  if (currentTime > submission.endTime) {
    throw new AppError("Quiz time has expired", 400);
  }

  // Update submission with the provided answers
  submission.answers = answers;
  submission.submittedAt = currentTime;
  submission.isCompleted = true;

  // Fetch the proctoring report linked to the submission
  const proctoringReport =
    await proctoringReportRepository.getProctoringReportById(
      submission.proctoringReport
    );

  // Extract features from the proctoring report for cheating detection
  const features = [
    proctoringReport.images.length,
    proctoringReport.cheating_indicators.mobile_phone,
    proctoringReport.cheating_indicators.extra_person,
    proctoringReport.cheating_indicators.mouth_open,
    proctoringReport.cheating_indicators.no_person,
    proctoringReport.cheating_indicators.eye_left_right,
  ];

  // Make a request to the Flask API to assess cheating probability
  let isFlagged = false;
  const response = await axios.post(
    `${process.env.FLASK_URL}/predict-cheating`,
    {
      features: features,
    }
  );

  // Extract cheating probability from the response
  const cheatingProbability = response.data.data.cheating_probability;

  // Flag the submission if cheating probability is above the threshold
  if (cheatingProbability > 60) {
    isFlagged = true;
  }

  if (isFlagged) {
    submission.isFlagged = true;
  }

  // Update the proctoring report with the cheating probability
  proctoringReport.cheating_probability = cheatingProbability;

  // Calculate and assign the quiz score based on the submitted answers
  submission.score = calculateQuizScore(answers, quiz.questions);

  // Save the updated proctoring report and submission
  await proctoringReport.save();
  await submission.save();

  // Return the updated submission
  return submission;
};

const updateSubmissionMarks = async (courseId, quizId, submissionId, newScore) => {
  // Get the course by its ID
  const course = await courseRepository.getCourseById(courseId);
  
  // Check if the course exists
  if (!course) {
    throw new AppError("Course not found", 404);
  }

  // Check if the quiz belongs to the course
  const quizBelongsToCourse = course.quizzes.includes(quizId);
  if (!quizBelongsToCourse) {
    throw new AppError("Quiz does not belong to the specified course", 400);
  }

  // Fetch the quiz details by ID
  const quiz = await quizRepository.findQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  // Find the submission for the given quiz and student
  const submission = await quizSubmissionRepository.findSubmissionById(submissionId);
  
  // Check if the submission exists
  if (!submission) {
    throw new AppError("Submission not found", 404);
  }

  // Check if the quiz has already been submitted
  if (!submission.isCompleted) {
    throw new AppError("Quiz has not been submitted yet", 400);
  }

  if (newScore < 0) {
    throw new AppError("Score cannot be negative", 400);
  }

  if(newScore > quiz.number_of_questions){
    throw new AppError("Score cannot be greater than the number of questions", 400);
  }
  // Update the submission score
  submission.score = newScore;

  // Save the updated submission
  await submission.save();

  return submission;
};

const updateSubmissionFlag = async (courseId, quizId, submissionId, isFlagged) => {
  // Fetch the course to ensure the quiz belongs to it
  const course = await courseRepository.getCourseById(courseId);

  // Ensure the quiz belongs to the course
  if (!course.quizzes.includes(quizId)) {
      throw new AppError("Quiz does not belong to the specified course", 404);
  }

  // Fetch the submission
  const submission = await quizSubmissionRepository.findSubmissionById(submissionId);
  if (!submission) {
      throw new AppError("Submission not found", 404);
  }

  // Ensure the submission is for the correct quiz
  if (submission.quiz.toString() !== quizId) {
      throw new AppError("Submission does not belong to the specified quiz", 400);
  }

  // Update the isFlagged status
  submission.isFlagged = isFlagged;
  await submission.save();

  return submission;
};

module.exports = {
  createQuiz,
  updateQuiz,
  deleteQuiz,
  getQuiz,
  getQuizzesByCourse,
  getQuizStudent,
  startQuiz,
  submitQuiz,
  updateSubmissionMarks,
  updateSubmissionFlag
};

const remarkRepository = require("../repositories/remarksRepository");
const AppError = require("../utilities/AppError");
const vivaRepository = require("../repositories/vivaRepository");
const submissionRepository = require("../repositories/submissionRepository");

const addRemarkToViva = async (classId, projectId, remarkData) => {
  console.log(remarkData);
  const project = await remarkRepository.findProjectByIdAndCourseId(
    projectId,
    classId
  );
  if (!project) {
    throw new AppError("Project Not Found", 400);
  }
  if (project.viva) {
    if (project.viva.status !== "taken") {
      throw new AppError("Can't Add Remark Without Taking Viva", 400);
    }
  } else {
    throw new AppError("Didn't Schedule Viva Yet", 400);
  }
  const viva = await vivaRepository.findVivaById(project.viva._id);
  if (viva.remarks) {
    throw new AppError("Remark Already Added", 400);
  }
  const remark = await remarkRepository.createRemark({
    overallPerformance: remarkData.overallPerformance,
    feedback: remarkData.feedback,
    obtainedMarks: remarkData.obtainedMarks,
    totalMarks: remarkData.totalMarks,
  });
  if (!remark) {
    throw new AppError("Not Saved due To Some Internal Error", 400);
  }
  viva.remarks = remark;
  await remarkRepository.saveViva(viva);
  return viva.remarks;
};

const updateRemark = async (remarkId, updateData) => {
  const checkRemark = await remarkRepository.findRemarkById(remarkId);
  if (!checkRemark) throw new AppError("Remark Not Found", 400);
  const updatedRemark = await remarkRepository.updateRemark(
    remarkId,
    updateData
  );
  return updatedRemark;
};

const sendRemark = async (remarkId, projectId, courseId) => {
  const project = await remarkRepository.findProjectByIdAndCourseId(
    projectId,
    courseId
  );
  if (!project) throw new AppError("Project Not Found", 400);
  const viva = await vivaRepository.findVivaById(project.viva._id);
  if (!viva) throw new AppError("Viva Not Found", 400);
  if (viva.remarks._id.toString() !== remarkId)
    throw new AppError("Remarks not exists on viva of this project", 400);
  return viva.remarks;
};

//for submission
const addRemarkToSubmission = async (courseId, submissionId, remarkData) => {
  const submission = await submissionRepository.getSubmissionById(
    submissionId
  );
  if (!submission) {
    throw new AppError("Submission Not Found", 400);
  }

  if (submission.remarks) {
    throw new AppError("Remark Already Added", 400);
  }

  const remark = await remarkRepository.createRemark(remarkData);

  if (!remark) {
    throw new AppError("Not Saved due To Some Internal Error", 400);
  }

  submission.remarks = remark;
  await submissionRepository.saveSubmission(submission);
  return submission.remarks;
};

const readSubmissionRemark = async (remarkId, submissionId, studentId) => {
  const submission = await submissionRepository.getSubmissionById(
    submissionId
  );
  if (!submission) throw new AppError("Submission Not Found", 400);
  if(submission.student.toString() !== studentId.toString()){
    throw new AppError("Not authorized", 400);
  }
  if (submission.remarks._id.toString() !== remarkId) {
    throw new AppError("Remarks not exists on this submission", 400);
  }

  return submission.remarks;
};

module.exports = {
  addRemarkToViva,
  updateRemark,
  sendRemark,
  addRemarkToSubmission,
  updateRemark,
  readSubmissionRemark,
};

const statusRepository = require("../repositories/statusRepository");
const projectRepository = require("../repositories/projectRepository");
const AppError = require("../utilities/AppError");

const addStatus = async (classId, projectId, statusData) => {
  const project = await projectRepository.findProjectByIdAndCourse(
    projectId,
    classId
  );
  if (!project) {
    throw new AppError("Project Not Found", 400);
  }
  if (project.viva) {
    throw new AppError("Viva Is Scheduled So Can't Add Status Now", 400);
  }
  if (project.status) {
    throw new AppError("Status Already Exists", 400);
  }
  const status = await statusRepository.createStatus(statusData);
  if (!status) {
    throw new AppError("Not Saved due To Some Internal Error", 400);
  }
  project.status = status;
  await project.save();
  return {
    _id: status._id,
    status: status.status,
    description: status.description,
  };
};

const updateStatus = async (statusId, statusData) => {
  const status = await statusRepository.findStatusById(statusId);
  if (!status) {
    throw new AppError("Status Not Found", 400);
  }
  const updatedStatus = await statusRepository.updateStatusById(
    statusId,
    statusData
  );
    if (!updatedStatus) {
        throw new AppError("Not Updated due To Some Internal Error", 400);
    }
    return {
        _id: updatedStatus._id,
        status: updatedStatus.status,
        description: updatedStatus.description,
    };
};

const getStatusById = async (statusId) => {
  const status = await statusRepository.findStatusById(statusId);
  if (!status) {
    throw new AppError("Status Not Found", 400);
  }
  return {
    _id: status._id,
    status: status.status,
    description: status.description,
  };
};

module.exports = {
  addStatus,
  updateStatus,
  getStatusById,
};

const submissionRepository = require("../repositories/submissionRepository");
const courseRepository = require("../repositories/courseRepository");
const assignmentRepository = require("../repositories/assignmentRepository");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
const path = require("path");

const addSubmission = async (
  courseId,
  assignmentId,
  studentId,
  document_id
) => {
  if (!courseId) {
    throw new Error("Course ID is required");
  }
  if (!assignmentId) {
    throw new Error("Assignment ID is required");
  }
  if (!studentId) {
    throw new Error("Student ID is required");
  }
  if (!document_id) {
    throw new Error("Document ID is required");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (assignment.course.toString() !== courseId) {
    throw new Error("Assignment not found in this course");
  }
  if (assignment.deadline < Date.now()) {
    throw new Error("Assignment deadline has passed");
  }
  const isSubmitted =
    await submissionRepository.getSubmissionByAssignmentAndStudent(
      assignmentId,
      studentId
    );
  if (isSubmitted) {
    throw new Error("Submission already exists update instead");
  }
  const submissionData = {
    assignment: assignmentId,
    student: studentId,
    document_id: document_id,
  };
  const submission = await submissionRepository.createSubmission(
    submissionData
  );
  assignment.submissions.push(submission._id);

  await assignmentRepository.saveAssignment(assignment);
  return submission;
};

const getSubmissionsByAssignment = async (courseId, assignmentId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (assignment.course.toString() !== courseId) {
    throw new Error("Assignment not found in this course");
  }
  const submissions = await submissionRepository.getSubmissionsByAssignmentId(
    assignmentId
  );

  return submissions;
};

const getSubmission = async (assignmentId, submissionId, studentId) => {
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) {
    throw new Error("Submission not found");
  }
  if (submission.assignment.toString() !== assignmentId) {
    throw new Error("Submission not found in this assignment");
  }
  if (submission.student.toString() !== studentId.toString()) {
    throw new Error("Not authorized to view this submission");
  }
  return submission;
};

const updateSubmission = async (
  assignmentId,
  submissionId,
  studentId,
  document_id
) => {
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (assignment.deadline < Date.now()) {
    throw new Error("Assignment deadline has passed");
  }
  const submission = await submissionRepository.getSubmissionById(submissionId);

  if (!submission) {
    throw new Error("Submission not found");
  }
  if (submission.assignment.toString() !== assignmentId) {
    throw new Error("Submission not found in this assignment");
  }
  if (submission.student.toString() !== studentId.toString()) {
    throw new Error("Not authorized to update this submission");
  }
  if (submission.document_id) {
    deleteFileByPath(
      path.join(__dirname, "../uploads", "submissions", submission.document_id)
    );
  }
  submission.document_id = document_id || submission.document_id;
  submission.submitted_at = Date.now();
  return await submissionRepository.saveSubmission(submission);
};

const deleteSubmission = async (assignmentId, submissionId, studentId) => {
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) {
    throw new Error("Submission not found");
  }
  if (submission.assignment.toString() !== assignmentId) {
    throw new Error("Submission not found in this assignment");
  }
  if(submission.student.toString() !== studentId.toString()){
    throw new Error("Not authorized to delete this submission");
  }
  if (submission.document_id) {
    deleteFileByPath(
      path.join(__dirname, "../uploads", "submissions", submission.document_id)
    );
  }
  return await submissionRepository.deleteSubmissionById(submissionId);
};

const getSubmissionTeacher = async (submissionId) => {
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) {
    throw new Error("Submission not found");
  }
  return submission;
};

module.exports = {
  addSubmission,
  getSubmissionsByAssignment,
  getSubmission,
  updateSubmission,
  deleteSubmission,
  getSubmissionTeacher
};

const vivaRepository = require("../repositories/vivaRepository");
const AppError = require("../utilities/AppError");
const { generateVivaDate, getTodayVivas } = require("../utilities/vivaHelpers");

const addViva = async (courseId, projectId) => {
  // Find the project by ID
  const project = await vivaRepository.findProjectById(projectId);
  if (!project) throw new AppError("Project Not Found", 400);

  // Ensure the project belongs to the course and is approved
  if (project.course._id != courseId)
    throw new AppError("Project Not Found In This Course", 400);
  if (project.status.status !== "approved")
    throw new AppError("Project Is Not Approved", 400);

  // Check if a viva already exists for this project
  if (project.viva) {
    throw new AppError("Viva already added");
  }

  // Find the course by ID
  const getCourse = await vivaRepository.findCourseById(courseId);
  if (!getCourse) throw new AppError("Course Not Found", 400);
  await getCourse.populate("vivas");

  // Ensure the viva start date is set
  if (!getCourse.vivaStartDate)
    throw new AppError("Viva Start Date Not Set", 400);

  // Generate a viva date
  const vivaDate = generateVivaDate(getCourse.vivas, getCourse.vivaStartDate);

  // Create a new viva
  const viva = await vivaRepository.createViva({
    status: "scheduled",
    dateCreated: new Date().toISOString().substring(0, 10),
    vivaDate,
  });

  // Associate the viva with the project indirectly
  project.viva = viva._id;
  await vivaRepository.saveProject(project);

  // Add the viva to the course's vivas array
  getCourse.vivas.push(viva);
  await vivaRepository.saveCourse(getCourse);

  // Return the newly created viva details
  return {
    _id: viva._id,
    status: viva.status,
    vivaDate: viva.vivaDate,
  };
};

const updateViva = async (vivaId, updateData) => {
  const { vivaDate } = updateData;

  // Check if vivaDate is provided
  if (vivaDate) {
    // Parse the vivaDate
    const parsedVivaDate = new Date(vivaDate);
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Reset time to midnight to only compare dates

    // Validate that the vivaDate is valid and in the future
    if (isNaN(parsedVivaDate.getTime())) {
      throw new AppError("Invalid vivaDate provided", 400);
    }
    if (parsedVivaDate < today) {
      throw new AppError("vivaDate must be a future date", 400);
    }

    // Update the parsed date in the updateData object
    updateData.vivaDate = parsedVivaDate;
  }

  // Find the viva by ID
  const viva = await vivaRepository.findVivaById(vivaId);
  if (!viva) throw new AppError("Viva Not Found", 400);

  // Proceed to update the viva
  await vivaRepository.updateViva(vivaId, updateData);
};

const sendViva = async (vivaId) => {
  const viva = await vivaRepository.findVivaById(vivaId);
  if (!viva) throw new AppError("Viva Not Found", 400);
  return viva;
};

const getTodaysViva = async (courseId) => {
  const getCourse = await vivaRepository.findCourseById(courseId);
  if (!getCourse) throw new AppError("Course Not Found", 400);

  const vivas = getTodayVivas(getCourse.vivas);
  if (vivas.length === 0) throw new AppError("No Vivas For Today", 400);

  return vivas;
};

const getAllVivas = async (courseId) => {
  const getCourse = await vivaRepository.findCourseById(courseId);
  if (!getCourse) throw new AppError("Course Not Found", 400);

  return getCourse.vivas;
};

module.exports = {
  addViva,
  updateViva,
  sendViva,
  getTodaysViva,
  getAllVivas,
};

class AppError extends Error{
    constructor(message,status){
        super()
        this.message=message;
        this.status=status;
    }
}
module.exports= AppError
const calculateQuizScore = ( answers, questions) => {
  let score = 0;

  // Iterate through the answers
  for (let i = 0; i < answers.length; i++) {
    const answer = answers[i];
    const question = questions.find(
      (q) => q._id.toString() === answer.question._id.toString()
    );
    console.log(question)
    if (question && question.correct_option === answer.selectedOption) {
      score += 1;
    }
  }

  return score;
};

module.exports = { calculateQuizScore };
function wrapAsync(fn){
    return function(req,res,next){
        fn(req,res,next).catch(e=>{next(e)});
    }
}
module.exports= wrapAsync;
const parseDate = (dateString) => {
  const [month, day, year] = dateString.split("/").map(Number);
  return new Date(year, month, day+1); // month is 0-indexed
};

module.exports = {
  parseDate,
};

const fs = require("fs");

const deleteFileByPath = (filePath) => {
  if (fs.existsSync(filePath)) {
    fs.unlink(filePath, (err) => {
      if (err) {
        throw err;
      }
    });
  }
};

module.exports = { deleteFileByPath };

const generateCourseCode=(arr)=> {
    const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
    let randomString = "";
    for (let i = 0; i < 9; i++) {
      randomString += characters[Math.floor(Math.random() * characters.length)];
    }
    for(let i of arr){
        if(i.classId === randomString){
            generateClassCode(arr)
        }
    }
    return randomString;
}
module.exports={
    generateCourseCode
}
const jwt= require('jsonwebtoken')

const generateToken= (id)=>{
    return jwt.sign({id},"hi",{expiresIn:"30d"});
}

module.exports= generateToken;
module.exports.verifyTeacherEmail=(email)=>{
    const regex = /[a-zA-Z0-9._%+-]+@faculty\.comsats\.edu\.pk/;
    return regex.test(email);
}

module.exports.verifyStudentEmail=(email)=>{
    const regex = /[a-zA-Z0-9._%+-]+@isbstudent\.comsats\.edu\.pk/;
    return regex.test(email);
}
const bcrpt= require('bcrypt')

const matchPassword= async function (password,toCompare){
    return await bcrpt.compare(password,toCompare);
}


module.exports= matchPassword;
const fs = require("fs");
const path = require("path");

const deleteFile = (fileName) => {
  const filePath = path.join(__dirname, "..", "public","profile_pictures", fileName);
  fs.unlink(filePath, (err) => {
    if (err) {
      throw err;
    }
  });
  
};

module.exports = { deleteFile };

const getLatestReview=(vivas)=> {
    if(vivas.length == 0){
        return false;
    }
    var latestViva;
    for(let viva of vivas){
        if(viva.status=='taken'){
            latestViva=viva;
            break;
        }
    }
    for(let viva of vivas){
        if(viva.status=='taken'){
            if(viva.tokenNumber > latestViva.tokenNumber){
                latestViva=viva;
            }
        }
    }
    return latestViva.review;
}

const getAverageReview=(vivas)=>{
    let totalReviews = {
        difficulty: 0,
        relevence: 0,
        clarity: 0,
        conceptual: 0,
        overallFeedback: 0
    };
    let numReviews = 0;

    for (const viva of vivas) {
        if (viva.status === 'taken') {
            const review = viva.review;
            totalReviews.difficulty += review.difficulty;
            totalReviews.relevence += review.relevence;
            totalReviews.clarity += review.clarity;
            totalReviews.conceptual += review.conceptual;
            totalReviews.overallFeedback += review.overallFeedback;
            numReviews++;
        }
    }

    if (numReviews === 0) {
        return null; // Return null if no 'talen' vivas found
    }

    const averageReview = {
        difficulty: Math.round(totalReviews.difficulty / numReviews),
        relevence: Math.round(totalReviews.relevence / numReviews),
        clarity: Math.round(totalReviews.clarity / numReviews),
        conceptual: Math.round(totalReviews.conceptual / numReviews),
        overallFeedback: Math.round(totalReviews.overallFeedback / numReviews)
    };

    return averageReview;
}


module.exports={
    getLatestReview,
    getAverageReview
}
function addBusinessDays(startDate, numDays) {
    const oneDay = 24 * 60 * 60 * 1000; // One day in milliseconds
    const weekendDays = [6, 0]; // Saturday (6) and Sunday (0)

    const startTimestamp = new Date(startDate).getTime();
    let currentTimestamp = startTimestamp;

    let addedDays = 0;

    while (addedDays < numDays) {
        currentTimestamp += oneDay;
        const currentDate = new Date(currentTimestamp);
        const currentDayOfWeek = currentDate.getDay();

        if (!weekendDays.includes(currentDayOfWeek)) {
            addedDays++;
        }
    }
    return new Date(currentTimestamp).toISOString.toISOString().substring(0, 10);
}

const generateVivaToken=(vivas)=>{
    return vivas.length+1
}
const generateVivaDate=(vivas,vivaStartDate)=>{
    if(vivas.length<=10){
        return vivaStartDate;
    }else if(vivas.length<=20){
        return addBusinessDays(vivaStartDate,0);
    }else if(vivas.length<=30){
        return addBusinessDays(vivaStartDate,1);
    }
}
const getTodayVivas=(vivas)=>{
    const today = new Date().toISOString().substring(0, 10);
    let finalVivas=[]
    if(vivas.length==0){
        return finalVivas;
    }
    for(let viva of vivas){
        if(viva.status=='scheduled'){
            if(viva.vivaDate.toISOString().substring(0, 10) == today){
                finalVivas.push(viva);
            }
        }
    }
    return finalVivas;
}

module.exports={
    generateVivaToken,
    generateVivaDate,
    getTodayVivas
}
