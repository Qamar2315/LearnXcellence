// Load environment variables from .env file
require("dotenv").config();

// Core Modules
const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");

// Initialize Express App
const app = express();

// Middleware Setup
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static("public"));

// Importing Routes
const routes = require("./routes"); // Assuming routes are centralized

// API Routes
app.use("/api", routes);

// Custom Middlewares
const { notFound, errorHandler } = require("./middlewares/ErrorHandler");

// Error Handling Middlewares
app.use(notFound);
app.use(errorHandler);

// Database Connection Function
async function connectToDatabase() {
  try {
    await mongoose.connect(process.env.MONGODB_URL, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log("Connected to MongoDB");
  } catch (error) {
    console.error("Failed to connect to MongoDB:", error.message);
    process.exit(1); // Exit process with failure
  }
}

// Connect to Database
connectToDatabase();

// Handle Unhandled Promise Rejections
process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled Rejection at:", promise, "reason:", reason);
  // Optionally, we can exit the process to avoid undefined behavior
  process.exit(1);
});

// Start the Server
const port = process.env.PORT || 8080;
app.listen(port, () => {
  console.log(`APP IS LISTENING ON PORT ${port}`);
});

const asyncHandler = require("../utilities/CatchAsync");
const announcementService = require("../services/announcementService");

const sendCourseAnnouncement = asyncHandler(async (req, res) => {
    const { courseId } = req.params;
    const announcement = await announcementService.sendCourseAnnouncement(courseId, req.body, req.user._id);
    res.status(201).json({
        success: true,
        message: "Announcement sent successfully",
        data: announcement
    });
});

const deleteAnnouncement = asyncHandler(async (req, res) => {
    const { announcementId } = req.params;
    const teacherId = req.user._id;
    await announcementService.deleteAnnouncement(announcementId, teacherId);
    res.status(200).json({
        success: true,
        message: "Announcement deleted successfully"
    });
});

const updateAnnouncement = asyncHandler(async (req, res) => {
    const { announcementId } = req.params;
    const teacherId = req.user._id;
    const updatedAnnouncement = await announcementService.updateAnnouncement(announcementId, req.body, teacherId);
    res.status(200).json({
        success: true,
        message: "Announcement updated successfully",
        data: updatedAnnouncement
    });
});

const getAllCourseAnnouncements = asyncHandler(async (req, res) => {
    const { courseId } = req.params;
    const courseAnnouncements = await announcementService.getAllCourseAnnouncements(courseId);
    res.status(200).json({
        success: true,
        message: "Announcements fetched successfully",
        data: courseAnnouncements
    });
});

module.exports = {
    sendCourseAnnouncement,
    deleteAnnouncement,
    updateAnnouncement,
    getAllCourseAnnouncements
};

const assignmentService = require("../services/assignmentService");
const asyncHandler = require("../utilities/CatchAsync");
const path = require("path");

const createAssignment = asyncHandler(async (req, res) => {
  const { title, description,deadline } = req.body;
  const { courseId } = req.params;
  const teacherId = req.user._id;
  let document_id;
  if (req.file) {
    document_id = req.file.filename;
  }
  const assignment = await assignmentService.addAssignment(
    courseId,
    teacherId,
    title,
    description,
    deadline,
    document_id
  );
  res.status(201).json({
    success: true,
    message: "Assignment created successfully",
    data: assignment,
  });
});

const getAssignments = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const assignments = await assignmentService.getAssignmentsByCourse(courseId);
  res.status(200).json(assignments);
});

const getAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  const assignment = await assignmentService.getAssignment(
    courseId,
    assignmentId
  );
  res.status(200).json(assignment);
});

const updateAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  const { title, description, deadline } = req.body;
  const document_id = req.file ? req.file.filename : null;

  const updatedAssignment = await assignmentService.updateAssignment(
    courseId,
    assignmentId,
    title,
    description,
    deadline,
    document_id
  );
  res.status(200).json({
    success: true,
    message: "Assignment updated successfully",
    data: updatedAssignment,
  });
});

const deleteAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  await assignmentService.deleteAssignment(courseId, assignmentId);
  res.status(201).json({ message: "Assignment deleted successfully" });
});

const downloadAssignment = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;

  // Get the assignment details
  const assignment = await assignmentService.getAssignment(courseId, assignmentId);

  if (!assignment.document_id) {
    return res.status(404).json({ error: "Assignment document not found" });
  }

  // Construct the file path
  const filePath = path.join(__dirname, "..", "uploads", "assignments", assignment.document_id);

  // Send the file as a response
  res.download(filePath, (err) => {
    if (err) {
      return res.status(500).json({ error: "Failed to download the file" });
    }
  });
});

module.exports = {
  createAssignment,
  getAssignments,
  getAssignment,
  updateAssignment,
  deleteAssignment,
  downloadAssignment,
};

const asyncHandler = require("../utilities/CatchAsync");
const authService = require("../services/authService");
const AppError = require("../utilities/AppError");

const registerStudent = asyncHandler(async (req, res) => {
  const { name, email, pass } = req.body;
  const student = await authService.registerStudent(name, email, pass);
  res.status(201).json(student);
});

const loginStudent = asyncHandler(async (req, res) => {
  const { email, pass } = req.body;
  const student = await authService.loginStudent(email, pass);
  res.status(200).json(student);
});

const registerTeacher = asyncHandler(async (req, res) => {
  const { name, email, pass } = req.body;
  const teacher = await authService.registerTeacher(name, email, pass);
  res.status(201).json(teacher);
});

const loginTeacher = asyncHandler(async (req, res) => {
  const { email, pass } = req.body;
  const teacher = await authService.loginTeacher(email, pass);
  res.status(200).json(teacher);
});

const updateStudentPassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  const studentId = req.user._id;
  const updatedStudent = await authService.updateStudentPassword(
    studentId,
    currentPassword,
    newPassword
  );
  res.status(200).json(updatedStudent);
});

const updateStudentName = asyncHandler(async (req, res) => {
  const { newName } = req.body;
  const studentId = req.user._id;
  const updatedStudent = await authService.updateStudentName(
    studentId,
    newName
  );
  res.status(200).json(updatedStudent);
});

const updateTeacherPassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  const teacherId = req.user._id;
  const updatedTeacher = await authService.updateTeacherPassword(
    teacherId,
    currentPassword,
    newPassword
  );
  res.status(200).json(updatedTeacher);
});

const updateTeacherName = asyncHandler(async (req, res) => {
  const { newName } = req.body;
  const teacherId = req.user._id;
  const updatedTeacher = await authService.updateTeacherName(
    teacherId,
    newName
  );
  res.status(200).json(updatedTeacher);
});

const getStudentInfo = asyncHandler(async (req, res) => {
  const studentId = req.params.id;
  const studentInfo = await authService.getStudentInfo(studentId);
  res.status(200).json(studentInfo);
});

const getTeacherInfo = asyncHandler(async (req, res) => {
  const teacherId = req.params.id;
  const teacherInfo = await authService.getTeacherInfo(teacherId);
  res.status(200).json(teacherInfo);
});

const uploadStudentImage = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }
  const studentId = req.user._id;
  const imageName = req.file.filename;

  const student = await authService.uploadStudentImage(studentId, imageName);
  res.status(200).json(student);
});

const uploadTeacherImage = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }
  const teacherId = req.user._id;
  const imageName = req.file.filename;

  const teacher = await authService.uploadTeacherImage(teacherId, imageName);
  res.status(200).json(teacher);
});

const generateOtp = asyncHandler(async (req, res) => {
  const account_id = req.user.account;
  const otp = await authService.generateOtp(account_id); // Call service to generate OTP and send it
  if (!otp) {
    throw new AppError("Failed to generate OTP", 404);
  }
  res.status(200).json({ message: "OTP sent successfully" });
});

const verifyOtp = asyncHandler(async (req, res) => {
  const { otp } = req.body;
  const account_id = req.user.account;
  await authService.verifyOtp(account_id, otp); // Call service to verify OTP and update the account
  res.status(200).json({ message: "Email verified successfully" });
});

const registerStudentFace = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }
  const studentId = req.user._id; // Assuming you have middleware to authenticate and set req.user
  const imagePath = req.file.path; // Path of the uploaded image

  await authService.registerStudentFace(studentId, imagePath);
  res
    .status(200)
    .json({ success: true, message: "Face data registered successfully" });
});

const verifyStudentFace = asyncHandler(async (req, res) => {
  if(!req.file){
    throw new AppError("Please provide an image")
  }
  const studentId = req.user._id; // Assuming `req.user` is set by authentication middleware
  const imagePath = req.file.path; // Path of the uploaded image
  const encoding = req.user.face_biometric_data
  const result = await authService.verifyStudentFace(
    studentId,
    imagePath,
    encoding
  );
  res.status(200).json(result);
});

module.exports = {
  registerStudent,
  loginStudent,
  registerTeacher,
  loginTeacher,
  updateStudentPassword,
  updateStudentName,
  updateTeacherPassword,
  updateTeacherName,
  getStudentInfo,
  getTeacherInfo,
  uploadStudentImage,
  uploadTeacherImage,
  generateOtp,
  verifyOtp,
  registerStudentFace,
  verifyStudentFace,
};

const asyncHandler = require("../utilities/CatchAsync");
const courseService = require("../services/courseService");

const createCourse = asyncHandler(async (req, res) => {
  const data = req.body;
  const result = await courseService.createCourse(req.user._id, data);
  res.status(201).json({
    success: true,
    message: "Course Created",
    data: result,
  });
});

const joinCourse = asyncHandler(async (req, res) => {
  const result = await courseService.joinCourse(req.user._id, req.query.courseCode);
  res.status(201).json({
    success: true,
    message: "Course Joined",
    data: result,
  });
});

const updateCourseName = asyncHandler(async (req, res) => {
  await courseService.updateCourseName(req.params.courseId, req.query.courseName);
  res.status(201).json({
    success: true,
    message: "Course Name Updated",
  });
});

const deleteCourse = asyncHandler(async (req, res) => {
  await courseService.deleteCourse(req.params.courseId, req.user._id);
  res.status(201).json({
    success: true,
    message: "Course Deleted",
  });
});

const leaveCourse = asyncHandler(async (req, res) => {
  await courseService.leaveCourse(req.params.courseId, req.user._id);
  res.status(201).json({
    success: true,
    message: "Course Left",
  });
});

const updateProjectSchedule = asyncHandler(async (req, res) => {
  const result = await courseService.updateProjectSchedule(req.params.courseId, req.body.startDate, req.body.endDate);
  res.status(201).json({
    success: true,
    message: "Project Schedule Updated",
    data: result,
  });
});

const updateVivaSchedule = asyncHandler(async (req, res) => {
  const result = await courseService.updateVivaSchedule(req.params.courseId, req.body.startDate, req.body.endDate);
  res.status(201).json({
    success: true,
    message: "Viva Schedule Updated",
    data: result,
  });
});

const sendAllCourses = asyncHandler(async (req, res) => {
  const result = await courseService.sendAllCourses(req.user.id);
  res.status(201).json({
    success: true,
    data: result,
  });
});

const sendCourse = asyncHandler(async (req, res) => {
  const result = await courseService.sendCourse(req.params.courseId);
  res.status(201).json({
    success: true,
    data: result,
  });
});

const updateCourse = asyncHandler(async (req, res) => {
  const result = await courseService.updateCourse(req.params.courseId, req.body);
  res.status(201).json({
    success: true,
    message: "Course Updated",
    data: result,
  });
});

const regenerateCourseCode = asyncHandler(async (req, res) => {
  const result = await courseService.regenerateCourseCode(req.params.courseId);
  res.status(201).json({
    success: true,
    message: "Course Code Regenerated",
    data: result,
  });
});

const addStudentToCourse = asyncHandler(async (req, res) => {
  const studentId = req.body.studentId;
  const courseId = req.params.courseId;
  const result = await courseService.addStudentToCourse(courseId, studentId);
  res.status(201).json({
    success: true,
    message: "Student Added to Course",
    data: result,
  });
});

const removeStudentFromCourse = asyncHandler(async (req, res) => {
  const studentId = req.body.studentId;
  const courseId = req.params.courseId;
  await courseService.removeStudentFromCourse(courseId, studentId);
  res.status(201).json({
    success: true,
    message: "Student Removed from Course",
  });
});

const searchStudent = asyncHandler(async (req, res) => {
  const studentEmail = req.query.search;
  const result = await courseService.searchStudent(studentEmail);
  res.status(201).json({
    success: true,
    data: result,
  });
});

module.exports = {
  createCourse,
  joinCourse,
  deleteCourse,
  updateCourseName,
  updateProjectSchedule,
  updateVivaSchedule,
  leaveCourse,
  sendAllCourses,
  sendCourse,
  updateCourse,
  regenerateCourseCode,
  addStudentToCourse,
  removeStudentFromCourse,
  searchStudent,
};

const lectureService = require("../services/lectureService");
const asyncHandler = require("../utilities/CatchAsync");
const path = require("path");

const createLecture = asyncHandler(async (req, res) => {
  const { title, description } = req.body;
  const { courseId } = req.params;
  const teacherId = req.user._id;
  let video_id;
  if (req.file) {
    video_id = req.file.filename;
  }
  const lecture = await lectureService.addLecture(
    courseId,
    teacherId,
    title,
    description,
    video_id
  );
  res.status(201).json({
    success: true,
    message: "Lecture created successfully",
    data: lecture,
  });
});

const getLectures = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const lectures = await lectureService.getLecturesByCourse(courseId);
  res.status(200).json(lectures);
});

const getLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;
  const lecture = await lectureService.getLecture(courseId, lectureId);
  res.status(200).json(lecture);
});

const updateLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;
  const { title, description } = req.body;
  const video_id = req.file ? req.file.filename : null;
  const updatedLecture = await lectureService.updateLecture(
    courseId,
    lectureId,
    title,
    description,
    video_id
  );
  res.status(200).json({
    success: true,
    message: "Lecture updated successfully",
    data: updatedLecture,
  });
});

const deleteLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;
  await lectureService.deleteLecture(courseId, lectureId);
  res.status(201).json({ message: "Lecture deleted successfully" });
});

const downloadLecture = asyncHandler(async (req, res) => {
  const { courseId, lectureId } = req.params;

  const lecture = await lectureService.getLecture(courseId, lectureId);

  if (!lecture.video_id) {
    return res.status(404).json({ error: "Lecture video not found" });
  }

  const filePath = path.join(
    __dirname,
    "..",
    "uploads",
    "lectures",
    lecture.video_id
  );

  res.download(filePath, (err) => {
    if (err) {
      return res.status(500).json({ error: "Failed to download the file" });
    }
  });
});

module.exports = {
  createLecture,
  getLectures,
  getLecture,
  updateLecture,
  deleteLecture,
  downloadLecture,
};

const notificationService = require("../services/notificationService");
const asyncHandler = require("../utilities/CatchAsync");
const AppError = require("../utilities/AppError");


// Mark a notification as read
const markNotificationAsRead = asyncHandler(async (req, res) => {
  const { notificationId } = req.params;
    const user = req.user;

  await notificationService.markNotificationAsRead(notificationId,user);

  res.status(200).json({
    success: true,
    message: "Notification marked as read successfully",
  });
});

// Get all notifications for a user
const getAllNotifications = asyncHandler(async (req, res) => {
  const user = req.user;
  const notifications = await notificationService.getAllNotifications(user);

  res.status(200).json({
    success: true,
    data: notifications,
  });
});

module.exports = {
  markNotificationAsRead,
  getAllNotifications,
};
const pollService = require("../services/pollService");
const asyncHandler = require("../utilities/CatchAsync");


const createPoll = asyncHandler(async (req, res) => {
  const { title, description, options } = req.body;
  const { courseId } = req.params;
  const teacherId = req.user._id;

  const poll = await pollService.addPoll(courseId, teacherId, title, description, options);
  res.status(201).json({
    success: true,
    message: "Poll created successfully",
    data: poll,
  });
});

const getPolls = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const polls = await pollService.getPollsByCourse(courseId);
  res.status(200).json(polls);
});

const getPoll = asyncHandler(async (req, res) => {
  const { courseId, pollId } = req.params;
  const poll = await pollService.getPoll(courseId, pollId);
  res.status(200).json(poll);
});

const votePoll = asyncHandler(async (req, res) => {
  const { courseId, pollId } = req.params;
  const { option } = req.body;
  const studentId = req.user._id;

  const poll = await pollService.votePoll(courseId, pollId, studentId, option);
  res.status(200).json({
    success: true,
    message: "Voted successfully",
    data: poll,
  });
});

const deletePoll = asyncHandler(async (req, res) => {
  const { courseId, pollId } = req.params;
  await pollService.deletePoll(courseId, pollId);
  res.status(200).json({ message: "Poll deleted successfully" });
});

module.exports = {
  createPoll,
  getPolls,
  getPoll,
  votePoll,
  deletePoll,
};

const asyncHandler = require("../utilities/CatchAsync");
const axios = require("axios");
const AppError = require("../utilities/AppError");
const proctoringService = require("../services/proctoringService");
const authRepository = require("../repositories/authRepository");
const notificationService = require("../services/notificationService");

const analyzeImage = asyncHandler(async (req, res) => {
  if (!req.file) {
    throw new AppError("Please provide an image", 400);
  }

  const studentId = req.user._id; // Get the student ID from the authenticated user
  const quizId = req.params.quizId; // Get the quiz ID from the route parameters
  const imagePath = req.file.path; // Path of the uploaded image

  // Check if the quiz submission exists and is within the allowed time frame
  const result = await proctoringService.analyzeImage(
    studentId,
    quizId,
    imagePath
  );

  res.status(200).json(result);
});

const generateReport = asyncHandler(async (req, res) => {
  const { courseId, quizId, studentId } = req.params;
  const teacherId = req.user._id; // Get the teacher ID from the authenticated user
  // Generate PDF report
  const pdfBuffer = await proctoringService.generatePdfReport(
    courseId,
    quizId,
    studentId
  );
  const teacher = await authRepository.findTeacherById(teacherId);
  const teacherAccount = await authRepository.findAccountById(teacher.account);
  const student = await authRepository.findStudentById(studentId);
  await notificationService.createNotification(
    {
      title: "Proctoring Report Generated",
      message: `Proctoring report has been generated for student ${student.name}`,
      read: false,
    },
    teacherAccount._id
  );

  // Send the generated PDF as a response
  res.setHeader("Content-Type", "application/pdf");
  res.setHeader(
    "Content-Disposition",
    `attachment; filename=report_${studentId}.pdf`
  );
  res.send(pdfBuffer);
});

module.exports = {
  analyzeImage,
  generateReport,
};

const asyncHandler = require("../utilities/CatchAsync");
const projectService = require("../services/projectService");

const createProject = asyncHandler(async (req, res) => {
  const projectData = req.body;
  const userId = req.user._id;
  const project = await projectService.createProject(userId, projectData);
  res.status(201).json({
    success: true,
    message: "Project Created Successfully",
    data: project,
  });
});

const updateProject = asyncHandler(async (req, res) => {
  const projectId = req.params.projectId;
  const projectData = req.body;
  const updatedProject = await projectService.updateProject(
    projectId,
    projectData
  );
  res.status(201).json({
    success: true,
    message: "Updated Successfully",
    data: updatedProject,
  });
});

const sendProject = asyncHandler(async (req, res) => {
  const projectId = req.params.projectId;
  const project = await projectService.getProjectById(projectId);
  res.status(201).json({
    success: true,
    message: "Project Found",
    data: project,
  });
});

const addMember = asyncHandler(async (req, res) => {
  const { projectId, courseId } = req.params;
  const { email } = req.body;
  const project = await projectService.addMemberToProject(
    projectId,
    email,
    courseId
  );
  res.status(200).json({
    success: true,
    message: "Member added successfully",
    data: project,
  });
});

const removeMember = asyncHandler(async (req, res) => {
  const { projectId, memberId } = req.params;
  const project = await projectService.removeMemberFromProject(
    projectId,
    memberId
  );
  res.status(200).json({
    success: true,
    message: "Member removed successfully",
    data: project,
  });
});

const deleteProject = asyncHandler(async (req, res) => {
  const projectId = req.params.projectId;
  const userId = req.user._id; // Assume the user's ID is available in the request
  await projectService.deleteProject(projectId, userId);
  res.status(200).json({
    success: true,
    message: "Project deleted successfully",
  });
});

const generateProjectSuggestions = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const suggestions = await projectService.generateProjectSuggestions(
    courseId
  );
  res.status(200).json({
    success: true,
    message: "Project Suggestions Generated",
    data: suggestions,
  });
});

module.exports = {
  createProject,
  updateProject,
  sendProject,
  addMember,
  removeMember,
  deleteProject,
  generateProjectSuggestions,
};

const asyncHandler = require("../utilities/CatchAsync");
const quizService = require("../services/quizService");
const AppError = require("../utilities/AppError");

const createQuiz = asyncHandler(async (req, res) => {
  const { title, topic, questions, deadline, duration, number_of_questions } =
    req.body;
  const { courseId } = req.params;
  const quiz = await quizService.createQuiz(
    courseId,
    title,
    topic,
    questions,
    deadline,
    duration,
    number_of_questions
  );
  res.status(201).json({
    success: true,
    message: "Quiz created successfully",
    data: {
      quiz,
    },
  });
});

const updateQuiz = asyncHandler(async (req, res) => {
  const { title, topic, questions, deadline, duration, number_of_questions } =
    req.body;
  const { id } = req.params;
  const quiz = await quizService.updateQuiz(
    id,
    title,
    topic,
    questions,
    deadline,
    duration,
    number_of_questions
  );
  res.status(200).json({
    success: true,
    message: "Quiz updated successfully",
    data: { quiz },
  });
});

const deleteQuiz = asyncHandler(async (req, res) => {
  const { id, courseId } = req.params;
  await quizService.deleteQuiz(id, courseId);
  res.status(200).json({
    success: true,
    message: "Quiz deleted successfully",
  });
});

const getQuiz = asyncHandler(async (req, res) => {
  const { id, courseId } = req.params;
  const quiz = await quizService.getQuiz(id, courseId);
  res.status(200).json(quiz);
});

const getQuizStudent = asyncHandler(async (req, res) => {
  const { id, courseId } = req.params;
  const quiz = await quizService.getQuizStudent(id, courseId);
  res.status(200).json(quiz);
});

const getQuizzesByCourse = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const quizzes = await quizService.getQuizzesByCourse(courseId);
  res.status(200).json(quizzes);
});

const startQuiz = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const studentId = req.user._id;
  const submission = await quizService.startQuiz(id, studentId);
  res.status(200).json({
    success: true,
    message: "Quiz started successfully",
    data: submission,
  });
});

const submitQuiz = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const studentId = req.user._id;
  const { answers } = req.body;
  const submission = await quizService.submitQuiz(id, studentId, answers);
  res.status(200).json({
    success: true,
    message: "Quiz submitted successfully",
    data: { submission },
  });
});

const updateSubmissionMarks = asyncHandler(async (req, res) => {
  const { courseId, quizId, submissionId } = req.params;
  const { newScore } = req.body;
  const submission = await quizService.updateSubmissionMarks(
    courseId,
    quizId,
    submissionId,
    newScore
  );
  res.status(200).json({
    success: true,
    message: "Quiz submission marks updated successfully",
    data: { submission },
  });
});

// Update the isFlagged status of a submission
const updateSubmissionFlag = asyncHandler(async (req, res) => {
  const { courseId, quizId, submissionId } = req.params;
  const { isFlagged } = req.body;

  // Call the service to update the flag status
  const updatedSubmission = await quizService.updateSubmissionFlag(
    courseId,
    quizId,
    submissionId,
    isFlagged
  );

  res.status(200).json({
    success: true,
    message: "Submission flag status updated successfully",
    data: {
      submission: updatedSubmission,
    },
  });
});

const generateQuizByTopic = asyncHandler(async (req, res) => {
  const { topic, numberOfQuestions, difficulty } = req.query; // Get parameters from query string

  if (!topic) {
    throw new AppError("Topic is required in the query string.", 400);
  }

  const generatedQuestions = await quizService.generateQuestionsByTopic(
    topic,
    numberOfQuestions,
    difficulty
  );

  res.status(200).json({
    success: true,
    message: "Quiz questions generated successfully",
    data: generatedQuestions,
  });
});

const generateQuizByTopicOrContent = asyncHandler(async (req, res) => {
  const { topic, numberOfQuestions, difficulty, content } = req.body;

  let generatedQuestions = await quizService.generateQuestionsByContent(
    topic,
    content,
    numberOfQuestions,
    difficulty
  );

  res.status(200).json({
    success: true,
    message: "Quiz questions generated successfully",
    data: generatedQuestions,
  });
});

// Controller Function to Handle Request
const generatePDFStudent = asyncHandler(async (req, res) => {
  try {
    const { courseId, id, studentId } = req.params;
    const pdfBuffer = await quizService.generatePDFStudent(
      courseId,
      id,
      studentId
    );

    // Set Response Headers
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename=report_${studentId}.pdf`
    );

    // Send the PDF Buffer
    res.send(pdfBuffer);
  } catch (error) {
    // Handle Errors Appropriately
    res.status(error.statusCode || 500).json({
      success: false,
      message: error.message || "An error occurred while generating the PDF",
    });
  }
});


const generatePDFAllStudents = asyncHandler(async (req, res) => {
  try {
    const { courseId, id } = req.params;

    // Use the service function to generate PDFs and create a zip file
    const zipBuffer = await quizService.generatePDFForAllStudents(courseId, id);

    // Set Response Headers for the zip file
    res.setHeader("Content-Type", "application/zip");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename=quizes_${id}.zip`
    );

    // Send the Zip file
    res.send(zipBuffer);
  } catch (error) {
    res.status(error.statusCode || 500).json({
      success: false,
      message: error.message || "An error occurred while generating the PDFs",
    });
  }
});

module.exports = {
  createQuiz,
  updateQuiz,
  deleteQuiz,
  getQuiz,
  getQuizzesByCourse,
  getQuizStudent,
  startQuiz,
  submitQuiz,
  updateSubmissionMarks,
  updateSubmissionFlag,
  generateQuizByTopic,
  generateQuizByTopicOrContent,
  generatePDFStudent,
  generatePDFAllStudents,
};

const asyncHandler = require("../utilities/CatchAsync");
const remarkService = require("../services/remarkService");

const addRemarkToViva = asyncHandler(async (req, res) => {
  const { courseId, projectId } = req.params;
  const data = await remarkService.addRemarkToViva(
    courseId,
    projectId,
    req.body
  );
  res.status(201).json({
    success: true,
    message: "Remark Added Successfully",
    data,
  });
});

const updateRemark = asyncHandler(async (req, res) => {
  const { remarkId } = req.params;
  const updatedRemark = await remarkService.updateRemark(remarkId, req.body);
  res.status(201).json({
    success: true,
    message: "updated successfully",
    data: updatedRemark,
  });
});

const sendRemark = asyncHandler(async (req, res) => {
  const { remarkId, projectId, courseId } = req.params;
  const remark = await remarkService.sendRemark(remarkId, projectId, courseId);
  res.status(201).json({
    success: true,
    message: "Remark Sent Successfully",
    data: remark,
  });
});

//For Submissions
const addRemarkToSubmission = asyncHandler(async (req, res) => {
  const { courseId, submissionId } = req.params;
  const data = await remarkService.addRemarkToSubmission(
    courseId,
    submissionId,
    req.body
  );
  res.status(201).json({
    success: true,
    message: "Remark Added Successfully",
    data,
  });
});

const updateSubmissionRemark = asyncHandler(async (req, res) => {
  const { remarkId } = req.params;
  const updatedRemark = await remarkService.updateRemark(remarkId, req.body); // Assuming you reuse the updateRemark service function
  res.status(201).json({
    success: true,
    message: "Remark updated successfully",
    data: updatedRemark,
  });
});

const readSubmissionRemark = asyncHandler(async (req, res) => {
  const { remarkId, submissionId } = req.params;
  const studentId = req.user._id;
  const remark = await remarkService.readSubmissionRemark(
    remarkId,
    submissionId,
    studentId
  );
  res.status(201).json({
    success: true,
    message: "Remark retrieved successfully",
    data: remark,
  });
});

module.exports = {
  addRemarkToViva,
  updateRemark,
  sendRemark,
  addRemarkToSubmission,
  updateSubmissionRemark,
  readSubmissionRemark,
};

const asyncHandler = require("../utilities/CatchAsync");
const statusService = require("../services/statusService");

const addStatus = asyncHandler(async (req, res) => {
    const { courseId, projectId } = req.params;
    const statusData = req.body;
    const status = await statusService.addStatus(courseId, projectId, statusData);
    res.status(201).json({
        success: true,
        message: "Added Successfully",
        data: status
    });
});

const updateStatus = asyncHandler(async (req, res) => {
    const { statusId } = req.params;
    const statusData = req.body;
    const status = await statusService.updateStatus(statusId, statusData);
    res.status(201).json({
        success: true,
        message: "Updated Successfully",
        data: status
    });
});

const sendStatus = asyncHandler(async (req, res) => {
    const { statusId } = req.params;
    const status = await statusService.getStatusById(statusId);
    res.status(201).json({
        success: true,
        message: "Status Found",
        data: status
    });
});

module.exports = {
    addStatus,
    updateStatus,
    sendStatus
};

const submissionService = require("../services/submissionService");
const asyncHandler = require("../utilities/CatchAsync");
const path = require("path");

const createSubmission = asyncHandler(async (req, res) => {
  if (!req.file) {
    res.status(400);
    throw new Error("No file uploaded");
  }
  const { courseId, assignmentId } = req.params;
  const document_id = req.file.filename;
  const studentId = req.user._id;
  const submission = await submissionService.addSubmission(
    courseId,
    assignmentId,
    studentId,
    document_id
  );

  res.status(201).json({
    success: true,
    message: "Submission created successfully",
    data: submission,
  });
});

const getSubmissions = asyncHandler(async (req, res) => {
  const { courseId, assignmentId } = req.params;
  const submissions = await submissionService.getSubmissionsByAssignment(
    courseId,
    assignmentId
  );
  res.status(200).json(submissions);
});

const getSubmission = asyncHandler(async (req, res) => {
  const { assignmentId, submissionId } = req.params;
  const studentId = req.user._id;
  const submission = await submissionService.getSubmission(
    assignmentId,
    submissionId,
    studentId
  );
  res.status(200).json(submission);
});

const updateSubmission = asyncHandler(async (req, res) => {
  if (!req.file) {
    res.status(400);
    throw new Error("No file uploaded");
  }
  const { assignmentId, submissionId } = req.params;
  const document_id = req.file.filename;
  const studentId = req.user._id;

  const updatedSubmission = await submissionService.updateSubmission(
    assignmentId,
    submissionId,
    studentId,
    document_id
  );

  res.status(200).json({
    success: true,
    message: "Submission updated successfully",
    data: updatedSubmission,
  });
});

const deleteSubmission = asyncHandler(async (req, res) => {
  const { assignmentId, submissionId } = req.params;
  const studentId = req.user._id;
  await submissionService.deleteSubmission(assignmentId, submissionId, studentId);
  res.status(200).json({ message: "Submission deleted successfully" });
});

const downloadSubmission = asyncHandler(async (req, res) => {
  const { assignmentId, submissionId } = req.params;
  const studentId = req.user._id;
  const submission = await submissionService.getSubmission(
    assignmentId,
    submissionId,
    studentId
  );
  res.download(path.join(__dirname, "../uploads", "submissions", submission.document_id));
});

const downloadSubmissionTeacher = asyncHandler(async (req, res) => {
  const { courseId, submissionId } = req.params;
  const submission = await submissionService.getSubmissionTeacher(submissionId);
  res.download(path.join(__dirname, "../uploads", "submissions", submission.document_id));
});

module.exports = {
  createSubmission,
  getSubmissions,
  getSubmission,
  updateSubmission,
  deleteSubmission,
  downloadSubmission,
  downloadSubmissionTeacher,
};

const asyncHandler = require("../utilities/CatchAsync");
const vivaService = require("../services/vivaService");

const addViva = asyncHandler(async (req, res) => {
  const { courseId, projectId } = req.params;
  const viva = await vivaService.addViva(courseId, projectId);
  res.status(201).json({
    success: true,
    message: "Viva added successfully",
    data: viva,
  });
});

const updateViva = asyncHandler(async (req, res) => {
  const { vivaId } = req.params;
  const updatedViva = await vivaService.updateViva(vivaId, req.body);
  res.status(201).json({
    success: true,
    message: "Viva updated successfully",
    data: updatedViva,
  });
});

const sendViva = asyncHandler(async (req, res) => {
  const { vivaId } = req.params;
  const viva = await vivaService.sendViva(vivaId);
  res.status(201).json({
    success: true,
    message: "Viva sent successfully",
    data: viva,
  });
});

const getTodaysViva = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const vivas = await vivaService.getTodaysViva(courseId);
  res.status(201).json({
    success: true,
    message: "Today's vivas fetched successfully",
    data: vivas,
  });
});

const getAllVivas = asyncHandler(async (req, res) => {
  const { courseId } = req.params;
  const vivas = await vivaService.getAllVivas(courseId);
  res.status(201).json({
    success: true,
    message: "All vivas fetched successfully",
    data: vivas,
  });
});

const generateVivaQuestions = asyncHandler(async (req, res) => {
    const { projectId } = req.params;
    const { numberOfQuestions, difficulty, questionType } = req.query;
  
    const questions = await vivaService.generateVivaQuestions(
      projectId,
      numberOfQuestions,
      difficulty,
      questionType
    );
  
    res.status(200).json({
      success: true,
      message: "Viva Questions Generated",
      data: questions,
    });
  });
  

module.exports = {
  addViva,
  updateViva,
  sendViva,
  getTodaysViva,
  getAllVivas,
  generateVivaQuestions
};

const Student = require("../models/Student");
const Teacher = require("../models/Teacher");
const Project = require("../models/Project");
const asyncHandler = require("../utilities/CatchAsync");
const AppError = require("../utilities/AppError");
const Course = require("../models/Course");

const isTeacher = asyncHandler(async (req, res, next) => {
  const teacher = await Teacher.findById(req.user._id);
  if (!teacher) {
    throw new AppError("Not Authorized", 401);
  }
  next();
});
const isStudent = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.user._id);
  if (!student) {
    throw new AppError("Not Authorized", 401);
  }
  next();
});

const isCourseCreator = asyncHandler(async (req, res, next) => {
  const courseId = req.params.courseId;
  const getCourse = await Course.findById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 401);
  }
  const teacher = await Teacher.findById(req.user._id);
  if (getCourse.teacher._id != teacher.id) {
    throw new AppError(
      "Not Authorized only course creator can perform this action",
      401
    );
  }
  next();
});

const isCourseStudent = asyncHandler(async (req, res, next) => {
  var isStudent = false;
  const courseId = req.body.courseId || req.params.courseId;

  for (const course_ of req.user.courses) {
    if (course_ == courseId) {
      isStudent = true;
    }
  }
  if (isStudent) {
    next();
  } else {
    throw new AppError("Not Authorized Not Student Of This Course", 401);
  }
});

const isProjectCreator = asyncHandler(async (req, res, next) => {
  const { projectId } = req.params;
  const project = await Project.findById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 401);
  } else {
    if (project.projectLeader._id != req.user.id) {
      throw new AppError(
        "Not Authorized Only Project Leader Of This Project Can Change",
        401
      );
    }
  }
  next();
});

const isProjectGroupMember = asyncHandler(async (req, res, next) => {
  const { projectId } = req.params;
  const project = await Project.findById(projectId);
  if (project.projectLeader._id == req.user.id) {
    next();
    return;
  }
  var isMember = false;
  if (!project) {
    throw new AppError("Project Not Found", 401);
  } else {
    for (let member of project.members) {
      if (member == req.user.id) {
        isMember = true;
        break;
      }
    }
  }
  if (isMember) {
    next();
  } else {
    throw new AppError(
      "Not Authorized Only Group Members Of Project Can View The Status",
      401
    );
  }
});

const isCourseCreatorOrCourseStudent = asyncHandler(async (req, res, next) => {
  const { courseId } = req.params;

  // Find the course by ID
  const course = await Course.findById(courseId).populate("teacher");
  if (!course) {
    throw new AppError("Course Not Found", 404);
  }

  const userId = req.user._id;

  // Check if the user is the course creator (teacher)
  if (course.teacher._id.toString() === userId.toString()) {
    return next();
  }

  // Check if the user is a student in the course
  const isStudent = course.students.some(
    (studentId) => studentId.toString() === userId.toString()
  );

  if (isStudent) {
    return next();
  }

  // If neither, throw an authorization error
  throw new AppError(
    "Not Authorized: You must be either the course creator or a student of this course",
    401
  );
});

module.exports = {
  isTeacher,
  isStudent,
  isCourseCreator,
  isCourseStudent,
  isProjectCreator,
  isProjectGroupMember,
  isCourseCreatorOrCourseStudent,
};

const AppError = require("../utilities/AppError")

const notFound= (req,res,next)=>{
    const error= new AppError("Requested Source Not Found",404);
    next(error);
}

const errorHandler=(err,req,res,next)=>{
    const status= err.status || 500;
    res.status(status).json({
        message:err.message
    })
}

module.exports={notFound,errorHandler}
const asyncHandler = require("../utilities/CatchAsync");
const AppError = require("../utilities/AppError");
const authRepository = require("../repositories/authRepository");

const isEmailVerified = asyncHandler(async (req, res, next) => {
  const userId = req.user._id; // Assuming `req.user` is set by authentication middleware

  // First, check if the user is a student
  let student = await authRepository.findStudentById(userId);
  if (student) {
    const account = await authRepository.findAccountById(student.account);
    if (!account) {
      return next(new AppError("Account not found", 404));
    }
    if (!account.email_verified) {
      return next(new AppError("Email not verified", 403));
    }
    return next(); // Proceed if the email is verified
  }

  // If not a student, check if the user is a teacher
  let teacher = await authRepository.findTeacherById(userId);
  if (teacher) {
    const account = await authRepository.findAccountById(teacher.account);
    if (!account) {
      return next(new AppError("Account not found", 404));
    }
    if (!account.email_verified) {
      return next(new AppError("Email not verified", 403));
    }
    return next(); // Proceed if the email is verified
  }

  // If not a student or teacher
  return next(new AppError("User not found", 404));
});

module.exports = { isEmailVerified };

const jwt= require('jsonwebtoken')
const Student= require('../models/Student')
const Teacher= require('../models/Teacher')
const asyncHandler=require('../utilities/CatchAsync');
const AppError = require('../utilities/AppError');

const isLogin= asyncHandler(async (req,res,next)=>{
    let token;
    if(
        req.headers.authorization &&
        req.headers.authorization.startsWith("Bearer")
    ){
        try{
            token=req.headers.authorization.split(" ")[1];
            const decoded= jwt.verify(token,"hi");
            const teacher=await Teacher.findById(decoded.id);
            const student=await Student.findById(decoded.id);
            if(teacher){
                req.user=teacher;
            }else if(student){
                req.user=student;
            }else{
                throw new AppError("NOT AUTHORIZED, TOKEN FAILED!",201);
            }
            next();
        }catch(error){
            throw new AppError("NOT AUTHORIZED, TOKEN FAILED!",201);
        }
    }
    if(!token){
        throw new AppError("NOT AUTHORIZED, NO TOKEN");
    }
})

module.exports={
    isLogin
};
const {
  registerSchema,
  loginSchema,
  updateNameSchema,
  updatePasswordSchema,
  otpSchema,
  emailSchema,
} = require("../schemas/authSchema");
const { courseSchema } = require("../schemas/courseSchema");
const { dateSchema } = require("../schemas/dateSchema");
const { projectSchema } = require("../schemas/projectSchema");
const { remarkSchema } = require("../schemas/remarkSchema");
const { statusSchema } = require("../schemas/statusSchema");
const { vivaSchema } = require("../schemas/vivaSchema");
const { reviewSchema } = require("../schemas/reviewSchema");
const { announcementSchema } = require("../schemas/announcementSchema");
const { quizSchema } = require("../schemas/quizSchema");
const {
  updateSubmissionMarksSchema,
} = require("../schemas/updateSubmissionMarksSchema");
const {
  updateSubmissionFlagSchema,
} = require("../schemas/updateSubmissionFlagSchema");
const { assignmentSchema } = require("../schemas/assignmentSchema");
const { pollSchema } = require("../schemas/pollSchema");
const { addRemoveStudentSchema } = require("../schemas/addRemoveStudentSchema");
const {
  quizGenerationBodySchema,
  quizGenerationQuerySchema,
} = require("../schemas/quizGenerationSchemas");
const AppError = require("../utilities/AppError");

module.exports.validateRegister = (req, res, next) => {
  const { error } = registerSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateLogin = (req, res, next) => {
  const { error } = loginSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateCourse = (req, res, next) => {
  // console.log(req.body);
  const { error } = courseSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateDate = (req, res, next) => {
  // console.log(req.body);
  const { error } = dateSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateProject = (req, res, next) => {
  // console.log(req.body);
  const { error } = projectSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateRemark = (req, res, next) => {
  // console.log(req.body);
  const { error } = remarkSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateStatus = (req, res, next) => {
  // console.log(req.body);
  const { error } = statusSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateViva = (req, res, next) => {
  // console.log(req.body);
  const { error } = vivaSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateReview = (req, res, next) => {
  // console.log(req.body);
  const { error } = reviewSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateAnnouncement = (req, res, next) => {
  // console.log(req.body);
  const { error } = announcementSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdatePassword = (req, res, next) => {
  const { error } = updatePasswordSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdateName = (req, res, next) => {
  const { error } = updateNameSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateOtp = (req, res, next) => {
  const { error } = otpSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateQuiz = (req, res, next) => {
  const { error } = quizSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdateQuizScore = (req, res, next) => {
  const { error } = updateSubmissionMarksSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateUpdateSubmissionFlag = (req, res, next) => {
  const { error } = updateSubmissionFlagSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateAssignment = (req, res, next) => {
  const { error } = assignmentSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validatePoll = (req, res, next) => {
  const { error } = pollSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

module.exports.validateAddRemoveStudent = (req, res, next) => {
  const { error } = addRemoveStudentSchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

// Middleware for validating request body
module.exports.validateQuizGenerationBody = (req, res, next) => {
  const { error } = quizGenerationBodySchema.validate(req.body);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};

// Middleware for validating query parameters
module.exports.validateQuizGenerationQuery = (req, res, next) => {
  const { error } = quizGenerationQuerySchema.validate(req.query);
  if (error) {
    const msg = error.details.map((el) => el.message).join(",");
    throw new AppError(msg, 400);
  } else {
    next();
  }
};
const multer = require("multer");
const path = require("path");
const fs = require("fs");

const assignment_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "assignments"
);

if (!fs.existsSync(assignment_dataDir)) {
  fs.mkdirSync(assignment_dataDir, { recursive: true });
}

const assignmentStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, assignment_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const assignmentStorageFilter = (req, file, cb) => {
  const allowedTypes = /doc|docx|pdf/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadAssignment = multer({
    storage: assignmentStorage,
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter: assignmentStorageFilter,
});

module.exports = {
    uploadAssignment,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const face_images_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "face_biometric_data"
);

if (!fs.existsSync(face_images_dataDir)) {
  fs.mkdirSync(face_images_dataDir, { recursive: true });
}

const faceBiometricDataStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, face_images_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const faceBiometricDataStorageFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadFaceBiometricData = multer({
  storage: faceBiometricDataStorage,
  limits: { fileSize: 1 * 1024 * 1024 },
  fileFilter: faceBiometricDataStorageFilter,
});

module.exports = {
  uploadFaceBiometricData,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const lectureDataDir = path.join(__dirname, "..", "..", "uploads", "lectures");

if (!fs.existsSync(lectureDataDir)) {
  fs.mkdirSync(lectureDataDir, { recursive: true });
}

const lectureStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, lectureDataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const lectureStorageFilter = (req, file, cb) => {
  const allowedTypes = /mp4|avi|mkv/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only video files are allowed (mp4, avi, mkv)"));
  }
};

const uploadLecture = multer({
  storage: lectureStorage,
  limits: { fileSize: 100 * 1024 * 1024 }, // 100 MB limit
  fileFilter: lectureStorageFilter,
});

module.exports = {
  uploadLecture,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const proctor_images_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "proctor_images_data"
);

if (!fs.existsSync(proctor_images_dataDir)) {
  fs.mkdirSync(proctor_images_dataDir, { recursive: true });
}

const proctoringImageStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, proctor_images_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const proctoringImageStorageFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadProctoringImage = multer({
  storage: proctoringImageStorage,
  limits: { fileSize: 1 * 1024 * 1024 },
  fileFilter: proctoringImageStorageFilter,
});

module.exports = {
  uploadProctoringImage,
};

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const profilePicturesDir = path.join(
  __dirname,
  "..",
  "..",
  "public",
  "profile_pictures"
);

if (!fs.existsSync(profilePicturesDir)) {
  fs.mkdirSync(profilePicturesDir, { recursive: true });
}

// Configuration for logo uploads
const profileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, profilePicturesDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const profileStorageFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadProfile = multer({
  storage: profileStorage,
  limits: { fileSize: 1 * 1024 * 1024 },
  fileFilter: profileStorageFilter,
});

module.exports = { uploadProfile };

const multer = require("multer");
const path = require("path");
const fs = require("fs");

const submission_dataDir = path.join(
  __dirname,
  "..",
  "..",
  "uploads",
  "submissions"
);

if (!fs.existsSync(submission_dataDir)) {
  fs.mkdirSync(submission_dataDir, { recursive: true });
}

const submissionStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, submission_dataDir);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const submissionStorageFilter = (req, file, cb) => {
  const allowedTypes = /doc|docx|pdf/;
  const extname = allowedTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    cb(new Error("Only JPEG, JPG, and PNG files are allowed"));
  }
};

const uploadSubmission = multer({
    storage: submissionStorage,
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter: submissionStorageFilter,
});

module.exports = {
    uploadSubmission,
};

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const accountSchema = new schema({
  email: String,
  username: String,
  profile_picture:String,
  password: String,
  email_verified: Boolean,
  notifications: [
    {
      type: schema.Types.ObjectId,
      ref: "Notification",
    },
  ],
  created_at: Date,
  updated_at: Date,
  otp:{
    type: schema.Types.ObjectId,
    ref: 'Otp'
  }
});
module.exports = mongoose.model("Account", accountSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const announcementSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  teacher: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  content: String,
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Announcement", announcementSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const assignmentSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  teacher: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  description: String,
  document_id: String,
  deadline: Date,
  submissions: [
    {
      type: schema.Types.ObjectId,
      ref: "Submission",
    },
  ],
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Assignment", assignmentSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const courseSchema = new schema({
  courseCode: String,
  courseName: String,
  description: String,
  projectRequirements: String,
  teacher: {
    type: schema.Types.ObjectId,
    ref: "Teacher",
  },
  vivas: [
    {
      type: schema.Types.ObjectId,
      ref: "Viva",
    },
  ],
  projects: [
    {
      type: schema.Types.ObjectId,
      ref: "Project",
    },
  ],
  announcements: [
    {
      type: schema.Types.ObjectId,
      ref: "Announcement",
    },
  ],
  polls: [
    {
      type: schema.Types.ObjectId,
      ref: "Poll",
    },
  ],
  lectures: [
    {
      type: schema.Types.ObjectId,
      ref: "Lecture",
    },
  ],
  assignments: [
    {
      type: schema.Types.ObjectId,
      ref: "Assignment",
    },
  ],
  quizzes:[
    {
      type: schema.Types.ObjectId,
      ref: "Quiz",  
    }
  ],
  students: [
    {
      type: schema.Types.ObjectId,
      ref: "Student",
    },
  ],
  projectStartDate: Date,
  projectEndDate: Date,
  vivaStartDate: Date,
  vivaEndDate: Date,
});
module.exports = mongoose.model("Course", courseSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const lectureSchema = new schema({
  course_id: { type: schema.Types.ObjectId, ref: "Course" },
  teacher_id: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  description: String,
  video_id: String,
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Lecture", lectureSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const notificationSchema = new schema({
  account: { type: schema.Types.ObjectId, ref: "Account" },
  title: String,
  content: String,
  read: Boolean,
  created_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Notification", notificationSchema);

// otpModel.js
const mongoose = require('mongoose');
const schema = mongoose.Schema;

const otpSchema = new schema({
  otp: Number,
  createdAt: { type: Date, default: Date.now } // Add createdAt field
});

module.exports = mongoose.model('Otp', otpSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const pollSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  teacher: { type: schema.Types.ObjectId, ref: "Teacher" },
  title: String,
  description: String,
  options: {
    type: [{
      type: String,
      minlength: 1,
      maxlength: 100
    }],
    validate: {
      validator: function(options) {
        return options.length >= 2 && options.length <= 3;
      },
      message: "Options should have 2 to 3 elements."
    }
  },
  votes: [{ type: schema.Types.ObjectId, ref: "Vote" }],
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});
  
  module.exports = mongoose.model("Poll", pollSchema);
  
const mongoose = require("mongoose");
const schema = mongoose.Schema;

// Define the AIProctoringReport schema
const aiProctoringReportSchema = new schema({
    images: [{ type: schema.Types.ObjectId, ref: "ProctoringImage" }],
    cheating_indicators: {
      mobile_phone: Number,
      extra_person: Number,
      mouth_open: Number,
      no_person: Number,
      eye_left_right: Number
    },
    cheating_probability: Number,
    created_at: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
  });

module.exports = mongoose.model("AIProctoringReport", aiProctoringReportSchema);

const mongoose = require('mongoose');
const schema=mongoose.Schema;

const projectSchema=new schema({
    name:String,
    scope:String,
    members:[
        {
            type: schema.Types.ObjectId,
            ref:'Student',
            min:1,
            max:4
        }
    ],
    projectLeader:{
        type: schema.Types.ObjectId,
        ref:'Student'
    },
    course:{
        type: schema.Types.ObjectId,
        ref:'Course'
    },
    status:
    {
        type: schema.Types.ObjectId,
        ref:'Status'
    },
    viva:{
        type: schema.Types.ObjectId,
        ref:'Viva'
    }
});
module.exports=mongoose.model('Project',projectSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

// Define the ProctoringImage schema
const proctoringImageSchema = new schema({
  image_id: String,
  timestamp: { type: Date, default: Date.now },
  cheating_indicators: {
    mobile_phone: Boolean,
    extra_person: Boolean,
    mouth_open: Boolean,
    no_person: Boolean,
    eye_gaze: String
  },
});

module.exports = mongoose.model("ProctoringImage", proctoringImageSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const questionSchema = new schema({
  content: String,
  options: [{
    type:String,
    min: 4,
    max: 4
  }],
  correct_option: String,
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Question", questionSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const quizSchema = new schema({
  course: { type: schema.Types.ObjectId, ref: "Course" },
  title: String,
  topic:String,
  questions: [{ type: schema.Types.ObjectId, ref: "Question" }],
  duration: Number,
  number_of_questions: Number,
  deadline: Date,
  submissions: [{ type: schema.Types.ObjectId, ref: "QuizSubmission" }],
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Quiz", quizSchema);

const mongoose = require("mongoose");
const schema = mongoose.Schema;

const submissionSchema = new schema({
  quiz: { type: schema.Types.ObjectId, ref: "Quiz" },
  student: { type: schema.Types.ObjectId, ref: "Student" },
  proctoringReport: { type: schema.Types.ObjectId, ref: "AIProctoringReport" },
  answers: [
    {
      question: { type: schema.Types.ObjectId, ref: "Question" },
      selectedOption: String,
    },
  ],
  score: Number,
  startedAt: { type: Date, default: Date.now },
  endTime: { type: Date },
  submittedAt: { type: Date },
  isCompleted: { type: Boolean, default: false },
  isFlagged: { type: Boolean, default: false },
});

module.exports = mongoose.model("QuizSubmission", submissionSchema);

const mongoose = require('mongoose');
const schema=mongoose.Schema;

const remarkSchema=new schema({
    overallPerformance: { type: String, enum: ['Bad', 'Poor', 'Fair', 'Good', 'Excellent'] },
    feedback: String,
    obtainedMarks: Number,
    totalMarks: Number,
    dateCreated: { type: Date, default: Date.now },
    updated_at: { type: Date, default: Date.now },
});
module.exports=mongoose.model('Remarks',remarkSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const statusSchema=new schema({
    status:{
        type:String,
        enum:['approved','pending','disapproved']
    },
    description:String
});
module.exports=mongoose.model('Status',statusSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const studentSchema=new schema({
    name:String,
    isGroupLeader:Boolean,
    face_biometric_data:[Number],
    courses :[{
        type: schema.Types.ObjectId,
        ref:'Course'
    }],
    account:{
        type: schema.Types.ObjectId,
        ref:'Account'
    }
});
module.exports=mongoose.model('Student',studentSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const submissionSchema = new schema({
  student: { type: schema.Types.ObjectId, ref: "Student" },
  assignment: { type: schema.Types.ObjectId, ref: "Assignment" },
  document_id: String,
  remarks: {type: schema.Types.ObjectId, ref: "Remarks"},
  submitted_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Submission", submissionSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const teacherSchema=new schema({
    name:String,
    courses:[{
        type: schema.Types.ObjectId,
        ref:'Course'
    }],
    account:{
        type: schema.Types.ObjectId,
        ref:'Account'
    }
});
module.exports=mongoose.model('Teacher',teacherSchema);
const mongoose = require('mongoose');
const schema=mongoose.Schema;

const vivaSchema=new schema({
    status:{
        type:String,
        enum:['scheduled','taken']
    },
    remarks:{
        type: schema.Types.ObjectId,
        ref:'Remarks'
    },
    dateCreated:{
        type:Date
    },
    vivaDate:{
        type:Date
    }
});
module.exports=mongoose.model('Viva',vivaSchema);
const mongoose = require("mongoose");
const schema = mongoose.Schema;

const voteSchema = new schema({
  poll: { type: schema.Types.ObjectId, ref: "Poll", required: true },
  student: { type: schema.Types.ObjectId, ref: "Student", required: true },
  option: { type: String, required: true },
  created_at: { type: Date, default: Date.now },
  updated_at: { type: Date, default: Date.now },
});

module.exports = mongoose.model("Vote", voteSchema);

const Course = require("../models/Course");
const Announcement = require("../models/Announcement");

const findCourseById = (courseId) => Course.findById(courseId);
const findCourseByIdWithAnnouncements = (courseId) => Course.findById(courseId).populate('announcements');
const createAnnouncement = (announcementData) => Announcement.create(announcementData);
const deleteAnnouncementById = (announcementId) => Announcement.findByIdAndDelete(announcementId);
const updateAnnouncementById = (announcementId, updateData) => Announcement.findByIdAndUpdate(announcementId, updateData, { new: true });
const findAnnouncementById = (announcementId) => Announcement.findById(announcementId);

module.exports = {
    findCourseById,
    findCourseByIdWithAnnouncements,
    createAnnouncement,
    deleteAnnouncementById,
    updateAnnouncementById,
    findAnnouncementById
};

const Assignment = require("../models/Assisgnment");

const createAssignment = async (assignmentData) => {
  const assignment = new Assignment(assignmentData);
  return await assignment.save();
};

const getAssignments = async (courseId) => {
  return await Assignment.find({ course: courseId });
};

const getAssignmentById = async (assignmentId) => {
  return await Assignment.findById(assignmentId);
};

const getAssignmentByTitleAndCourse = async (title, courseId) => {
  return await Assignment.findOne({
    title,
    course: courseId,
  });
};

const deleteAssignmentById = async (assignmentId) => {
  return await Assignment.findByIdAndDelete(assignmentId);
};

const saveAssignment = async (assignment) => {
  return await assignment.save();
};

module.exports = {
  createAssignment,
  getAssignments,
  getAssignmentById,
  getAssignmentByTitleAndCourse,
  deleteAssignmentById,
  saveAssignment,
};

const Account = require('../models/Account');
const Student = require('../models/Student');
const Teacher = require('../models/Teacher');
const Otp = require('../models/OtpModel');

const findAccountByEmail = (email) => Account.findOne({ email });
const findStudentByAccountId = (accountId) => Student.findOne({ account: accountId });
const findTeacherByAccountId = (accountId) => Teacher.findOne({ account: accountId });
const createAccount = (email, password) => Account.create({ email, password });
const createStudent = (name, accountId) => Student.create({ name, account: accountId, isGroupLeader: false });
const createTeacher = (name, accountId) => Teacher.create({ name, account: accountId });
const findStudentById = (studentId) => Student.findById(studentId).populate('account');
const findTeacherById = (teacherId) => Teacher.findById(teacherId).populate('account');
const findAccountById = (accountId) => Account.findById(accountId).populate('otp');
const findAccountByIdForNotifications = (accountId) => Account.findById(accountId).populate('notifications');
const updateAccountEmailVerification = (id, isVerified) => Account.findByIdAndUpdate(id, { email_verified: isVerified });
const getExistingOtp = (email) => {
    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
    return Otp.findOne({ email, createdAt: { $gt: thirtyMinutesAgo } });
};
const createNewOtp = (otp) => Otp.create({  otp });
const deleteOtp = (id) => Otp.findByIdAndDelete(id);
const setAccountOtpToNull = (accountId) => Account.findByIdAndUpdate(accountId, { otp: null });

module.exports = {
    findAccountByEmail,
    findStudentByAccountId,
    findTeacherByAccountId,
    createAccount,
    createStudent,
    createTeacher,
    findStudentById,
    findTeacherById,
    findAccountById,
    updateAccountEmailVerification,
    getExistingOtp,
    createNewOtp,
    deleteOtp,
    setAccountOtpToNull,
    findAccountByIdForNotifications
};

const Student = require("../models/Student");
const Teacher = require("../models/Teacher");
const Course = require("../models/Course");
const Viva = require("../models/Viva");
const Project = require("../models/Project");

const findTeacherById = (id) => Teacher.findById(id);
const findStudentById = (id) => Student.findById(id);
const findCourseByName = (name) => Course.findOne({ courseName: name });
const findAllCourses = () => Course.find({});
const createCourse = (courseData) => Course.create(courseData);
const findCourseBycourseCode = (courseCode) =>
  Course.findOne({ courseCode });
const findCourseById = (id) => Course.findById(id);
const updateCourseName = (courseId, courseName) =>
  Course.findByIdAndUpdate(courseId, { courseName: courseName });
const deleteVivaById = (id) => Viva.findByIdAndDelete(id);
const deleteProjectById = (id) => Project.findByIdAndDelete(id);
const removeCourseFromTeacher = (teacherId, courseId) =>
  Teacher.findByIdAndUpdate(teacherId, { $pull: { courses: courseId } });
const deleteCourseById = (id) => Course.findByIdAndDelete(id);
const removeStudentFromCourse = (courseId, studentId) =>
  Course.findByIdAndUpdate(courseId, { $pull: { students: studentId } });
const removeCourseFromStudent = (studentId, courseId) =>
  Student.findByIdAndUpdate(studentId, { $pull: { courses: courseId } });
const getStudentFromCourse = (courseId, studentId) =>
  Student.findOne({ _id: studentId, courses: courseId });
const getCourseById = (courseId) => Course.findById(courseId);


module.exports = {
  findTeacherById,
  findStudentById,
  findCourseByName,
  findAllCourses,
  createCourse,
  findCourseBycourseCode,
  findCourseById,
  updateCourseName,
  deleteVivaById,
  deleteProjectById,
  removeCourseFromTeacher,
  deleteCourseById,
  removeStudentFromCourse,
  removeCourseFromStudent,
  getStudentFromCourse,
  getCourseById,
};

const Lecture = require("../models/Lecture");

const createLecture = async (lectureData) => {
  const lecture = new Lecture(lectureData);
  return await lecture.save();
};

const getLectures = async (courseId) => {
  return await Lecture.find({ course: courseId });
};

const getLectureById = async (lectureId) => {
  return await Lecture.findById(lectureId);
};

const getLectureByTitleAndCourse = async (title, courseId) => {
  return await Lecture.findOne({
    title,
    course: courseId,
  });
};

const deleteLectureById = async (lectureId) => {
  return await Lecture.findByIdAndDelete(lectureId);
};

const saveLecture = async (lecture) => {
  return await lecture.save();
};

module.exports = {
  createLecture,
  getLectures,
  getLectureById,
  getLectureByTitleAndCourse,
  deleteLectureById,
  saveLecture,
};

const Notification = require("../models/Notification");

const createNotification = (notificationData) =>
  Notification.create(notificationData);

const findNotificationById = (notificationId) =>
  Notification.findById(notificationId);

module.exports = {
  createNotification,
  findNotificationById,
};
const Poll = require("../models/Poll");

const createPoll = async (pollData) => {
  const poll = new Poll(pollData);
  return await poll.save();
};

const getPolls = async (courseId) => {
  return await Poll.find({ course: courseId });
};

const getPollById = async (pollId) => {
  return await Poll.findById(pollId).populate("votes");
};

const deletePollById = async (pollId) => {
  return await Poll.findByIdAndDelete(pollId);
};

const savePoll = async (poll) => {
  return await poll.save();
};


module.exports = {
  createPoll,
  getPolls,
  getPollById,
  deletePollById,
  savePoll,
};

const AIProctoringReport = require("../models/ProctoringReport");
const ProctoringImage = require("../models/ProtoringImage");
const AppError = require("../utilities/AppError");

const createProctoringReport = async (reportData) => {
  return await AIProctoringReport.create(reportData);
};

const getProctoringReportById = async(id) => {
  return await AIProctoringReport.findById(id);
}

// Function to create a proctoring image and update the report
const updateProctoringReport = async (
  reportId,
  { imageId, cheatingIndicators }
) => {
  const proctoringImage = await ProctoringImage.create({
    image_id: imageId,
    cheating_indicators: cheatingIndicators,
  });

  const report = await AIProctoringReport.findById(reportId);
  if (!report) {
    throw new AppError("Proctoring report not found", 404);
  }

  // Add the new image to the report
  report.images.push(proctoringImage._id);

  // Update the cheating indicators in the report
  report.cheating_indicators.mobile_phone += cheatingIndicators.mobile_phone
    ? 1
    : 0;
  report.cheating_indicators.extra_person += cheatingIndicators.extra_person
    ? 1
    : 0;
  report.cheating_indicators.mouth_open += cheatingIndicators.mouth_open
    ? 1
    : 0;
  report.cheating_indicators.no_person += cheatingIndicators.no_person ? 1 : 0;

  report.cheating_indicators.eye_left_right += cheatingIndicators.eye_gaze == "center" ? 0 :1; 
  report.updated_at = new Date();

  await report.save();

  return report;
};

module.exports = {
  createProctoringReport,
  updateProctoringReport,
  getProctoringReportById
};

const ProctoringImage = require('../models/ProtoringImage');

const createProtoringImage = (image_id , cheaing_indicators) => ProctoringImage.create({image_id , cheaing_indicators});

module.exports = {
    createProtoringImage
};

const Student = require("../models/Student");
const Course = require("../models/Course");
const Project = require("../models/Project");
const Status = require("../models/Status");

const findStudentById = (id) => Student.findById(id);
const findCourseById = (id) => Course.findById(id);
const findProjectByName = (name) => Project.findOne({ name });
const findProjectByLeaderAndCourse = (student, courseInstance) => Project.findOne({
    projectLeader: student,
    course: courseInstance
});
const createProject = (projectData) => Project.create(projectData);
const createStatus = (statusData) => Status.create(statusData);
const findProjectById = (id) => Project.findById(id).populate("members").populate("projectLeader");
const updateProjectById = (id, updateData) => Project.findByIdAndUpdate(id, updateData, { new: true });
const findProjectByIdAndCourse = (projectId, courseId) => Project.findOne({
    _id: projectId,
    course: courseId
});

const findProjectByNameAndCourse = (name, courseId) => Project.findOne({
    name,
    course: courseId
});

const findProjectByMemberAndCourse = (member, courseInstance) => Project.findOne({
    members: member._id,
    course: courseInstance
});
const deleteProjectById = (id) => Project.findByIdAndDelete(id);

module.exports = {
    findStudentById,
    findCourseById,
    findProjectByName,
    findProjectByLeaderAndCourse,
    createProject,
    createStatus,
    findProjectById,
    updateProjectById,
    findProjectByIdAndCourse,
    findProjectByNameAndCourse,
    findProjectByMemberAndCourse,
    deleteProjectById
};

const Question = require('../models/Question');

// Find a question by its content
const findQuestionByContent = async (content) => {
    return await Question.findOne({ content });
};

// Create a new question
const createQuestion = async (questionData) => {
    return await Question.create(questionData);
};

module.exports = {
    findQuestionByContent,
    createQuestion,
};

const Quiz = require("../models/Quiz");

// Create a new quiz
const createQuiz = async (quizData) => {
  return await Quiz.create(quizData);
};

const getQuizById = async (quizId) => {
  return await Quiz.findById(quizId);
};

// Find a quiz by its ID
const findQuizById = async (quizId) => {
  return await Quiz.findById(quizId).populate("questions");
};

const getQuizzesByCourse = async (courseId) => {
  return await Quiz.find({ course: courseId });
};

// Update a quiz by its ID
const updateQuizById = async (quizId, updateData) => {
  return await Quiz.findByIdAndUpdate(quizId, updateData, { new: true });
};

// Delete a quiz by its ID
const deleteQuizById = async (quizId) => {
  return await Quiz.findByIdAndDelete(quizId);
};

module.exports = {
  createQuiz,
  findQuizById,
  updateQuizById,
  deleteQuizById,
  getQuizById,
  getQuizzesByCourse,
};

const QuizSubmission = require('../models/QuizSubmission');

const createSubmission = async (submissionData) => {
    return await QuizSubmission.create(submissionData);
};

const findSubmission = async (quizId, studentId) => {
    return await QuizSubmission.findOne({ quiz: quizId, student: studentId });
};

const findSubmissionById= async (submissionId)=>{
    return await QuizSubmission.findById(submissionId);
}
module.exports = {
    createSubmission,
    findSubmission,
    findSubmissionById
};

const Project = require('../models/Project');
const Remark = require('../models/Remarks');
const Viva = require('../models/Viva');

const findProjectByIdAndCourseId = (projectId, courseId) => Project.findOne({ _id: projectId, course: courseId }).populate('viva');
const createRemark = (remarkData) => Remark.create(remarkData);
const saveProject = (project) => project.save();
const findRemarkById = (remarkId) => Remark.findById(remarkId);
const updateRemark = (remarkId, updateData) => Remark.findByIdAndUpdate(remarkId, updateData, { new: true });
const saveViva = (viva) => viva.save();

module.exports = {
    findProjectByIdAndCourseId ,
    createRemark,
    saveProject,
    findRemarkById,
    updateRemark,
    saveViva
};

const Status = require("../models/Status");

const createStatus = (statusData) => Status.create(statusData);
const findStatusById = (id) => Status.findById(id);
const updateStatusById = (id, updateData) => Status.findByIdAndUpdate(id, updateData, { new: true });
// Delete a status by ID
const deleteStatus = (id) => Status.findByIdAndDelete(id);

module.exports = {
    createStatus,
    findStatusById,
    updateStatusById,
    deleteStatus
};

const Submission = require("../models/Submission");

const createSubmission = async (submissionData) => {
  const submission = new Submission(submissionData);
  return await submission.save();
};

const getSubmissionsByAssignmentId = async (assignmentId) => {
  return await Submission.find({ assignment: assignmentId }).populate(
    "remarks"
  );
};

const getSubmissionById = async (submissionId) => {
  return await Submission.findById(submissionId).populate("remarks");
};

const deleteSubmissionsByAssignmentId = async (assignmentId) => {
  return await Submission.deleteMany({ assignment: assignmentId });
};

const saveSubmission = async (submission) => {
  return await submission.save();
};

const getSubmissionByAssignmentAndStudent = async (assignmentId, studentId) => {
  return await Submission.findOne({ assignment: assignmentId, student: studentId });
};

const deleteSubmissionById = async (submissionId) => {
  return await Submission.findByIdAndDelete(submissionId);
}

module.exports = {
  createSubmission,
  getSubmissionsByAssignmentId,
  getSubmissionById,
  deleteSubmissionsByAssignmentId,
  saveSubmission,
  getSubmissionByAssignmentAndStudent,
  deleteSubmissionById,

};

const Project = require('../models/Project');
const Viva = require('../models/Viva');
const Course = require('../models/Course');

const findProjectById = (projectId) => Project.findById(projectId).populate('status');
const findVivaByProjectId = (projectId) => Viva.findOne({ project: projectId });
const findCourseById = (courseId) => Course.findById(courseId).populate('vivas');
const createViva = (vivaData) => Viva.create(vivaData);
const saveProject = (project) => project.save();
const saveCourse = (getCourse) => getCourse.save();
const findVivaById = (vivaId) => Viva.findById(vivaId).populate('remarks');
const updateViva = (vivaId, updateData) => Viva.findByIdAndUpdate(vivaId, updateData);
const deleteVivaById = (vivaId) => Viva.findByIdAndDelete(vivaId);

module.exports = {
    findProjectById,
    findVivaByProjectId,
    findCourseById,
    createViva,
    saveProject,
    saveCourse,
    findVivaById,
    updateViva,
    deleteVivaById
};

const Vote = require("../models/Vote");

const createVote = async (voteData) => {
  const vote = new Vote(voteData);
  return await vote.save();
};

const getVoteByPollAndStudent = async (pollId, studentId) => {
  return await Vote.findOne({ poll: pollId, student: studentId });
};

const updateVote = async (voteId, option) => {
  return await Vote.findByIdAndUpdate(
    voteId,
    { option, updated_at: Date.now() },
    { new: true }
  );
};

const deleteVoteById = async (voteId) => {
  return await Vote.findByIdAndDelete(voteId);
};

const getVotesByPollId = async (pollId) => {
  return await Vote.find({ poll: pollId });
};

const saveVote = async (vote) => {
  return await vote.save();
};

module.exports = {
  createVote,
  getVoteByPollAndStudent,
  updateVote,
  deleteVoteById,
  getVotesByPollId,
  saveVote,
};

const express = require("express");
const router = express.Router();

// Import middleware functions for authentication and authorization.
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  isTeacher,
  isCourseCreator,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");

// Import middleware for announcement data validation.
const { validateAnnouncement } = require("../middlewares/schemaValidator");

// Import the announcement controller for handling announcement-related logic.
const announcementController = require("../controllers/announcementController");

// Route for getting all announcements for a course and creating new announcements.
router
  .route("/:courseId")
  .get(
    isLogin,
    isEmailVerified,
    isCourseCreatorOrCourseStudent, // Only logged-in course creators or students can view announcements.
    announcementController.getAllCourseAnnouncements
  )
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator, // Only logged-in teachers who are course creators can create announcements.
    validateAnnouncement, // Validate announcement data before processing.
    announcementController.sendCourseAnnouncement
  );

// Route for deleting and updating a specific announcement.
router
  .route("/:courseId/announcement/:announcementId")
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator, // Only logged-in teachers who are course creators can delete announcements.
    announcementController.deleteAnnouncement
  )
  .patch(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator, // Only logged-in teachers who are course creators can update announcements.
    validateAnnouncement, // Validate announcement data before processing.
    announcementController.updateAnnouncement
  );

module.exports = router;

const express = require("express");
const router = express.Router();

// Controller for handling assignment logic
const assignmentController = require("../controllers/assignmentController");

// Middleware for handling file uploads (using multer)
const { uploadAssignment } = require("../middlewares/multer/uploadAssignment");

// Middleware for authentication and authorization
const { isCourseCreator, isTeacher, isCourseCreatorOrCourseStudent } = require("../middlewares/authorization");
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

// Middleware for assignment data validation (assuming it exists)
const { validateAssignment } = require("../middlewares/schemaValidator");

// Define routes for assignment operations

// Get all assignments for a course (Teacher & Course Creator only)
router.get(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  assignmentController.getAssignments
);

// Create a new assignment (Teacher & Course Creator only)
router.post(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  uploadAssignment.single("assignment_document"), // Handle file upload
  validateAssignment, // Validate assignment data
  assignmentController.createAssignment
);

// Download an assignment document ( Course students or creator only)
router.get(
  "/:courseId/assignment/:assignmentId/download",
  isLogin,
  isEmailVerified,
  isCourseCreatorOrCourseStudent,
  assignmentController.downloadAssignment
);

// Get a specific assignment (Logged-in users only)
router.get(
  "/:courseId/assignment/:assignmentId",
  isLogin,
  isEmailVerified,
  assignmentController.getAssignment
);

// Update an existing assignment (Teacher & Course Creator only)
router.put(
  "/:courseId/assignment/:assignmentId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  uploadAssignment.single("assignment_document"), // Handle file upload for updates
  validateAssignment, // Validate updated assignment data
  assignmentController.updateAssignment
);

// Delete an assignment (Teacher & Course Creator only)
router.delete(
  "/:courseId/assignment/:assignmentId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  assignmentController.deleteAssignment
);

module.exports = router;

const express = require("express");
const router = express.Router();

// Controllers for handling authentication and user data
const authController = require("../controllers/authController");

// Middleware for request body validation
const {
  validateRegister,
  validateLogin,
  validateUpdatePassword,
  validateUpdateName,
  validateOtp,
} = require("../middlewares/schemaValidator");

// Middleware for authentication and authorization
const { isLogin } = require("../middlewares/isLogin");
const { isStudent, isTeacher } = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

// Middleware for handling file uploads (using multer)
const { uploadProfile } = require("../middlewares/multer/uploadProfile");
const { uploadFaceBiometricData } = require("../middlewares/multer/uploadFace");

// --- Public Routes ---

// Register a new student
router.post("/register", validateRegister, authController.registerStudent);

// Login an existing student
router.post("/login", validateLogin, authController.loginStudent);

// Register a new teacher
router.post(
  "/teacher/register",
  validateRegister,
  authController.registerTeacher
);

// Login an existing teacher
router.post("/teacher/login", validateLogin, authController.loginTeacher);

// --- Protected Routes (require authentication) ---

// Generate OTP (One-Time Password)
router.post("/generate-otp", isLogin, authController.generateOtp);

// Verify OTP
router.post("/verify-otp", isLogin, validateOtp, authController.verifyOtp);

// --- Student Specific Routes (require authentication and student role) ---

// Update student password
router.patch(
  "/student/update-password",
  isLogin,
  isEmailVerified,
  isStudent,
  validateUpdatePassword,
  authController.updateStudentPassword
);

// Update student name
router.patch(
  "/student/update-name",
  isLogin,
  isEmailVerified,
  isStudent,
  validateUpdateName,
  authController.updateStudentName
);

// Upload student profile image
router.post(
  "/student/upload-image",
  isLogin,
  isEmailVerified,
  isStudent,
  uploadProfile.single("profileImage"),
  authController.uploadStudentImage
);

// Get student information (accessible by anyone)
router.get(
  "/student/:id",
  isLogin,
  isEmailVerified,
  authController.getStudentInfo
);

// Register student's face for facial recognition
router.post(
  "/student/register-face",
  isLogin,
  isEmailVerified,
  isStudent,
  uploadFaceBiometricData.single("face_image"),
  authController.registerStudentFace
);

// Verify student's face using facial recognition
router.post(
  "/student/verify-face",
  uploadFaceBiometricData.single("face_image"), // Handle face image upload
  isLogin,
  isEmailVerified,
  isStudent,
  authController.verifyStudentFace
);

// --- Teacher Specific Routes (require authentication and teacher role) ---

// Update teacher password
router.patch(
  "/teacher/update-password",
  isLogin,
  isEmailVerified,
  isTeacher,
  validateUpdatePassword,
  authController.updateTeacherPassword
);

// Update teacher name
router.patch(
  "/teacher/update-name",
  isLogin,
  isEmailVerified,
  isTeacher,
  validateUpdateName,
  authController.updateTeacherName
);

// Upload teacher profile image
router.post(
  "/teacher/upload-image",
  isLogin,
  isEmailVerified,
  isTeacher,
  uploadProfile.single("profileImage"),
  authController.uploadTeacherImage
);

// Get teacher information (accessible by anyone)
router.get(
  "/teacher/:id",
  isLogin,
  isEmailVerified,
  authController.getTeacherInfo
);

module.exports = router;

const express = require("express");
const router = express.Router();

// Controller for handling course-related logic
const courseController = require("../controllers/courseController");

// Middleware for authentication and authorization
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  isTeacher,
  isStudent,
  isCourseCreator,
  isCourseStudent,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");

// Middleware for data validation
const {
  validateCourse,
  validateDate,
  validateAddRemoveStudent,
} = require("../middlewares/schemaValidator");

// --- Public Routes ---

// Get all courses (accessible by anyone)
router.get(
  "/getAll",
  isLogin,
  isEmailVerified,
  courseController.sendAllCourses
);

// --- Protected Routes (require authentication) ---

// Create a new course (Teacher only)
router.post(
  "/create",
  isLogin,
  isEmailVerified,
  isTeacher,
  validateCourse, // Validate course data
  courseController.createCourse
);

// Search for a student (Teacher only)
router.get(
  "/search-student",
  isLogin,
  isEmailVerified,
  isTeacher,
  courseController.searchStudent
);

// Join a course using a course code (Student only)
router.post(
  "/join",
  isLogin,
  isEmailVerified,
  isStudent,
  courseController.joinCourse
);

// --- Course Specific Routes (require authentication) ---

// Get a specific course
// (Accessible by Course Creator, Course Teacher and Course Student)
router.get(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isCourseCreatorOrCourseStudent,
  courseController.sendCourse
);

// Update a course's name (Course Creator only)
router.put(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  courseController.updateCourseName
);

// Update a course's details (Course Creator only)
router.patch(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  validateCourse, // Validate course data
  courseController.updateCourse
);

// Delete a course (Course Creator only)
router.delete(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  courseController.deleteCourse
);

// Leave a course (Student only)
router.put(
  "/:courseId/leave",
  isLogin,
  isEmailVerified,
  isStudent,
  isCourseStudent, // Ensure the student is enrolled in the course
  courseController.leaveCourse
);

// Regenerate the course code (Course Creator only)
router.put(
  "/:courseId/regenerate-course-code",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  courseController.regenerateCourseCode
);

// Add a student to a course (Course Creator only)
router.put(
  "/:courseId/add",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  validateAddRemoveStudent, // Validate student data
  courseController.addStudentToCourse
);

// Remove a student from a course (Course Creator only)
router.put(
  "/:courseId/remove",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  validateAddRemoveStudent, // Validate student data
  courseController.removeStudentFromCourse
);

// Update viva schedule for a course (Course Creator only)
router.put(
  "/updateViva/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  validateDate,
  courseController.updateVivaSchedule
);

// Update project schedule for a course (Course Creator only)
router.put(
  "/updateProject/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  validateDate,
  courseController.updateProjectSchedule
);

module.exports = router;

// ./routes/index.js

const express = require('express');
const router = express.Router();

const courseRoutes = require('./courseRoutes');
const projectRoutes = require('./projectRoutes');
const remarkRoutes = require('./remarkRoutes');
const statusRoutes = require('./statusRoutes');
const vivaRoutes = require('./vivaRoutes');
const announcementRoutes = require('./announcementRoutes');
const authRoutes = require('./authRoutes');
const proctoringRoutes = require('./proctoringRoutes');
const quizRoutes = require('./quizRoutes');
const assignmentRoutes = require('./assignmentRoutes');
const submissionRoutes = require('./submissionRoutes');
const lectureRoutes = require('./lectureRoutes');
const pollRoutes = require('./pollRoutes');
const notificationRoutes = require('./notificationRoutes');

router.use('/auth', authRoutes);
router.use('/course', courseRoutes);
router.use('/project', projectRoutes);
router.use('/remarks', remarkRoutes);
router.use('/status', statusRoutes);
router.use('/viva', vivaRoutes);
router.use('/announcements', announcementRoutes);
router.use('/ai-proctoring', proctoringRoutes);
router.use('/quiz', quizRoutes);
router.use('/assignments', assignmentRoutes);
router.use('/submissions', submissionRoutes);
router.use('/lectures', lectureRoutes);
router.use('/polls', pollRoutes);
router.use('/notifications', notificationRoutes);

module.exports = router; 
const express = require("express");
const router = express.Router();

// Controller for handling lecture-related logic
const lectureController = require("../controllers/lectureController");

// Middleware for authentication and authorization
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  isTeacher,
  isCourseCreator,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");

// Middleware for handling lecture video uploads (using multer)
const { uploadLecture } = require("../middlewares/multer/uploadLecture");

// --- Lecture Routes ---

// Get all lectures for a course
// (Accessible by Course Creator, Course Teacher and Course Student)
router.get(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isCourseCreatorOrCourseStudent,
  lectureController.getLectures
);

// Create a new lecture for a course (Teacher and Course Creator only)
router.post(
  "/:courseId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  uploadLecture.single("lecture_video"), // Handle lecture video upload
  lectureController.createLecture
);

// Get a specific lecture
// (Accessible by Course Creator, Course Teacher and Course Student)
router.get(
  "/:courseId/lecture/:lectureId",
  isLogin,
  isEmailVerified,
  isCourseCreatorOrCourseStudent,
  lectureController.getLecture
);

// Update a specific lecture (Teacher and Course Creator only)
router.put(
  "/:courseId/lecture/:lectureId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  uploadLecture.single("lecture_video"), // Handle lecture video upload for updates
  lectureController.updateLecture
);

// Delete a specific lecture (Teacher and Course Creator only)
router.delete(
  "/:courseId/lecture/:lectureId",
  isLogin,
  isEmailVerified,
  isTeacher,
  isCourseCreator,
  lectureController.deleteLecture
);

// Download a lecture video
// (Accessible by Course Creator, Course Teacher and Course Student)
router.get(
  "/:courseId/lecture/:lectureId/download",
  isLogin,
  isEmailVerified,
  isCourseCreatorOrCourseStudent,
  lectureController.downloadLecture
);

module.exports = router;

const express = require("express");
const router = express.Router();

// Controller for handling notification-related logic
const notificationController = require("../controllers/notificationController");

// Middleware for user authentication
const { isLogin } = require("../middlewares/isLogin");

// --- Notification Routes ---

// Mark a notification as read (requires authentication)
router.put(
  "/mark-as-read/:notificationId", // Route parameter for the notification ID
  isLogin,                          // Ensure the user is logged in
  notificationController.markNotificationAsRead // Controller function to handle marking as read
);

// Get all notifications for the logged-in user
router.get(
  "/get-notifications",      
  isLogin,                          // Ensure the user is logged in
  notificationController.getAllNotifications // Controller function to retrieve notifications
);

module.exports = router;
const express = require("express");
const router = express.Router();
const pollController = require("../controllers/pollController");
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const { isTeacher, isCourseCreator, isStudent, isCourseStudent, isCourseCreatorOrCourseStudent } = require("../middlewares/authorization");
const { validatePoll } = require("../middlewares/schemaValidator");
router
  .route("/:courseId")
  .get(isLogin, isEmailVerified,isCourseCreatorOrCourseStudent, pollController.getPolls)
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validatePoll,
    pollController.createPoll
  );

router
  .route("/:courseId/poll/:pollId")
  .get(isLogin, isEmailVerified,isCourseCreatorOrCourseStudent, pollController.getPoll)
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    pollController.deletePoll
  );

router
  .route("/:courseId/poll/:pollId/vote")
  .post(isLogin, isEmailVerified,isStudent,isCourseStudent, pollController.votePoll);

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const {
  isStudent,
  isTeacher,
  isCourseCreator,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  uploadProctoringImage,
} = require("../middlewares/multer/uploadProctoringImage");
const proctoringController = require("../controllers/proctoringController");
router
  .route("/:courseId/:quizId/analyze-image")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    uploadProctoringImage.single("proctor_image"),
    proctoringController.analyzeImage
  );

router
  .route("/:courseId/:quizId/generate-report/:studentId")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    proctoringController.generateReport
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { validateProject } = require("../middlewares/schemaValidator");
const {
  isStudent,
  isCourseStudent,
  isProjectCreator,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const projectController = require("../controllers/projectController");

router
  .route("/create")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    validateProject,
    projectController.createProject
  );

router
  .route("/:courseId/:projectId/add-member")
  .put(
    isLogin,
    isEmailVerified,
    isCourseStudent,
    isProjectCreator,
    projectController.addMember
  );

router
  .route("/:courseId/:projectId/:memberId/remove-member")
  .put(
    isLogin,
    isEmailVerified,
    isCourseStudent,
    isProjectCreator,
    projectController.removeMember
  );

router
  .route("/:courseId/generate-project-suggestions")
  .get(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    projectController.generateProjectSuggestions
  );

router
  .route("/:courseId/:projectId")
  .get(
    isLogin,
    isEmailVerified,
    isCourseCreatorOrCourseStudent,
    projectController.sendProject
  )
  .put(
    isLogin,
    isEmailVerified,
    isStudent,
    isProjectCreator,
    validateProject,
    projectController.updateProject
  )
  .delete(
    isLogin,
    isEmailVerified,
    isCourseCreatorOrCourseStudent,
    projectController.deleteProject
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const quizController = require("../controllers/quizController");
const { isLogin } = require("../middlewares/isLogin");
const {
  isTeacher,
  isCourseCreator,
  isCourseStudent,
  isStudent,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const {
  validateQuiz,
  validateUpdateQuizScore,
  validateUpdateSubmissionFlag,
  validateQuizGenerationQuery,
  validateQuizGenerationBody,
} = require("../middlewares/schemaValidator");

router
  .route("/:courseId/create")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateQuiz,
    quizController.createQuiz
  );

/**
 * @route GET /api/quizzes/:courseId/generate
 * @description Generate quiz questions by topic
 * @access Private (Teachers, Course Creators)
 * @param {string} topic (query parameter) - The topic for question generation.
 * @param {number} [numberOfQuestions] (query parameter) - Number of questions (default: 5).
 * @param {string} [difficulty] (query parameter) - Difficulty level (easy, medium, hard, default: medium).
 */

router
  .route("/:courseId/generate")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateQuizGenerationQuery,
    quizController.generateQuizByTopic
  )
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateQuizGenerationBody,
    quizController.generateQuizByTopicOrContent
  );

router
  .route("/course/:courseId")
  .get(isLogin, isEmailVerified, quizController.getQuizzesByCourse);

router
  .route("/:courseId/:id/get")
  .get(
    isLogin,
    isEmailVerified,
    isCourseStudent,
    isCourseStudent,
    quizController.getQuizStudent
  );

router
  .route("/:courseId/:id/start")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    quizController.startQuiz
  );

router
  .route("/:courseId/:id/pdf")
  .post(isLogin, isEmailVerified, isTeacher, isCourseCreator, quizController.generatePDFAllStudents);

router
  .route("/:courseId/:id/pdf/:studentId")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    quizController.generatePDFStudent
  );

router
  .route("/:courseId/:id/submit")
  .post(isLogin, isEmailVerified, isStudent, quizController.submitQuiz);

router
  .route("/:courseId/:quizId/update-marks/:submissionId")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    validateUpdateQuizScore,
    quizController.updateSubmissionMarks
  );

router
  .route("/:courseId/:quizId/update-flag/:submissionId")
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    validateUpdateSubmissionFlag,
    quizController.updateSubmissionFlag
  );

router
  .route("/:courseId/:id")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    quizController.getQuiz
  )
  .patch(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateQuiz,
    quizController.updateQuiz
  )
  .delete(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    quizController.deleteQuiz
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const { validateRemark } = require("../middlewares/schemaValidator");
const {
  isTeacher,
  isCourseCreator,
  isStudent,
  isProjectGroupMember,
  isCourseCreatorOrCourseStudent,
} = require("../middlewares/authorization");
const remarkController = require("../controllers/remarkController");

router
  .route("/viva/:courseId/:projectId/add")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.addRemarkToViva
  );

router
  .route("/viva/:courseId/:projectId/:remarkId")
  .get(isLogin,isEmailVerified, isStudent, isProjectGroupMember, remarkController.sendRemark)
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.updateRemark
  );

// Add remark to a submission
router
  .route("/submission/:courseId/:submissionId/add")
  .post(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.addRemarkToSubmission
  );

// Get, update remark on a submission
router
  .route("/submission/:courseId/:submissionId/:remarkId")
  .get(isLogin, isStudent,isCourseCreatorOrCourseStudent, remarkController.readSubmissionRemark)
  .put(
    isLogin,
    isTeacher,
    isCourseCreator,
    validateRemark,
    remarkController.updateSubmissionRemark
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { validateStatus } = require("../middlewares/schemaValidator");
const { isTeacher, isCourseCreator, isCourseCreatorOrCourseStudent } = require("../middlewares/authorization");

const statusController = require("../controllers/statusController");
const { isEmailVerified } = require("../middlewares/isEmailVerified");

router
  .route("/:courseId/:projectId/add")
  .post(
    isLogin,
    isTeacher,
    isEmailVerified,
    isCourseCreator,
    validateStatus,
    statusController.addStatus
  );

router
  .route("/:courseId/:projectId/:statusId")
  .get(isLogin,isEmailVerified,isCourseCreatorOrCourseStudent, statusController.sendStatus)
  .put(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    validateStatus,
    statusController.updateStatus
  );

module.exports = router;

const express = require("express");
const router = express.Router();
const submissionController = require("../controllers/submissionController");
const { isLogin } = require("../middlewares/isLogin");
const {
  isStudent,
  isTeacher,
  isCourseCreator,
  isCourseStudent,
} = require("../middlewares/authorization");
const { validateSubmission } = require("../middlewares/schemaValidator");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const { uploadSubmission } = require("../middlewares/multer/uploadSubmission");

router
  .route("/:courseId/submission/:submissionId/download")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    submissionController.downloadSubmissionTeacher
  );

router
  .route("/:courseId/assignment/:assignmentId")
  .get(
    isLogin,
    isEmailVerified,
    isTeacher,
    isCourseCreator,
    submissionController.getSubmissions
  )
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    uploadSubmission.single("submision_document"),
    submissionController.createSubmission
  );

router
  .route("/assignment/:assignmentId/submissions/:submissionId/download")
  .get(
    isLogin,
    isEmailVerified,
    isStudent,
    submissionController.downloadSubmission
  );

router
  .route("/assignment/:assignmentId/submissions/:submissionId")
  .get(isLogin, isEmailVerified, isStudent, submissionController.getSubmission)
  .put(
    isLogin,
    isEmailVerified,
    isStudent,
    uploadSubmission.single("submision_document"),
    submissionController.updateSubmission
  )
  .delete(isLogin, isStudent, submissionController.deleteSubmission);

module.exports = router;

const express = require("express");
const router = express.Router();
const { isLogin } = require("../middlewares/isLogin");
const { validateViva } = require("../middlewares/schemaValidator");
const {
  isTeacher,
  isStudent,
  isCourseCreator,
  isProjectCreator,
  isCourseStudent,
} = require("../middlewares/authorization");
const { isEmailVerified } = require("../middlewares/isEmailVerified");
const vivaController = require("../controllers/vivaController");

router
  .route("/:courseId/:projectId/add")
  .post(
    isLogin,
    isEmailVerified,
    isStudent,
    isCourseStudent,
    isProjectCreator,
    vivaController.addViva
  );

router
  .route("/:courseId/getTodayVivas")
  .get(isLogin, isEmailVerified, vivaController.getTodaysViva);

router
  .route("/:courseId/getAllVivas")
  .get(isLogin, isEmailVerified, isCourseCreator, vivaController.getAllVivas);

// Parameters for generating viva questions
/**
 * Query Parameters:
 * - numberOfQuestions: The number of questions to generate (e.g., 5, 10).
 * - difficulty: The difficulty level of the questions (e.g., easy, medium, hard).
 * - questionType: The type of questions to generate. Options include:
 *   - general: Broad questions about the project.
 *   - technical: Questions about the technical aspects of the project.
 *   - conceptual: Questions on theoretical concepts applied in the project.
 *   - analytical: Questions requiring analysis of project aspects.
 *   - problem-solving: Scenarios requiring problem-solving related to the project.
 *   - design: Questions about design choices and system architecture.
 *   - implementation: Questions about the coding and implementation details.
 *   - testing: Questions related to testing methodologies and practices.
 *   - security: Questions about security measures and data protection.
 *   - ux: Questions related to user experience and interface design.
 *   - ethical: Questions about ethical and legal considerations.
 *   - project-management: Questions about project management techniques.
 *   - research: Questions about research methods and data gathering.
 *   - future-scope: Questions about future enhancements and scalability.
 */

router.route("/:courseId/:projectId/generate-viva-questions").get(
  isLogin,
  isEmailVerified,
  isTeacher, // Only allow teachers to access this route
  isCourseCreator, // Only allow course creator to access this route
  vivaController.generateVivaQuestions
);

router
  .route("/:courseId/:vivaId")
  .get(isLogin, vivaController.sendViva)
  .put(
    isLogin,
    isTeacher,
    isCourseCreator,
    validateViva,
    vivaController.updateViva
  );

module.exports = router;

const Joi = require("joi");

module.exports.addRemoveStudentSchema = Joi.object({
  studentId: Joi.string().required(),
});

const Joi= require('joi')

module.exports.announcementSchema = Joi.object(
    {
        title:Joi.string().required(),
        content:Joi.string().required()
    }
)
const Joi= require('joi')

module.exports.assignmentSchema = Joi.object(
    {
        title: Joi.string().required(),
        description: Joi.string().required(),
        deadline: Joi.date().required(),
    }
);
const Joi = require("joi");

module.exports.registerSchema = Joi.object({
  name: Joi.string().required(),
  email: Joi.string().required(),
  pass: Joi.string().required(),
});
module.exports.loginSchema = Joi.object({
  email: Joi.string().required(),
  pass: Joi.string().required(),
});

module.exports.updatePasswordSchema = Joi.object({
  currentPassword: Joi.string().required(),
  newPassword: Joi.string().required(),
});

module.exports.updateNameSchema = Joi.object({
  newName: Joi.string().required(),
});

module.exports.otpSchema = Joi.object({
  otp: Joi.string().required(),
});

const Joi= require('joi')

module.exports.courseSchema = Joi.object(
    {
        courseName: Joi.string().required(),
        description: Joi.string().required(),
        projectRequirements: Joi.string().required().default("Requirements Coming Soon"),
    }
)
const Joi= require('joi')

module.exports.dateSchema = Joi.object(
    {
        startDate: Joi.date().required(),
        endDate: Joi.date().required()
    }
)
const Joi = require("joi");

module.exports.pollSchema = Joi.object({
  title: Joi.string().required(), // Title is required and should be a string
  description: Joi.string().optional(), // Description is optional
  options: Joi.array()
    .items(
      Joi.string().min(1).max(100) // Options should be strings with a length between 1 and 100
    )
    .min(2)
    .max(3)
    .required()
    .messages({
      "array.min": "Options should have at least 2 elements.",
      "array.max": "Options should have at most 3 elements.",
    }),
  created_at: Joi.date().default(Date.now),
});

const Joi= require('joi')

module.exports.projectSchema = Joi.object(
    {
        name: Joi.string().required(),
        scope: Joi.string().required(),
        members:Joi.array().required().min(1).max(4),
        courseId:Joi.string().required()
    }
)
const Joi = require("joi");

// Schema for request body validation
const quizGenerationBodySchema = Joi.object({
  topic: Joi.string().required(),
  content: Joi.string().required(),
  numberOfQuestions: Joi.number().integer().min(1).max(20).optional(),
  difficulty: Joi.string().valid("easy", "medium", "hard").optional(),
});

// Schema for query parameters validation
const quizGenerationQuerySchema = Joi.object({
  topic: Joi.string().required(),
  numberOfQuestions: Joi.number().integer().min(1).max(20).optional(),
  difficulty: Joi.string().valid("easy", "medium", "hard").optional(),
});

module.exports = {
  quizGenerationBodySchema,
  quizGenerationQuerySchema,
};
const Joi = require('joi');

module.exports.quizSchema = Joi.object({
  title: Joi.string().required(),
  topic: Joi.string().required(),
  questions: Joi.array().items(
    Joi.object({
      content: Joi.string().required(),
      options: Joi.array().items(Joi.string().required()).min(2).required(),
      correct_option: Joi.string().required()
    })
  ).required(),
  number_of_questions: Joi.number().required(),
  deadline: Joi.date().required(),
  duration: Joi.number().required()
});

const Joi = require('joi');

const remarkSchema = Joi.object({
  overallPerformance: Joi.string()
    .valid('Bad', 'Poor', 'Fair', 'Good', 'Excellent')
    .required(),
  feedback: Joi.string().trim().required(),
  obtainedMarks: Joi.number().min(0).required(), 
  totalMarks: Joi.number().min(0).required(), 
});

module.exports = { remarkSchema };
const Joi= require('joi')

module.exports.reviewSchema = Joi.object({
    difficulty: Joi.number().integer().min(1).max(5).required(),
    relevence: Joi.number().integer().min(1).max(5).required(),
    clarity: Joi.number().integer().min(1).max(5).required(),
    conceptual: Joi.number().integer().min(1).max(5).required(),
    overallFeedback: Joi.number().integer().min(1).max(5).required()
});
const Joi = require('joi');

const statusSchema = Joi.object({
    status: Joi.string().valid('approved','unsatisfactory','disapproved').required(),
    description: Joi.string().required()
});

module.exports.statusSchema = statusSchema;
const Joi = require("joi");

const updateSubmissionFlagSchema = Joi.object({
    isFlagged: Joi.boolean().required(),
});

module.exports.updateSubmissionFlagSchema = updateSubmissionFlagSchema;
const Joi = require('joi');

const updateSubmissionMarksSchema = Joi.object({
    newScore: Joi.number().required(),
});

module.exports.updateSubmissionMarksSchema = updateSubmissionMarksSchema;
const Joi= require('joi')

module.exports.vivaSchema = Joi.object(
    {
        status: Joi.string().valid('taken','scheduled'),
        vivaDate:Joi.date()
    }
)
const announcementRepository = require("../repositories/announcementRepository");
const authRepository = require("../repositories/authRepository");
const notificationService = require("./notificationService");
const AppError = require("../utilities/AppError");

const sendCourseAnnouncement = async (
  courseId,
  announcementData,
  teacherId
) => {
  const course = await announcementRepository.findCourseById(courseId);
  if (!course) {
    throw new AppError("Course not found", 400);
  }
  const announcement = await announcementRepository.createAnnouncement({
    ...announcementData,
    course: courseId,
    teacher: teacherId,
  });
  course.announcements.push(announcement._id);
  await course.save();
  // TODO: Notify students of the new announcement
  for (const student of course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "New Announcement",
        content: `A new announcement has been made for ${course.courseName
}`,
        read: false,
      },
      student_account._id
    );
  }
  // Notify teacher
  const teacher = await authRepository.findTeacherById(teacherId);
  const teacherAccount = await authRepository.findAccountById(teacher.account);
  await notificationService.createNotification(
    {
      title: "New Announcement",
      content: `You made a new announcement has been made for ${course.courseName
}`,
      read: false,
    },
    teacherAccount._id
  );
  return {
    _id: announcement._id,
    title: announcement.title,
    message: announcement.content,
  };
};

const deleteAnnouncement = async (announcementId, teacherId) => {
  const announcement = await announcementRepository.findAnnouncementById(
    announcementId
  );
  if (!announcement) {
    throw new AppError("Announcement not found", 404);
  }
  await announcementRepository.deleteAnnouncementById(announcementId);

  // Notify student
  const course = await announcementRepository.findCourseById(announcement.course);
  for (const student of course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "Announcement Deleted",
        content: `An announcement has been deleted from ${course.courseName}`,
        read: false,
      },
      student_account._id
    );
  }

  // Notify teacher
  const teacher = await authRepository.findTeacherById(teacherId);
  const teacherAccount = await authRepository.findAccountById(teacher.account);
  await notificationService.createNotification(
    {
      title: "Announcement Deleted",
      content: `You deleted an announement`,
      read: false,
    },
    teacherAccount._id
  );
};

const updateAnnouncement = async (announcementId, updateData, teacherId) => {
  const announcement = await announcementRepository.findAnnouncementById(
    announcementId
  );

  if (!announcement) {
    throw new AppError("Announcement not found", 404);
  }
  await announcementRepository.updateAnnouncementById(
    announcementId,
    updateData
  );

  // Notify student
  const course = await announcementRepository.findCourseById(announcement.course);
  for (const student of course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "Announcement Updated",
        content: `An announcement has been updated in ${course.courseName}`,
        read: false,
      },
      student_account._id
    );
  }

  // Notify teacher
  const teacher = await authRepository.findTeacherById(teacherId);
  const teacherAccount = await authRepository.findAccountById(teacher.account);
  await notificationService.createNotification(
    {
      title: "Announcement Updated",
      content: `You updated an announcement`,
      read: false,
    },
    teacherAccount._id
  );
  return announcement;
};

const getAllCourseAnnouncements = async (courseId) => {
  const course = await announcementRepository.findCourseByIdWithAnnouncements(
    courseId
  );
  if (!course) {
    throw new AppError("Course not found", 400);
  }
  return course.announcements;
};

module.exports = {
  sendCourseAnnouncement,
  deleteAnnouncement,
  updateAnnouncement,
  getAllCourseAnnouncements,
};

const assignmentRepository = require("../repositories/assignmentRepository");
const courseRepository = require("../repositories/courseRepository");
const authRepository = require("../repositories/authRepository");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
const submissionRepository = require("../repositories/submissionRepository");
const path = require("path");
const moment = require("moment-timezone");
const notificationService = require("./notificationService");

const addAssignment = async (
  courseId,
  teacherId,
  title,
  description,
  deadline,
  document_id
) => {
  if (!title || !description || !deadline) {
    throw new Error("Title, description and deadline are required");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const isAssignmentExist =
    await assignmentRepository.getAssignmentByTitleAndCourse(title, courseId);
  if (isAssignmentExist) {
    throw new Error(
      "Assignment with the same title already exists in the same course"
    );
  }
  const formattedDate = moment
    .tz(deadline, "DD/MM/YYYY", "your_time_zone")
    .utc()
    .toDate();
  const assignmentData = {
    course: courseId,
    teacher: teacherId,
    title,
    description,
    deadline: formattedDate,
    document_id,
  };
  const assignment = await assignmentRepository.createAssignment(
    assignmentData
  );
  course.assignments.push(assignment._id);
  await course.save();
  
  // Notify students
  for (const student of course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "New Assignment",
        content: `A new assignment has been added to ${course.courseName}`,
        read: false,
      },
      student_account._id
    );
  }
  return assignment;
};

const getAssignmentsByCourse = async (courseId) => {
  return await assignmentRepository.getAssignments(courseId);
};

const getAssignment = async (courseId, assignmentId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (course.assignments.indexOf(assignmentId) === -1) {
    throw new Error("Assignment not found in the course");
  }
  return assignment;
};

const updateAssignment = async (
  courseId,
  assignmentId,
  title,
  description,
  deadline,
  document_id
) => {
  const assignment = await getAssignment(courseId, assignmentId);
  if (!courseId || !assignmentId) {
    throw new AppError("course id and assignment id must be in params");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new AppError("course not found");
  }
  if (course.assignments.indexOf(assignmentId) === -1) {
    throw new AppError("assignment not found in the course");
  }
  if (document_id) {
    deleteFileByPath(
      path.join(
        __dirname,
        "../",
        "uploads",
        "assignments",
        assignment.document_id
      )
    );
  }
  const formattedDate = moment
    .tz(deadline, "DD/MM/YYYY", "your_time_zone")
    .utc()
    .toDate();
  assignment.title = title || assignment.title;
  assignment.description = description || assignment.description;
  assignment.document_id = document_id || assignment.document_id;
  assignment.deadline = formattedDate;
  assignment.updated_at = Date.now();

  return await assignmentRepository.saveAssignment(assignment);
};

const deleteAssignment = async (courseId, assignmentId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }

  if (course.assignments.indexOf(assignmentId) === -1) {
    throw new Error("Assignment not found in the course");
  }
  if (assignment.document_id) {
    try {
      deleteFileByPath(
        path.join(
          __dirname,
          "../",
          "uploads",
          "assignments",
          assignment.document_id
        )
      );
    } catch (err) {
      console.log(err);
    }
  }
  // Delete associated submissions
  await submissionRepository.deleteSubmissionsByAssignmentId(assignmentId);

  // Delete the assignment
  await assignmentRepository.deleteAssignmentById(assignmentId);

  // Remove the assignment reference from the course
  course.assignments = course.assignments.filter(
    (id) => id.toString() !== assignmentId.toString()
  );
  await course.save();

  // Notify students
  for (const student of course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "Assignment Deleted",
        content: `An assignment has been deleted from ${course.courseName}`,
        read: false,
      },
      student_account._id
    );
  }
};

module.exports = {
  addAssignment,
  getAssignmentsByCourse,
  getAssignment,
  updateAssignment,
  deleteAssignment,
};

const authRepository = require("../repositories/authRepository");
const bcrypt = require("bcrypt");
const AppError = require("../utilities/AppError");
const generateToken = require("../utilities/GetToken");
const axios = require("axios");
const {
  verifyStudentEmail,
  verifyTeacherEmail,
} = require("../utilities/MailVerification");
const { deleteFile } = require("../utilities/removeFile");
const notificationService = require("../services/notificationService");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
require("dotenv").config();

const registerStudent = async (name, email, pass) => {
  if (!name || !email || !pass) {
    throw new AppError("Enter all the required fields", 400);
  }
  if (!verifyStudentEmail(email)) {
    throw new AppError("This Is Not A Student Email", 400);
  }
  const account = await authRepository.findAccountByEmail(email);
  if (account) {
    const studentExists = await authRepository.findStudentByAccountId(
      account._id
    );
    if (studentExists) {
      throw new AppError("Student Already Registered", 400);
    }
  }
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(pass, salt);
  const studentAccount = await authRepository.createAccount(
    email,
    hashedPassword
  );
  const student = await authRepository.createStudent(name, studentAccount._id);
  await notificationService.createNotification(
    {
      title: "Welcome to the Student Portal",
      content: "You have successfully registered as a student",
      read: false,
    },
    studentAccount._id
  );
  return {
    _id: student._id,
    name: student.name,
    email: studentAccount.email,
    password: studentAccount.password,
    token: generateToken(student._id),
  };
};

const loginStudent = async (email, pass) => {
  if (!verifyStudentEmail(email)) {
    throw new AppError("This Is Not A Student Email", 400);
  }
  const studentAccount = await authRepository.findAccountByEmail(email);
  if (!studentAccount) {
    throw new AppError("Student Account Not Found", 400);
  }
  const isMatch = await bcrypt.compare(pass, studentAccount.password);
  if (!isMatch) {
    throw new AppError("Wrong Email Or Password", 400);
  }
  const student = await authRepository.findStudentByAccountId(
    studentAccount._id
  );
  return {
    _id: student._id,
    name: student.name,
    email: studentAccount.email,
    token: generateToken(student._id),
  };
};

const registerTeacher = async (name, email, pass) => {
  if (!name || !email || !pass) {
    throw new AppError("Enter all the required fields", 400);
  }
  if (!verifyTeacherEmail(email)) {
    throw new AppError("This Is Not A Faculty Email", 400);
  }
  const account = await authRepository.findAccountByEmail(email);
  if (account) {
    const teacherExists = await authRepository.findTeacherByAccountId(
      account._id
    );
    if (teacherExists) {
      throw new AppError("Teacher Already Registered", 400);
    }
  }
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(pass, salt);
  const teacherAccount = await authRepository.createAccount(
    email,
    hashedPassword
  );
  const teacher = await authRepository.createTeacher(name, teacherAccount._id);
  await notificationService.createNotification(
    {
      title: "Welcome to the Faculty Portal",
      content: "You have successfully registered as a teacher",
      read: false,
    },
    teacherAccount._id
  );
  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacherAccount.email,
    password: teacherAccount.password,
    token: generateToken(teacher._id),
  };
};

const loginTeacher = async (email, pass) => {
  if (!verifyTeacherEmail(email)) {
    throw new AppError("This Is Not A Faculty Email", 400);
  }
  const teacherAccount = await authRepository.findAccountByEmail(email);
  if (!teacherAccount) {
    throw new AppError("Teacher Account Not Found", 400);
  }
  const isMatch = await bcrypt.compare(pass, teacherAccount.password);
  if (!isMatch) {
    throw new AppError("Wrong Email Or Password", 400);
  }
  const teacher = await authRepository.findTeacherByAccountId(
    teacherAccount._id
  );
  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacherAccount.email,
    token: generateToken(teacher._id),
  };
};

const updateStudentPassword = async (
  studentId,
  currentPassword,
  newPassword
) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }

  const studentAccount = await authRepository.findAccountById(student.account);
  const isMatch = await bcrypt.compare(
    currentPassword,
    studentAccount.password
  );
  if (!isMatch) {
    throw new AppError("Incorrect Current Password", 400);
  }

  const salt = await bcrypt.genSalt(10);
  const hashedNewPassword = await bcrypt.hash(newPassword, salt);
  studentAccount.password = hashedNewPassword;
  await studentAccount.save();

  return { message: "Password Updated Successfully" };
};

const updateStudentName = async (studentId, newName) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }

  student.name = newName;
  await student.save();

  return {
    _id: student._id,
    name: student.name,
    email: student.account.email,
  };
};

const updateTeacherPassword = async (
  teacherId,
  currentPassword,
  newPassword
) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher Not Found", 404);
  }

  const teacherAccount = await authRepository.findAccountById(teacher.account);
  const isMatch = await bcrypt.compare(
    currentPassword,
    teacherAccount.password
  );
  if (!isMatch) {
    throw new AppError("Incorrect Current Password", 400);
  }

  const salt = await bcrypt.genSalt(10);
  const hashedNewPassword = await bcrypt.hash(newPassword, salt);
  teacherAccount.password = hashedNewPassword;
  await teacherAccount.save();

  return { message: "Password Updated Successfully" };
};

const updateTeacherName = async (teacherId, newName) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher Not Found", 404);
  }

  teacher.name = newName;
  await teacher.save();

  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacher.account.email,
  };
};

const getStudentInfo = async (studentId) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student not found", 404);
  }
  return {
    _id: student._id,
    name: student.name,
    email: student.account.email,
    profile_picture: student.account.profile_picture,
  };
};

const getTeacherInfo = async (teacherId) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher not found", 404);
  }
  return {
    _id: teacher._id,
    name: teacher.name,
    email: teacher.account.email,
  };
};

const uploadStudentImage = async (studentId, imageName) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student not found", 404);
  }
  const studentAccount = await authRepository.findAccountById(student.account);
  if (studentAccount.profile_picture) {
    deleteFile(studentAccount.profile_picture);
  }
  studentAccount.profile_picture = imageName;
  await studentAccount.save();
  student.account = studentAccount;
  return student;
};

const uploadTeacherImage = async (teacherId, imageName) => {
  const teacher = await authRepository.findTeacherById(teacherId);
  if (!teacher) {
    throw new AppError("Teacher not found", 404);
  }
  const teacherAccount = await authRepository.findAccountById(teacher.account);
  if (teacherAccount.profile_picture) {
    deleteFile(teacherAccount.profile_picture);
  }
  teacherAccount.profile_picture = imageName;
  await teacherAccount.save();
  teacher.account = teacherAccount;
  return teacher;
};

const generateOtp = async (account_id) => {
  const account = await authRepository.findAccountById(account_id);

  if (!account) {
    throw new AppError("Account Not Found ", 400);
  }
  if (account.email_verified) {
    throw new AppError("Email Already Verified", 400);
  }
  if (account && account.otp) {
    const existingOtp = account.otp;
    const now = new Date();
    const otpCreatedAt = new Date(existingOtp.createdAt);
    const expiryTime = 30 * 60 * 1000; // 30 minutes in milliseconds

    // Check if the existing OTP is still valid
    if (now - otpCreatedAt < expiryTime) {
      return existingOtp.otp; // Return the existing valid OTP
    }

    // If the existing OTP is expired, delete it
    await authRepository.deleteOtp(existingOtp._id);
    account.otp = null;
    await account.save();
  }

  // Call Flask API to generate a new OTP if necessary
  const response = await axios.post(`${process.env.FLASK_URL}/generate-otp`, {
    email: account.email,
  });
  if (!response.data.success) {
    throw new Error("Failed to generate OTP from Flask API");
  }
  const otp = response.data.otp;
  // Save the new OTP in the database
  const newOtp = await authRepository.createNewOtp(otp);

  // Associate the new OTP with the account
  if (account) {
    account.otp = newOtp._id;
    await account.save();
  } else {
    throw new AppError("Account not found", 404);
  }
  return newOtp.otp;
};

const verifyOtp = async (account_id, otp) => {
  const account = await authRepository.findAccountById(account_id);
  if (account.email_verified) {
    throw new AppError("Email Already Verified", 400);
  }
  if (!account) {
    throw new AppError("Account not found", 404);
  }

  if (!account.otp) {
    throw new AppError("No OTP associated with this account", 400);
  }

  const existingOtp = account.otp;
  const now = new Date();
  const otpCreatedAt = new Date(existingOtp.createdAt);
  const expiryTime = 30 * 60 * 1000; // 30 minutes in milliseconds

  if (existingOtp.otp !== parseInt(otp, 10)) {
    throw new AppError("Invalid OTP", 400);
  }

  if (now - otpCreatedAt >= expiryTime) {
    throw new AppError("Expired OTP", 400);
  }

  // OTP is valid, proceed with email verification
  await authRepository.updateAccountEmailVerification(account_id, true);
  await authRepository.deleteOtp(existingOtp._id);
  await authRepository.setAccountOtpToNull(account._id);

  return { success: true, message: "Email verified successfully" };
};

const registerStudentFace = async (studentId, imagePath) => {
  const student = await authRepository.findStudentById(studentId);
  // console.log(student)
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }
  // Call Flask API to get face encoding
  const response = await axios.post(`${process.env.FLASK_URL}/register-face`, {
    image_path: imagePath,
  });
  if (!response.data.success) {
    throw new AppError(response.data.error, 400);
  }
  // Save face encoding to student document
  student.face_biometric_data = response.data.encoding;
  await student.save();
  deleteFileByPath(imagePath);
};

const verifyStudentFace = async (studentId, imagePath, encoding) => {
  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }
  // Call Flask API for face verification
  const response = await axios.post(`${process.env.FLASK_URL}/verify-face`, {
    image_path: imagePath,
    known_face_encoding: encoding,
  });
  deleteFileByPath(imagePath);
  if (!response.data.success) {
    throw new AppError(response.data.error, 400);
  }
  // console.log(response.data)
  const { success, match } = response.data;

  if (success) {
    return { success, match };
  } else {
    throw new AppError("Face not matched", 400);
  }
};

module.exports = {
  registerStudent,
  loginStudent,
  registerTeacher,
  loginTeacher,
  updateStudentPassword,
  updateStudentName,
  updateTeacherPassword,
  updateTeacherName,
  getStudentInfo,
  getTeacherInfo,
  uploadStudentImage,
  uploadTeacherImage,
  generateOtp,
  verifyOtp,
  registerStudentFace,
  verifyStudentFace,
};

const courseRepository = require("../repositories/courseRepository");
const authRepository = require("../repositories/authRepository");
const announcementRepository = require("../repositories/announcementRepository");
const vivaRepository = require("../repositories/vivaRepository");
const projectRepository = require("../repositories/projectRepository");
const lectureRepository = require("../repositories/lectureRepository");
const quizRepository = require("../repositories/quizRepository");
const assignmentRepository = require("../repositories/assignmentRepository");
const pollService = require("../services/pollService");
const notificationService = require("../services/notificationService");

const { parseDate } = require("../utilities/dateHelper");

const { generateCourseCode } = require("../utilities/GenerateCode");
const AppError = require("../utilities/AppError");

const createCourse = async (teacherId, data) => {
  const teacher = await courseRepository.findTeacherById(teacherId);
  const checkCourse = await courseRepository.findCourseByName(data.courseName);
  if (checkCourse) {
    throw new AppError("Course Already Exists With The Same Name", 400);
  }
  const courses = await courseRepository.findAllCourses();
  const courseCode = generateCourseCode(courses);
  const newCourse = await courseRepository.createCourse({
    courseCode,
    courseName: data.courseName,
    teacher,
    description: data.description,
    projectRequirements: data.projectRequirements,
  });
  teacher.courses.push(newCourse);
  await teacher.save();
  return {
    _id: newCourse._id,
    courseCode: newCourse.courseCode,
    courseName: newCourse.courseName,
    description: newCourse.description,
    projectRequirements: newCourse.projectRequirements,
    teacher: newCourse.teacher,
  };
};

const joinCourse = async (studentId, courseCode) => {
  if (!courseCode) {
    throw new AppError("Send Course Code To Join", 201);
  }
  const student = await courseRepository.findStudentById(studentId);
  const getCourse = await courseRepository.findCourseBycourseCode(courseCode);
  if (getCourse) {
    await getCourse.populate("students");
    for (const stu of getCourse.students) {
      if (stu.id == student.id) {
        throw new AppError("Student Already Joined", 201);
      }
    }
    student.courses.push(getCourse);
    await student.save();
    getCourse.students.push(student);
    await getCourse.save();
    return {
      _id: getCourse._id,
      courseCode: getCourse.courseCode,
      courseName: getCourse.courseName,
      students: getCourse.students,
    };
  } else {
    throw new AppError("Course Not Found Wrong Code", 201);
  }
};

const updateCourseName = async (courseId, courseName) => {
  if (!courseName || courseName.trim() === "") {
    throw new AppError("Course Name Can't Be Empty", 400);
  }
  const checkCourse = await courseRepository.findCourseByName(courseName);
  if (checkCourse) {
    throw new AppError("Course Already Exists With The Same Name", 400);
  }
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  } else {
    await courseRepository.updateCourseName(courseId, courseName);
  }
  // send notification to students
  for (const studentId of getCourse.students) {
    const student = await courseRepository.findStudentById(studentId);
    const studentAccount = await authRepository.findAccountById(
      student.account
    );
    await notificationService.createNotification(
      {
        title: "Course Name Updated",
        message: `Course name has been updated to ${courseName}`,
        read: false,
      },
      studentAccount._id
    );
  }
};

const deleteCourse = async (courseId, teacherId) => {
  // Find the course by ID
  const course = await courseRepository.findCourseById(courseId);
  if (!course) throw new AppError("Course Not Found", 400);

  // Delete related Vivases
  for (const vivaId of course.vivas) {
    await vivaRepository.deleteVivaById(vivaId);
  }

  // Delete related Projects
  for (const projectId of course.projects) {
    const project = await projectRepository.findProjectById(projectId);
    if (project) {
      await projectRepository.deleteProjectById(projectId);
    }
  }

  // Delete related Announcements
  for (const announcementId of course.announcements) {
    await announcementRepository.deleteAnnouncementById(announcementId);
  }

  // Delete related Polls
  for (const pollId of course.polls) {
    await pollService.deletePoll(course._id, pollId);
  }

  // Delete related Lectures
  for (const lectureId of course.lectures) {
    await lectureRepository.deleteLectureById(lectureId);
  }

  // Delete related Assignments
  for (const assignmentId of course.assignments) {
    await assignmentRepository.deleteAssignmentById(assignmentId);
  }

  // Delete related Quizzes
  for (const quizId of course.quizzes) {
    await quizRepository.deleteQuizById(quizId);
  }

  // Remove references to the course from students
  for (const studentId of course.students) {
    await courseRepository.removeCourseFromStudent(studentId, courseId);
  }

  // Remove course from teacher
  await courseRepository.removeCourseFromTeacher(teacherId, courseId);

  // Finally, delete the course
  await courseRepository.deleteCourseById(courseId);
};

const leaveCourse = async (courseId, studentId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  const student = await courseRepository.getStudentFromCourse(
    courseId,
    studentId
  );
  console.log(student);
  if (!student) {
    throw new AppError("Student Not Found in Course", 400);
  }
  await courseRepository.removeStudentFromCourse(courseId, studentId);
  await courseRepository.removeCourseFromStudent(studentId, courseId);
};

const updateProjectSchedule = async (courseId, startDate, endDate) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  if (startDate == endDate) {
    throw new AppError("Start and End Date cannot be Same", 400);
  } else if (startDate > endDate) {
    throw new AppError("Start Date cannot be After The End Date", 400);
  } else {
    getCourse.projectStartDate = startDate;
    getCourse.projectEndDate = endDate;
    await getCourse.save();
    // notify students
    for (const studentId of getCourse.students) {
      const student = await courseRepository.findStudentById(studentId);
      const studentAccount = await authRepository.findAccountById(
        student.account
      );
      await notificationService.createNotification(
        {
          title: "Project Schedule Updated",
          content: `Project Schedule has been updated for ${getCourse.courseName}`,
          read: false,
        },
        studentAccount._id
      );
    }
    return {
      _id: getCourse._id,
      courseId: getCourse.courseId,
      courseName: getCourse.courseName,
      projectStartDate: getCourse.projectStartDate,
      projectEndDate: getCourse.projectEndDate,
    };
  }
};

const updateVivaSchedule = async (courseId, startDate, endDate) => {
  const startDate_ = parseDate(startDate);
  const endDate_ = parseDate(endDate);
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Reset time to midnight to only compare dates

  // Validation checks
  if (startDate_ < today) {
    throw new AppError("Viva Start Date cannot be before today", 400);
  }
  if (endDate_ < today) {
    throw new AppError("Viva End Date cannot be before today", 400);
  }
  if (startDate_ > endDate_) {
    throw new AppError("Viva Start Date cannot be after Viva End Date", 400);
  }
  if (startDate === endDate) {
    throw new AppError("Start and End Date cannot be the same", 400);
  }

  // Find the course
  const course = await courseRepository.findCourseById(courseId);
  if (!course) {
    throw new AppError("Course not found", 400);
  }

  // Update course schedule
  course.vivaStartDate = startDate_;
  course.vivaEndDate = endDate_;
  await course.save();
  // notify students
  for (const studentId of course.students) {
    const student = await courseRepository.findStudentById(studentId);
    const studentAccount = await authRepository.findAccountById(
      student.account
    );
    await notificationService.createNotification(
      {
        title: "Viva Schedule Updated",
        content: `Viva Schedule has been updated for ${course.courseName}`,
        read: false,
      },
      studentAccount._id
    );
  }
  // Return the updated course details
  return {
    _id: course._id,
    courseId: course.courseId,
    courseName: course.courseName,
    vivaStartDate: course.vivaStartDate,
    vivaEndDate: course.vivaEndDate,
  };
};

const sendAllCourses = async (userId) => {
  let user = await courseRepository.findStudentById(userId);
  if (!user) {
    user = await courseRepository.findTeacherById(userId);
    if (!user) {
      throw new AppError("User Not Found", 400);
    }
  }
  await user.populate({
    path: "courses",
    populate: {
      path: "teacher",
      model: "Teacher", // Replace 'Teacher' with your actual model name
    },
  });
  return { courses: user.courses };
};

const sendCourse = async (courseId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 201);
  }
  await getCourse.populate({
    path: "projects",
    populate: {
      path: "projectLeader status",
    },
  });
  await getCourse.populate("students");
  await getCourse.populate("vivas");
  return {
    _id: getCourse._id,
    courseCode: getCourse.courseCode,
    courseName: getCourse.courseName,
    description: getCourse.description,
    projectRequirements: getCourse.projectRequirements,
    students: getCourse.students,
    projects: getCourse.projects,
    vivas: getCourse.vivas,
    projectStartDate: getCourse.projectStartDate,
    projectEndDate: getCourse.projectEndDate,
    vivaStartDate: getCourse.vivaStartDate,
    courseNotifications: getCourse.courseNotifications,
    vivaNotifications: getCourse.vivaNotifications,
    vivaEndDate: getCourse.vivaEndDate,
  };
};

const updateCourse = async (courseId, body) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  for (const key in body) {
    getCourse[key] = body[key];
  }
  await getCourse.save();
  return getCourse;
};

const regenerateCourseCode = async (courseId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  const courses = await courseRepository.findAllCourses();
  const courseCode = generateCourseCode(courses);
  getCourse.courseCode = courseCode;
  await getCourse.save();
  return getCourse;
};

const addStudentToCourse = async (courseId, studentId) => {
  const student = await courseRepository.findStudentById(studentId);
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  if (!student) {
    throw new AppError("Student Not Found", 400);
  }
  await student.populate("account", "-password -otp");
  if (student.account.email_verified == false) {
    throw new AppError("Student Email Not Verified", 400);
  }
  await getCourse.populate("students");
  for (const stu of getCourse.students) {
    if (stu.id == student.id) {
      throw new AppError("Student Already Joined", 201);
    }
  }
  student.courses.push(courseId);
  await student.save();
  getCourse.students.push(studentId);
  await getCourse.save();
  return {
    _id: getCourse._id,
    courseCode: getCourse.courseCode,
    courseName: getCourse.courseName,
    students: getCourse.students,
  };
};

const removeStudentFromCourse = async (courseId, studentId) => {
  const getCourse = await courseRepository.findCourseById(courseId);
  if (!getCourse) {
    throw new AppError("Course Not Found", 400);
  }
  const student = await courseRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student Not Found", 400);
  }
  if (!getCourse.students.includes(studentId)) {
    throw new AppError("Student Not Found in Course", 400);
  }
  await courseRepository.removeStudentFromCourse(courseId, studentId);
  await courseRepository.removeCourseFromStudent(studentId, courseId);
};

const searchStudent = async (studentEmail) => {
  const account = await authRepository.findAccountByEmail(studentEmail);
  if (!account) {
    throw new AppError("Student Not Found", 400);
  }
  const student = await authRepository.findStudentByAccountId(account._id);
  if (!student) {
    throw new AppError("Student Not Found", 400);
  }
  await student.populate("account", "-password -otp");
  return student;
};

module.exports = {
  createCourse,
  joinCourse,
  updateCourseName,
  deleteCourse,
  leaveCourse,
  updateProjectSchedule,
  updateVivaSchedule,
  sendAllCourses,
  sendCourse,
  updateCourse,
  regenerateCourseCode,
  addStudentToCourse,
  removeStudentFromCourse,
  searchStudent,
};

const lectureRepository = require("../repositories/lectureRepository");
const courseRepository = require("../repositories/courseRepository");
const authRepository = require("../repositories/authRepository");
const notificationService = require("./notificationService");
const { deleteFileByPath } = require("../utilities/deleteFilesByPath");
const path = require("path");

const addLecture = async (
  courseId,
  teacherId,
  title,
  description,
  video_id
) => {
  if (!title || !description) {
    throw new Error("Title and description are required");
  }

  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const isLectureExist = await lectureRepository.getLectureByTitleAndCourse(
    title,
    courseId
  );
  if (isLectureExist) {
    throw new Error(
      "Lecture with the same title already exists in the same course"
    );
  }

  const lectureData = {
    course: courseId,
    teacher: teacherId,
    title,
    description,
    video_id,
  };
  const lecture = await lectureRepository.createLecture(lectureData);
  course.lectures.push(lecture._id);
  await course.save();
  // Notify students
  for (const student of course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "New Lecture",
        content: `A new lecture has been added to ${course.courseName}`,
        read: false,
      },
      student_account
    );
  }
  return lecture;
};

const getLecturesByCourse = async (courseId) => {
  const course = await courseRepository.getCourseById(courseId);
  await course.populate("lectures");
  return course.lectures;
};

const getLecture = async (courseId, lectureId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const lecture = await lectureRepository.getLectureById(lectureId);
  if (!lecture) {
    throw new Error("Lecture not found");
  }
  if (course.lectures.indexOf(lectureId) === -1) {
    throw new Error("Lecture not found in the course");
  }
  return lecture;
};

const updateLecture = async (
  courseId,
  lectureId,
  title,
  description,
  video_id
) => {
  const lecture = await getLecture(courseId, lectureId);
  if (!courseId || !lectureId) {
    throw new Error("Course id and lecture id must be in params");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  if (course.lectures.indexOf(lectureId) === -1) {
    throw new Error("Lecture not found in the course");
  }
  if (video_id) {
    deleteFileByPath(
      path.join(__dirname, "..", "uploads", "lectures", lecture.video_id)
    );
  }

  lecture.title = title || lecture.title;
  lecture.description = description || lecture.description;
  lecture.video_id = video_id || lecture.video_id;
  lecture.updated_at = Date.now();

  return await lectureRepository.saveLecture(lecture);
};

const deleteLecture = async (courseId, lectureId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const lecture = await lectureRepository.getLectureById(lectureId);
  if (!lecture) {
    throw new Error("Lecture not found");
  }

  if (course.lectures.indexOf(lectureId) === -1) {
    throw new Error("Lecture not found in the course");
  }

  if (lecture.video_id) {
    try {
      deleteFileByPath(
        path.join(__dirname, "..", "uploads", "lectures", lecture.video_id)
      );
    } catch (err) {
      console.log(err);
    }
  }

  await lectureRepository.deleteLectureById(lectureId);

  course.lectures = course.lectures.filter(
    (id) => id.toString() !== lectureId.toString()
  );
  await course.save();
  // notify students
  for (const student of course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "Lecture Deleted",
        message: `A lecture has been deleted from ${course.courseName}`,
        read: false,
      },
      student_account
    );
  }
};

module.exports = {
  addLecture,
  getLecturesByCourse,
  getLecture,
  updateLecture,
  deleteLecture,
};

const notificationRepository = require("../repositories/notificationRepository");
const authRepository = require("../repositories/authRepository");
const AppError = require("../utilities/AppError");

// Mark a notification as read
const markNotificationAsRead = async (notificationId, user) => {
  const userAccount = await authRepository.findAccountById(user.account);
  if (!userAccount) {
    throw new AppError("Account not found", 404);
  }

  const notification = await notificationRepository.findNotificationById(
    notificationId
  );
  if (!notification) {
    throw new AppError("Notification not found", 404);
  }
  if (notification.account.toString() !== user.account.toString()) {
    throw new AppError(
      "You are not authorized to mark this notification as read",
      403
    );
  }
  notification.read = true;
  await notification.save();
};

// Get all notifications for a user
const getAllNotifications = async (user) => {
  const account = await authRepository.findAccountByIdForNotifications(user.account);
  if (!account) {
    throw new AppError("Account not found", 404);
  }
  return account.notifications;
};

const createNotification = async (notificationData, accountId) => {
  notificationData.account = accountId;
  const notification = await notificationRepository.createNotification(
    notificationData
  );
  const account = await authRepository.findAccountById(accountId);
  account.notifications.push(notification);
  await account.save();
  return notification;
};

module.exports = {
  markNotificationAsRead,
  getAllNotifications,
  createNotification
};

const pollRepository = require("../repositories/pollRepository");
const courseRepository = require("../repositories/courseRepository");
const authRepository = require("../repositories/authRepository");
const voteRepository = require("../repositories/voteRepository");
const AppError = require("../utilities/AppError");

const addPoll = async (courseId, teacherId, title, description, options) => {
  if (!title || !options || options.length < 2 || options.length > 3) {
    throw new Error("Title and valid options (between 2 and 3) are required.");
  }

  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const pollData = {
    course: courseId,
    teacher: teacherId,
    title,
    description,
    options,
  };

  const poll = await pollRepository.createPoll(pollData);
  course.polls.push(poll._id);
  await course.save();
  // notify students
  for (const student in course.students) {
    const student_data = await authRepository.findStudentById(student);
    const student_account = await authRepository.findAccountById(
      student_data.account
    );
    await notificationService.createNotification(
      {
        title: "Poll added",
        message: `A lecture has been added in ${course.name}`,
        read: false,
      },
      student_account
    );
  }
  return poll;
};

const getPollsByCourse = async (courseId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  return await pollRepository.getPolls(courseId);
};

const getPoll = async (courseId, pollId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const poll = await pollRepository.getPollById(pollId);
  if (!poll) {
    throw new Error("Poll not found");
  }

  if (poll.course.toString() !== courseId.toString()) {
    throw new Error("Poll not found in this course");
  }

  return poll;
};

const votePoll = async (courseId, pollId, studentId, option) => {
  if (!option) {
    throw new AppError("Option is required", 400);
  }
  const poll = await pollRepository.getPollById(pollId);

  if (!poll) {
    throw new AppError("Poll not found", 404);
  }

  if (poll.course.toString() !== courseId.toString()) {
    throw new AppError("Poll not found in this course", 404);
  }
  if (poll.options.indexOf(option) === -1) {
    throw new AppError("Invalid option", 400);
  }
  const existingVote = await voteRepository.getVoteByPollAndStudent(
    pollId,
    studentId
  );

  if (existingVote) {
    if (existingVote.option === option) {
      return poll;
    } else {
      // Update the existing vote
      existingVote.option = option;
      await voteRepository.saveVote(existingVote);
      poll.updated_at = Date.now();
      await pollRepository.savePoll(poll);
      // Retrieve the updated poll from the database
      const updatedPoll = await pollRepository.getPollById(poll._id);

      // Return the updated poll
      return updatedPoll;
    }
  } else {
    // Create a new vote
    const newVote = await voteRepository.createVote({
      poll: pollId,
      student: studentId,
      option,
    });
    poll.votes.push(newVote._id);
    poll.updated_at = Date.now();
    await pollRepository.savePoll(poll);
    return poll;
  }
};

const deletePoll = async (courseId, pollId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }

  const poll = await pollRepository.getPollById(pollId);
  if (!poll) {
    throw new Error("Poll not found");
  }
  for (const voteId of poll.votes) {
    await voteRepository.deleteVoteById(voteId);
  }

  await pollRepository.deletePollById(pollId);

  course.polls = course.polls.filter(
    (id) => id.toString() !== pollId.toString()
  );
  await course.save();
};

module.exports = {
  addPoll,
  getPollsByCourse,
  getPoll,
  votePoll,
  deletePoll,
};

const axios = require("axios");
const proctoringReportRepository = require("../repositories/proctoringReportRepository");
const quizSubmissionRepository = require("../repositories/quizSubmissionRepository");
const quizRepository = require("../repositories/quizRepository");
const AppError = require("../utilities/AppError");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
const path = require("path");
const PDFDocument = require("pdfkit");
const fs = require("fs");

const analyzeImage = async (studentId, quizId, imagePath) => {
  const submission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );

  if (!submission) {
    throw new AppError("No submission found quiz not started yet", 404);
  }

  if (submission.isCompleted) {
    throw new AppError("Quiz has already been completed", 400);
  }

  const currentTime = new Date();
  const timeRemaining = submission.endTime - currentTime;

  // Check if at least 40 seconds remain before the quiz ends
  if (timeRemaining < 40000) {
    throw new AppError("Cannot take image, quiz about to end", 400);
  }

  // Call Flask API to analyze the image
  const response = await axios.post(`${process.env.FLASK_URL}/analyze-image`, {
    image_path: imagePath,
  });

  if (!response.data.success) {
    throw new AppError(response.data.error, 400);
  }

  // Append the proctoring image to the submission's proctoring report
  const updatedReport = await proctoringReportRepository.updateProctoringReport(
    submission.proctoringReport,
    {
      imageId: "result_" + path.basename(imagePath),
      cheatingIndicators: response.data.data,
    }
  );

  deleteFileByPath(imagePath);

  return {
    success: true,
    message: "Image analyzed successfully",
    updatedReport,
  };
};

const generatePdfReport = async (courseId, quizId, studentId) => {
  // Fetch the quiz and submission details
  const quiz = await quizRepository.findQuizById(quizId);
  if (!quiz || !quiz.course.equals(courseId)) {
    throw new AppError("Quiz not found for the given course", 404);
  }

  const submission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );

  if (!submission) {
    throw new AppError("Submission not found", 404);
  }

  if (!submission.isCompleted) {
    throw new AppError("Quiz is not completed yet", 400);
  }
  await submission.populate("student");

  // Fetch the AI proctoring report
  const proctoringReport =
    await proctoringReportRepository.getProctoringReportById(
      submission.proctoringReport
    );

  if (!proctoringReport) {
    throw new AppError("Proctoring report not found", 404);
  }

  await proctoringReport.populate("images");

  const formattedDateTime = new Date(submission.submittedAt).toLocaleString('en-GB', {
    dateStyle: 'short',
    timeStyle: 'medium',
  });

  // Generate the PDF report
  const doc = new PDFDocument();
  let buffers = [];
  doc.on("data", buffers.push.bind(buffers));
  doc.on("end", () => {});

  // Report Title
  doc.fontSize(22).text("Quiz Report", { align: "center", underline: true });
  doc.moveDown(1);

  // Quiz Details Section
  doc.fontSize(16).text("Quiz Details", { underline: true });
  doc.moveDown(0.5);
  doc.fontSize(14).text(`Student Name: ${submission.student.name}`);
  doc.fontSize(14).text(`Student ID: ${submission.student._id}`);
  doc.fontSize(14).text(`Quiz Title: ${quiz.title}`);
  doc.text(`Topic: ${quiz.topic}`);
  doc.text(`Submitted At: ${formattedDateTime}`);
  doc.moveDown(1);

  // Proctoring Report Section
  doc.fontSize(16).text("Proctoring Report", { underline: true });
  doc.moveDown(0.5);
  doc
    .fontSize(14)
    .text(`Cheating Probability: ${proctoringReport.cheating_probability}%`);
  doc.moveDown(1);

  // Adding Images to the PDF
  doc.fontSize(16).text("Proctoring Images", { underline: true });

  for (let i = 0; i < proctoringReport.images.length; i++) {
    const image = proctoringReport.images[i];
    const imagePath = path.join(
      __dirname,
      "../uploads/proctoring_result_db",
      image.image_id
    );

    if (fs.existsSync(imagePath)) {
      if (i === 0) {
        // First image on the first page
        doc.image(imagePath, {
          fit: [480, 640],
          align: "center",
          valign: "center",
        });
        doc.addPage(); // Add a new page after the first image
      } else {
        if ((i - 1) % 2 === 0) {
          // Add the first image of the new page
          doc.image(imagePath, {
            fit: [480, 640],
            align: "center",
            valign: "center",
          });
          doc.moveDown(50); // Space before the second image
        } else {
          // Add the second image on the same page
          doc.image(imagePath, {
            fit: [480, 640],
            align: "center",
            valign: "center",
          });
          doc.addPage(); // Add a new page after placing two images
        }
      }
    }
  }

  doc.end();
  // Wait until the PDF is generated
  return new Promise((resolve, reject) => {
    doc.on("end", () => {
      const pdfData = Buffer.concat(buffers);
      resolve(pdfData);
    });
    doc.on("error", (err) => {
      reject(err);
    });
  });
};

module.exports = {
  analyzeImage,
  generatePdfReport,
};

const projectRepository = require("../repositories/projectRepository");
const authRepository = require("../repositories/authRepository");
const statusRepository = require("../repositories/statusRepository");
const notificationService = require("./notificationService");
const AppError = require("../utilities/AppError");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const dotenv = require("dotenv");

const createProject = async (userId, projectData) => {
  const { name, scope, members, courseId } = projectData;

  // Validate student and course existence
  const student = await projectRepository.findStudentById(userId);
  if (!student) {
    throw new AppError("Student Not Found", 404);
  }

  const checkCourse = await projectRepository.findCourseById(courseId);
  if (!checkCourse) {
    throw new AppError("Course Not Found", 404);
  }

  // Validate project uniqueness within the course
  const existingProject = await projectRepository.findProjectByNameAndCourse(
    name,
    courseId
  );
  if (existingProject) {
    throw new AppError(
      "Project with the same name already exists in this course",
      409
    );
  }

  // Ensure the student is not already leading another project in the same course
  const existingLeaderProject =
    await projectRepository.findProjectByLeaderAndCourse(student, checkCourse);
  if (existingLeaderProject) {
    throw new AppError("You are already leading a group in this course", 409);
  }

  // Validate all members
  for (const member of members) {
    const groupMember = await projectRepository.findStudentById(member);
    console.log(groupMember);
    if (!groupMember) {
      throw new AppError(`Member with ID ${member} not found`, 404);
    }

    // Ensure member is enrolled in the course
    if (!groupMember.courses.includes(courseId)) {
      throw new AppError(
        `Member ${groupMember.name} is not part of the course`,
        400
      );
    }

    // Check if the member is already part of another group in the same course
    const isMemberInAnotherGroup =
      await projectRepository.findProjectByMemberAndCourse(
        groupMember,
        checkCourse
      );
    if (isMemberInAnotherGroup) {
      throw new AppError(
        `Member ${groupMember.name} is already in another group for this course`,
        409
      );
    }
  }

  // Create the project
  const project = await projectRepository.createProject({
    name,
    scope,
    projectLeader: student,
    course: checkCourse,
  });

  // Set student as group leader
  student.isGroupLeader = true;
  await student.save();

  // Add members to the project
  for (const member of members) {
    const groupMember = await projectRepository.findStudentById(member);
    project.members.push(groupMember);
  }

  // Create and assign initial project status
  const status = await projectRepository.createStatus({
    status: "pending",
    description: "",
  });
  if (!status) {
    throw new AppError("Failed to save status due to an internal error", 500);
  }
  project.status = status;

  // Save the project and update course with the new project
  await project.save();
  checkCourse.projects.push(project);
  await checkCourse.save();

  // Return the created project details
  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course._id,
  };
};

const updateProject = async (projectId, projectData) => {
  const { name, scope, members, courseId } = projectData;

  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }

  // Validate and collect new members
  const validMembers = [];
  for (const memberId of members) {
    const member = await projectRepository.findStudentById(memberId);
    if (!member) {
      throw new AppError(`Member with ID ${memberId} not found`, 404);
    }

    // Ensure member is enrolled in the course
    if (!member.courses.includes(courseId)) {
      throw new AppError(
        `Member ${member.name} is not part of the course`,
        400
      );
    }

    // Check if the member is already part of another group in the same course
    const isMemberInAnotherGroup =
      await projectRepository.findProjectByMemberAndCourse(member, courseId);
    if (
      isMemberInAnotherGroup &&
      isMemberInAnotherGroup._id.toString() !== projectId.toString()
    ) {
      throw new AppError(
        `Member ${member.name} is already in another group for this course`,
        409
      );
    }

    validMembers.push(member);
  }

  // Update the project with new data
  const updatedProject = await projectRepository.updateProjectById(projectId, {
    name,
    scope,
    members: validMembers,
  });

  return {
    _id: updatedProject._id,
    name: updatedProject.name,
    scope: updatedProject.scope,
    members: updatedProject.members,
    projectLeader: updatedProject.projectLeader,
    course: updatedProject.course,
  };
};

const getProjectById = async (projectId) => {
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 400);
  }

  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course,
  };
};

const addMemberToProject = async (projectId, email, courseId) => {
  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }
  if (project.members.length > 4) {
    throw new AppError("You cannot add more then 4 members", 400);
  }
  // Find the student by email
  const account = await authRepository.findAccountByEmail(email);
  const member = await authRepository.findStudentByAccountId(account._id);
  if (!member) {
    throw new AppError(`Member with email ${email} not found`, 404);
  }

  // Ensure the member is enrolled in the course
  if (!member.courses.includes(courseId)) {
    throw new AppError(`Member ${member.name} is not part of the course`, 400);
  }

  // Check if the member is already part of another group in the same course
  const isMemberInAnotherGroup =
    await projectRepository.findProjectByMemberAndCourse(member, courseId);
  if (isMemberInAnotherGroup) {
    throw new AppError(
      `Member ${member.name} is already in another group for this course`,
      409
    );
  }

  // Add the member to the project
  project.members.push(member);
  await project.save();
  await notificationService.createNotification(
    {
      title: "You are added to a project",
      content: `You have been added to project ${project.name}`,
      read: false,
    },
    account._id
  );
  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course._id,
  };
};

const removeMemberFromProject = async (projectId, memberId) => {
  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }
  if (project.members.length == 0) {
    throw new AppError("Cannot remove you are only on member", 400);
  }

  // Check if the member is part of the project
  const memberIndex = project.members.findIndex(
    (member) => member._id.toString() === memberId
  );
  if (memberIndex === -1) {
    throw new AppError("Member not found in this project", 404);
  }

  // Remove the member from the project
  project.members.splice(memberIndex, 1);
  await project.save();
  // notify student
  await notificationService.createNotification(
    {
      title: "You are removed from a project",
      content: `You have been removed from  ${project.name}`,
      read: false,
    },
    account._id
  );
  return {
    _id: project._id,
    name: project.name,
    scope: project.scope,
    members: project.members,
    projectLeader: project.projectLeader,
    course: project.course._id,
  };
};

const deleteProject = async (projectId, userId) => {
  // Find the project by ID
  const project = await projectRepository.findProjectById(projectId);
  if (!project) {
    throw new AppError("Project Not Found", 404);
  }

  // Find the course associated with the project
  const course = await projectRepository.findCourseById(project.course._id);
  if (!course) {
    throw new AppError("Course Not Found", 404);
  }

  // Ensure the user is either the course creator or the project leader
  const isCourseCreator = course.teacher.toString() === userId.toString();
  const isProjectLeader =
    project.projectLeader._id.toString() === userId.toString();
  if (!isCourseCreator && !isProjectLeader) {
    throw new AppError(
      "Unauthorized: Only the course creator or project leader can delete this project",
      403
    );
  }

  // Remove the project from the course's project list
  course.projects.pull(projectId);
  await course.save();

  // Delete the project's status
  if (project.status) {
    await statusRepository.deleteStatus(project.status._id);
  }

  // Delete the project
  await projectRepository.deleteProjectById(projectId);
};

const generateProjectSuggestions = async (courseId) => {
  const genAI = new GoogleGenerativeAI(process.env.GEMENI_API_KEY);
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  // Find the course by ID
  const course = await projectRepository.findCourseById(courseId);
  if (!course) {
    throw new AppError("Course not found", 404);
  }

  const { projectRequirements, courseName, courseDescription } = course;

  // Construct the prompt using course details
  const prompt = `Generate 5 project ideas that match the following criteria:
    Course Name: ${courseName}
    Course Description: ${courseDescription}
    Project Requirements: ${projectRequirements}
    Output format: Each idea should be represented as an object with 'ideaTitle' and 'ideaDescription' fields. Format: [{ideaTitle: '...', ideaDescription: '...'}, ...]. Should be JSON Array only.`;

  try {
    const result = await model.generateContent(prompt);
    let response = result.response;

    // Remove ```json and last ```
    let jsonString = response
      .text()
      .replace(/^```json\s+/, "")
      .replace(/\s+```$/, "");

    // Parse the response into a JSON array
    const jsonArray = JSON.parse(jsonString);

    return jsonArray;
  } catch (err) {
    console.error("Error generating project suggestions:", err);
    throw new AppError(
      "Failed to generate project suggestions. Please try again later.",
      500
    );
  }
};

module.exports = {
  createProject,
  updateProject,
  getProjectById,
  addMemberToProject,
  removeMemberFromProject,
  deleteProject,
  generateProjectSuggestions,
};

const quizRepository = require("../repositories/quizRepository");
const questionRepository = require("../repositories/questionRepository");
const courseRepository = require("../repositories/courseRepository");
const quizSubmissionRepository = require("../repositories/quizSubmissionRepository");
const proctoringReportRepository = require("../repositories/proctoringReportRepository");
const authRepository = require("../repositories/authRepository");
const notificationService = require("./notificationService");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const fs = require("fs");
const PDFDocument = require("pdfkit");
const genAI = new GoogleGenerativeAI(process.env.GEMENI_API_KEY);
const model = genAI.getGenerativeModel({ model: "gemini-pro" });
const { calculateQuizScore } = require("../utilities/calculateQuizScore");
const { extractEnrollment } = require("../utilities/extractEnrollment");
const _ = require("lodash");
const AppError = require("../utilities/AppError");
const AdmZip = require("adm-zip");
const axios = require("axios");
require("dotenv").config();

const createQuiz = async (
  courseId,
  title,
  topic,
  questions,
  deadline,
  duration,
  number_of_questions
) => {
  if (
    !courseId ||
    !title ||
    !questions ||
    !topic ||
    !deadline ||
    !duration ||
    !number_of_questions
  ) {
    throw new AppError("Input all required fields", 400);
  }
  if (new Date(deadline) < new Date()) {
    throw new AppError("Deadline must be in the future", 400);
  }
  let course = await courseRepository.getCourseById(courseId);

  if (!course) {
    throw new AppError("Course not found", 404);
  }
  const questionIds = [];
  for (const questionData of questions) {
    let question = await questionRepository.findQuestionByContent(
      questionData.content
    );
    if (!question) {
      question = await questionRepository.createQuestion(questionData);
    }
    questionIds.push(question._id);
  }

  const quiz = await quizRepository.createQuiz({
    course,
    title,
    deadline,
    topic,
    duration,
    number_of_questions,
    questions: questionIds,
  });
  course.quizzes.push(quiz._id);
  await course.save();

  // notify students
  for (const student of course.students) {
    const studentData = await authRepository.findStudentById(student);
    const studentAccount = await authRepository.findAccountById(
      studentData.account
    );
    await notificationService.createNotification(
      {
        title: "New Quiz",
        message: `A new quiz has been added to ${course.name}`,
        read: false,
      },
      studentAccount._id
    );
  }

  return quiz;
};

const updateQuiz = async (
  quizId,
  title,
  topic,
  questions,
  deadline,
  duration,
  number_of_questions
) => {
  if (
    !quizId ||
    !title ||
    !questions ||
    !topic ||
    !deadline ||
    !duration ||
    !number_of_questions
  ) {
    throw new AppError("Input all required fields", 400);
  }

  const quiz = await quizRepository.getQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }
  if (new Date(deadline) < new Date()) {
    throw new AppError("Deadline must be in the future", 400);
  }
  const questionIds = [];
  for (const questionData of questions) {
    let question = await questionRepository.findQuestionByContent(
      questionData.content
    );
    if (!question) {
      question = await questionRepository.createQuestion(questionData);
    }
    questionIds.push(question._id);
  }

  quiz.title = title;
  quiz.topic = topic;
  quiz.deadline = deadline;
  quiz.duration = duration;
  quiz.number_of_questions = number_of_questions;
  quiz.questions = questionIds;
  await quiz.save();
  return quiz;
};

const deleteQuiz = async (quizId, courseId) => {
  const quiz = await quizRepository.getQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  if (courseId !== quiz.course.toString()) {
    throw new AppError("Course ID does not match", 400);
  }
  // Delete quiz
  await quizRepository.deleteQuizById(quizId);
  // Remove the quiz reference from the associated course
  const course = await courseRepository.getCourseById(quiz.course);
  if (!course) {
    throw new AppError("Course not found", 404);
  }
  course.quizzes.pull(quizId);
  await course.save();
};

const getQuiz = async (id, courseId) => {
  const quiz = await quizRepository.findQuizById(id);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }
  if (quiz.course.toString() !== courseId) {
    throw new AppError("Course ID does not match", 400);
  }
  return quiz;
};

const getQuizStudent = async (id, courseId) => {
  const quiz = await quizRepository.findQuizById(id);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }
  if (quiz.course.toString() !== courseId) {
    throw new AppError("Course ID does not match", 400);
  }

  // Shuffle the questions
  const shuffledQuestions = _.shuffle(quiz.questions);

  // Get the number of questions stated in the quiz model
  const numberOfQuestions = quiz.number_of_questions;

  // Return the specified number of questions
  const selectedQuestions = shuffledQuestions.slice(0, numberOfQuestions);

  // If you need to return the entire quiz object with the modified questions
  return { ...quiz.toObject(), questions: selectedQuestions };
};

const getQuizzesByCourse = async (courseId) => {
  const quizzes = await quizRepository.getQuizzesByCourse(courseId);
  return quizzes;
};

const startQuiz = async (quizId, studentId) => {
  const quiz = await quizRepository.getQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  const existingSubmission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );
  if (existingSubmission && !existingSubmission.isCompleted) {
    throw new AppError("Quiz is already started and not completed", 400);
  }

  const startTime = new Date();
  const endTime = new Date(startTime.getTime() + quiz.duration * 60000);

  const newSubmission = await quizSubmissionRepository.createSubmission({
    quiz: quizId,
    student: studentId,
    startedAt: startTime,
    endTime: endTime,
  });

  quiz.submissions.push(newSubmission._id);
  await quiz.save();

  // Create the proctoring report and link it to the submission
  const proctoringReport =
    await proctoringReportRepository.createProctoringReport({
      images: [],
      cheating_indicators: {
        mobile_phone: 0,
        extra_person: 0,
        mouth_open: 0,
        no_person: 0,
        eye_left_right: 0,
      },
    });

  newSubmission.proctoringReport = proctoringReport;
  await newSubmission.save();

  return newSubmission;
};

const submitQuiz = async (quizId, studentId, answers) => {
  // Find the submission for the given quiz and student
  const submission = await quizSubmissionRepository.findSubmission(
    quizId,
    studentId
  );

  // Validate if answers are provided
  if (!answers) {
    throw new AppError("Input answers");
  }

  // Fetch the quiz details by ID
  const quiz = await quizRepository.findQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  // Check if the submission exists
  if (!submission) {
    throw new AppError("Submission not found", 404);
  }

  // Check if the quiz has already been submitted
  if (submission.isCompleted) {
    throw new AppError("Quiz already submitted", 400);
  }

  // Ensure the submission is within the allowed time
  const currentTime = new Date();
  if (currentTime > submission.endTime) {
    throw new AppError("Quiz time has expired", 400);
  }

  // Update submission with the provided answers
  submission.answers = answers;
  submission.submittedAt = currentTime;
  submission.isCompleted = true;

  // Fetch the proctoring report linked to the submission
  const proctoringReport =
    await proctoringReportRepository.getProctoringReportById(
      submission.proctoringReport
    );

  // Extract features from the proctoring report for cheating detection
  const features = [
    proctoringReport.images.length,
    proctoringReport.cheating_indicators.mobile_phone,
    proctoringReport.cheating_indicators.extra_person,
    proctoringReport.cheating_indicators.mouth_open,
    proctoringReport.cheating_indicators.no_person,
    proctoringReport.cheating_indicators.eye_left_right,
  ];

  // Make a request to the Flask API to assess cheating probability
  let isFlagged = false;
  const response = await axios.post(
    `${process.env.FLASK_URL}/predict-cheating`,
    {
      features: features,
    }
  );

  // Extract cheating probability from the response
  const cheatingProbability = response.data.data.cheating_probability;

  // Flag the submission if cheating probability is above the threshold
  if (cheatingProbability > 60) {
    isFlagged = true;
  }

  if (isFlagged) {
    submission.isFlagged = true;
  }

  // Update the proctoring report with the cheating probability
  proctoringReport.cheating_probability = cheatingProbability;

  // Calculate and assign the quiz score based on the submitted answers
  submission.score = calculateQuizScore(answers, quiz.questions);

  // Save the updated proctoring report and submission
  await proctoringReport.save();
  await submission.save();

  // Return the updated submission
  return submission;
};

const updateSubmissionMarks = async (
  courseId,
  quizId,
  submissionId,
  newScore
) => {
  // Get the course by its ID
  const course = await courseRepository.getCourseById(courseId);

  // Check if the course exists
  if (!course) {
    throw new AppError("Course not found", 404);
  }

  // Check if the quiz belongs to the course
  const quizBelongsToCourse = course.quizzes.includes(quizId);
  if (!quizBelongsToCourse) {
    throw new AppError("Quiz does not belong to the specified course", 400);
  }

  // Fetch the quiz details by ID
  const quiz = await quizRepository.findQuizById(quizId);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  // Find the submission for the given quiz and student
  const submission = await quizSubmissionRepository.findSubmissionById(
    submissionId
  );

  // Check if the submission exists
  if (!submission) {
    throw new AppError("Submission not found", 404);
  }

  // Check if the quiz has already been submitted
  if (!submission.isCompleted) {
    throw new AppError("Quiz has not been submitted yet", 400);
  }

  if (newScore < 0) {
    throw new AppError("Score cannot be negative", 400);
  }

  if (newScore > quiz.number_of_questions) {
    throw new AppError(
      "Score cannot be greater than the number of questions",
      400
    );
  }
  // Update the submission score
  submission.score = newScore;

  // Save the updated submission
  await submission.save();
  //notify student
  const student = await authRepository.findStudentById(submission.student);
  const studentAccount = await authRepository.findAccountById(student.account);
  await notificationService.createNotification(
    {
      title: "Quiz Score Updated",
      message: `Your score for the quiz ${quiz.title} has been updated.`,
      read: false,
    },
    studentAccount._id
  );
  return submission;
};

const updateSubmissionFlag = async (
  courseId,
  quizId,
  submissionId,
  isFlagged
) => {
  // Fetch the course to ensure the quiz belongs to it
  const course = await courseRepository.getCourseById(courseId);

  // Ensure the quiz belongs to the course
  if (!course.quizzes.includes(quizId)) {
    throw new AppError("Quiz does not belong to the specified course", 404);
  }

  // Fetch the submission
  const submission = await quizSubmissionRepository.findSubmissionById(
    submissionId
  );
  if (!submission) {
    throw new AppError("Submission not found", 404);
  }

  // Ensure the submission is for the correct quiz
  if (submission.quiz.toString() !== quizId) {
    throw new AppError("Submission does not belong to the specified quiz", 400);
  }

  // Update the isFlagged status
  submission.isFlagged = isFlagged;
  await submission.save();

  return submission;
};

const generateQuestionsByTopic = async (
  topic,
  numberOfQuestions,
  difficulty
) => {
  // const genAI = new GoogleGenerativeAI(process.env.GEMENI_API_KEY);
  // const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const prompt = `
  Generate ${numberOfQuestions} multiple-choice questions about ${topic}
  with difficulty level: ${difficulty}.
  Output format: JSON Array. Each question should have the following structure:
  {
    "content": "Question text",
    "options": ["Option 1", "Option 2", "Option 3", "Option 4"],
    "correct_option": "Correct option (Should be one of the options from the options array)"
  }
  `;

  try {
    const result = await model.generateContent(prompt);
    let response = result.response;

    let jsonString = response
      .text()
      .replace(/^```json\s+/, "")
      .replace(/\s+```$/, "");

    const jsonArray = JSON.parse(jsonString);
    return jsonArray;
  } catch (err) {
    console.error("Error generating questions:", err);
    throw new AppError(
      "Failed to generate quiz questions. Please try again later.",
      500
    );
  }
};

const generateQuestionsByContent = async (
  topic,
  content,
  numberOfQuestions,
  difficulty
) => {
  const prompt = `
    Generate ${numberOfQuestions} multiple-choice questions ${
    topic ? `about the topic: "${topic}"` : ""
  } 
    ${content ? `based on the following content: "${content}"` : ""}
    with a difficulty level of ${difficulty}.
    Output format: JSON Array. Each question should have the following structure:
    {
      "content": "Question text",
      "options": ["Option 1", "Option 2", "Option 3", "Option 4"],
      "correct_option": "Correct option (Should be one of the options from the options array)"
    }
  `;

  try {
    const result = await model.generateContent(prompt);
    let response = result.response;

    let jsonString = response
      .text()
      .replace(/^```json\s+/, "")
      .replace(/\s+```$/, "");

    const jsonArray = JSON.parse(jsonString);
    return jsonArray;
  } catch (err) {
    console.error("Error generating questions:", err);
    throw new AppError(
      "Failed to generate quiz questions. Please try again later.",
      500
    );
  }
};

const generatePDFStudent = async (courseId, id, studentId) => {
  // Fetch Quiz, Student, and Course Information
  const quiz = await quizRepository.findQuizById(id);
  if (!quiz) {
    throw new AppError("Quiz not found", 404);
  }

  const student = await authRepository.findStudentById(studentId);
  if (!student) {
    throw new AppError("Student not found", 404);
  }

  const account = await authRepository.findAccountById(student.account);
  if (!account) {
    throw new AppError("Account not found", 404);
  }

  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new AppError("Course not found", 404);
  }

  // Check if student is enrolled in the course
  if (course.students.indexOf(studentId) === -1) {
    throw new AppError("Student not enrolled in the course", 400);
  }

  const enrollment = extractEnrollment(account.email);

  // Generate the PDF document
  const doc = new PDFDocument();
  let buffers = [];
  doc.on("data", buffers.push.bind(buffers));
  doc.on("end", () => {});

  // Add Quiz and Student Details to the PDF
  doc.fontSize(18).text(`${quiz.title}`, { align: "center" }).moveDown();
  doc.fontSize(14).text(`Topic: ${quiz.topic}`).moveDown();
  doc
    .fontSize(12)
    .text(
      "---------------------------------------------------------------------------------------------------------------------"
    )
    .moveDown();
  doc.text(`Student Name: ${student.name}`).moveDown();
  doc.text(`Student Enrollment: ${enrollment}`).moveDown();
  doc
    .fontSize(12)
    .text(
      "---------------------------------------------------------------------------------------------------------------------"
    )
    .moveDown();

  // Shuffle and Add Questions to PDF
  const shuffledQuestions = quiz.questions.sort(() => Math.random() - 0.5);
  shuffledQuestions.forEach((question, index) => {
    doc
      .fontSize(14)
      .text(`${index + 1}. ${question.content}`)
      .moveDown(0.5); // Slightly reduce space between questions

    // Add options with circles before them
    question.options.forEach((option) => {
      doc.fontSize(12).text(`o    ${option}`, {
        indent: 20,
      }); // Indent options
      doc.moveDown(0.2); // Reduce space between options
    });
    doc.moveDown(0.5); // Move down a bit after each question
  });

  // Finalize the PDF Document
  doc.end();

  // Wait until the PDF is generated
  return new Promise((resolve, reject) => {
    doc.on("end", () => {
      const pdfData = Buffer.concat(buffers);
      resolve(pdfData);
    });
    doc.on("error", (err) => {
      reject(err);
    });
  });
};


/**
 * Generates PDFs for all students enrolled in a course and compresses them into a zip file.
 * @param {string} courseId - The ID of the course.
 * @param {string} quizId - The ID of the quiz.
 * @returns {Buffer} - The buffer containing the zip file data.
 */
const generatePDFForAllStudents = async (courseId, quizId) => {
  // Fetch the course to get enrolled students
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new AppError("Course not found", 404);
  }

  // Create a zip file to store individual student PDFs
  const zip = new AdmZip();

  let count = 0;
  // Iterate through each student enrolled in the course
  for (const studentId of course.students) {
    try {
      // Generate PDF for the current student
      const pdfBuffer = await generatePDFStudent(courseId, quizId, studentId);

      // Add the generated PDF to the zip file
      zip.addFile(`quiz_${count}.pdf`, pdfBuffer);
      count++;
    } catch (error) {
      console.error(`Error generating PDF for student ${studentId}:`, error);
      // Optionally log error or continue processing other students
    }
  }

  // Return the zip file buffer
  return zip.toBuffer();
};


module.exports = {
  createQuiz,
  updateQuiz,
  deleteQuiz,
  getQuiz,
  getQuizzesByCourse,
  getQuizStudent,
  startQuiz,
  submitQuiz,
  updateSubmissionMarks,
  updateSubmissionFlag,
  generateQuestionsByTopic,
  generateQuestionsByContent,
  generatePDFStudent,
  generatePDFForAllStudents,
};

const remarkRepository = require("../repositories/remarksRepository");
const AppError = require("../utilities/AppError");
const vivaRepository = require("../repositories/vivaRepository");
const submissionRepository = require("../repositories/submissionRepository");
const authRepository = require("../repositories/authRepository");
const notificationService = require("./notificationService");

const addRemarkToViva = async (classId, projectId, remarkData) => {
  const project = await remarkRepository.findProjectByIdAndCourseId(
    projectId,
    classId
  );
  if (!project) {
    throw new AppError("Project Not Found", 400);
  }
  if (project.viva) {
    if (project.viva.status !== "taken") {
      throw new AppError("Can't Add Remark Without Taking Viva", 400);
    }
  } else {
    throw new AppError("Didn't Schedule Viva Yet", 400);
  }

  const viva = await vivaRepository.findVivaById(project.viva._id);
  if (viva.remarks) {
    throw new AppError("Remark Already Added", 400);
  }
  const remark = await remarkRepository.createRemark({
    overallPerformance: remarkData.overallPerformance,
    feedback: remarkData.feedback,
    obtainedMarks: remarkData.obtainedMarks,
    totalMarks: remarkData.totalMarks,
  });
  if (!remark) {
    throw new AppError("Not Saved due To Some Internal Error", 400);
  }
  viva.remarks = remark;
  await remarkRepository.saveViva(viva);
  for (const student of project.members) {
    const studentData = await authRepository.findStudentById(student);
    const studentAccount = await authRepository.findAccountById(
      studentData.account
    );
    await notificationService.createNotification(
      {
        title: "Remark Updated",
        message: `Your remark has been updated`,
        read: false,
      },
      studentAccount._id
    );
  }
  // notify project leader
  const leader = await authRepository.findStudentById(project.projectLeader);
  const leaderAccount = await authRepository.findAccountById(leader.account);
  await notificationService.createNotification(
    {
      title: "Remark Updated",
      message: `Your remark has been updated`,
      read: false,
    },
    leaderAccount._id
  );
  return viva.remarks;
};

const updateRemark = async (remarkId, updateData) => {
  const checkRemark = await remarkRepository.findRemarkById(remarkId);
  if (!checkRemark) throw new AppError("Remark Not Found", 400);
  const updatedRemark = await remarkRepository.updateRemark(
    remarkId,
    updateData
  );
  return updatedRemark;
};

const sendRemark = async (remarkId, projectId, courseId) => {
  const project = await remarkRepository.findProjectByIdAndCourseId(
    projectId,
    courseId
  );
  if (!project) throw new AppError("Project Not Found", 400);
  const viva = await vivaRepository.findVivaById(project.viva._id);
  if (!viva) throw new AppError("Viva Not Found", 400);
  if (viva.remarks._id.toString() !== remarkId)
    throw new AppError("Remarks not exists on viva of this project", 400);
  return viva.remarks;
};

//for submission
const addRemarkToSubmission = async (courseId, submissionId, remarkData) => {
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) {
    throw new AppError("Submission Not Found", 400);
  }

  if (submission.remarks) {
    throw new AppError("Remark Already Added", 400);
  }

  const remark = await remarkRepository.createRemark(remarkData);

  if (!remark) {
    throw new AppError("Not Saved due To Some Internal Error", 400);
  }

  submission.remarks = remark;
  await submissionRepository.saveSubmission(submission);
  const student = await authRepository.findStudentById(submission.student);
  const studentAccount = await authRepository.findAccountById(student.account);
  await notificationService.createNotification(
    {
      title: "Remark added",
      message: `Your remark has been added`,
      read: false,
    },
    studentAccount._id
  );
  return submission.remarks;
};

const readSubmissionRemark = async (remarkId, submissionId, studentId) => {
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) throw new AppError("Submission Not Found", 400);
  if (submission.student.toString() !== studentId.toString()) {
    throw new AppError("Not authorized", 400);
  }
  if (submission.remarks._id.toString() !== remarkId) {
    throw new AppError("Remarks not exists on this submission", 400);
  }

  return submission.remarks;
};

module.exports = {
  addRemarkToViva,
  updateRemark,
  sendRemark,
  addRemarkToSubmission,
  updateRemark,
  readSubmissionRemark,
};

const statusRepository = require("../repositories/statusRepository");
const projectRepository = require("../repositories/projectRepository");
const AppError = require("../utilities/AppError");

const addStatus = async (classId, projectId, statusData) => {
  const project = await projectRepository.findProjectByIdAndCourse(
    projectId,
    classId
  );
  if (!project) {
    throw new AppError("Project Not Found", 400);
  }
  if (project.viva) {
    throw new AppError("Viva Is Scheduled So Can't Add Status Now", 400);
  }
  if (project.status) {
    throw new AppError("Status Already Exists", 400);
  }
  const status = await statusRepository.createStatus(statusData);
  if (!status) {
    throw new AppError("Not Saved due To Some Internal Error", 400);
  }
  project.status = status;
  await project.save();
  return {
    _id: status._id,
    status: status.status,
    description: status.description,
  };
};

const updateStatus = async (statusId, statusData) => {
  const status = await statusRepository.findStatusById(statusId);
  if (!status) {
    throw new AppError("Status Not Found", 400);
  }
  const updatedStatus = await statusRepository.updateStatusById(
    statusId,
    statusData
  );
  if (!updatedStatus) {
    throw new AppError("Not Updated due To Some Internal Error", 400);
  }
  return {
    _id: updatedStatus._id,
    status: updatedStatus.status,
    description: updatedStatus.description,
  };
};

const getStatusById = async (statusId) => {
  const status = await statusRepository.findStatusById(statusId);
  if (!status) {
    throw new AppError("Status Not Found", 400);
  }
  return {
    _id: status._id,
    status: status.status,
    description: status.description,
  };
};

module.exports = {
  addStatus,
  updateStatus,
  getStatusById,
};

const submissionRepository = require("../repositories/submissionRepository");
const courseRepository = require("../repositories/courseRepository");
const assignmentRepository = require("../repositories/assignmentRepository");
const authRepository = require("../repositories/authRepository");
const notificationService = require("./notificationService");
const { deleteFileByPath } = require("../utilities/deleteFilesBypath");
const path = require("path");

const addSubmission = async (
  courseId,
  assignmentId,
  studentId,
  document_id
) => {
  if (!courseId) {
    throw new Error("Course ID is required");
  }
  if (!assignmentId) {
    throw new Error("Assignment ID is required");
  }
  if (!studentId) {
    throw new Error("Student ID is required");
  }
  if (!document_id) {
    throw new Error("Document ID is required");
  }
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (assignment.course.toString() !== courseId) {
    throw new Error("Assignment not found in this course");
  }
  if (assignment.deadline < Date.now()) {
    throw new Error("Assignment deadline has passed");
  }
  const isSubmitted =
    await submissionRepository.getSubmissionByAssignmentAndStudent(
      assignmentId,
      studentId
    );
  if (isSubmitted) {
    throw new Error("Submission already exists update instead");
  }
  const submissionData = {
    assignment: assignmentId,
    student: studentId,
    document_id: document_id,
  };
  const submission = await submissionRepository.createSubmission(
    submissionData
  );
  assignment.submissions.push(submission._id);
  await assignmentRepository.saveAssignment(assignment);
  const teacher = await authRepository.findTeacherById(assignment.teacher);
  const account = await authRepository.findAccountById(teacher.account);
  await notificationService.createNotification(
    {
      title: "New Submission",
      message: `A new submission has been added to ${assignment.title}`,
    },
    account._id
  );
  return submission;
};

const getSubmissionsByAssignment = async (courseId, assignmentId) => {
  const course = await courseRepository.getCourseById(courseId);
  if (!course) {
    throw new Error("Course not found");
  }
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (assignment.course.toString() !== courseId) {
    throw new Error("Assignment not found in this course");
  }
  const submissions = await submissionRepository.getSubmissionsByAssignmentId(
    assignmentId
  );

  return submissions;
};

const getSubmission = async (assignmentId, submissionId, studentId) => {
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) {
    throw new Error("Submission not found");
  }
  if (submission.assignment.toString() !== assignmentId) {
    throw new Error("Submission not found in this assignment");
  }
  if (submission.student.toString() !== studentId.toString()) {
    throw new Error("Not authorized to view this submission");
  }
  return submission;
};

const updateSubmission = async (
  assignmentId,
  submissionId,
  studentId,
  document_id
) => {
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  if (assignment.deadline < Date.now()) {
    throw new Error("Assignment deadline has passed");
  }
  const submission = await submissionRepository.getSubmissionById(submissionId);

  if (!submission) {
    throw new Error("Submission not found");
  }
  if (submission.assignment.toString() !== assignmentId) {
    throw new Error("Submission not found in this assignment");
  }
  if (submission.student.toString() !== studentId.toString()) {
    throw new Error("Not authorized to update this submission");
  }
  if (submission.document_id) {
    deleteFileByPath(
      path.join(__dirname, "../uploads", "submissions", submission.document_id)
    );
  }
  submission.document_id = document_id || submission.document_id;
  submission.submitted_at = Date.now();
  return await submissionRepository.saveSubmission(submission);
};

const deleteSubmission = async (assignmentId, submissionId, studentId) => {
  const assignment = await assignmentRepository.getAssignmentById(assignmentId);
  if (!assignment) {
    throw new Error("Assignment not found");
  }
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) {
    throw new Error("Submission not found");
  }
  if (submission.assignment.toString() !== assignmentId) {
    throw new Error("Submission not found in this assignment");
  }
  if (submission.student.toString() !== studentId.toString()) {
    throw new Error("Not authorized to delete this submission");
  }
  if (submission.document_id) {
    deleteFileByPath(
      path.join(__dirname, "../uploads", "submissions", submission.document_id)
    );
  }
  return await submissionRepository.deleteSubmissionById(submissionId);
};

const getSubmissionTeacher = async (submissionId) => {
  const submission = await submissionRepository.getSubmissionById(submissionId);
  if (!submission) {
    throw new Error("Submission not found");
  }
  return submission;
};

module.exports = {
  addSubmission,
  getSubmissionsByAssignment,
  getSubmission,
  updateSubmission,
  deleteSubmission,
  getSubmissionTeacher,
};

const vivaRepository = require("../repositories/vivaRepository");
const authRepository = require("../repositories/authRepository");
const notificationService = require("./notificationService");
const projectRepository = require("../repositories/projectRepository");
const AppError = require("../utilities/AppError");
const { GoogleGenerativeAI } = require("@google/generative-ai");

const { generateVivaDate, getTodayVivas } = require("../utilities/vivaHelpers");

const addViva = async (courseId, projectId) => {
  // Find the project by ID
  const project = await vivaRepository.findProjectById(projectId);
  if (!project) throw new AppError("Project Not Found", 400);

  // Ensure the project belongs to the course and is approved
  if (project.course._id != courseId)
    throw new AppError("Project Not Found In This Course", 400);
  if (project.status.status !== "approved")
    throw new AppError("Project Is Not Approved", 400);

  // Check if a viva already exists for this project
  if (project.viva) {
    throw new AppError("Viva already added");
  }

  // Find the course by ID
  const getCourse = await vivaRepository.findCourseById(courseId);
  if (!getCourse) throw new AppError("Course Not Found", 400);
  await getCourse.populate("vivas");

  // Ensure the viva start date is set
  if (!getCourse.vivaStartDate)
    throw new AppError("Viva Start Date Not Set", 400);

  // Generate a viva date
  const vivaDate = generateVivaDate(getCourse.vivas, getCourse.vivaStartDate);

  // Create a new viva
  const viva = await vivaRepository.createViva({
    status: "scheduled",
    dateCreated: new Date().toISOString().substring(0, 10),
    vivaDate,
  });

  // Associate the viva with the project indirectly
  project.viva = viva._id;
  await vivaRepository.saveProject(project);

  // Add the viva to the course's vivas array
  getCourse.vivas.push(viva);
  await vivaRepository.saveCourse(getCourse);

  // Notify the project members
  for (const student of project.members) {
    const studentData = await authRepository.findStudentById(student);
    const studentAccount = await authRepository.findAccountById(
      studentData.account
    );
    await notificationService.createNotification(
      {
        title: "Viva Scheduled",
        message: `A viva has been scheduled for your project`,
        read: false,
      },
      studentAccount._id
    );
  }

  // notify project leader
  const leader = await authRepository.findStudentById(project.projectLeader);
  const leaderAccount = await authRepository.findAccountById(leader.account);
  await notificationService.createNotification(
    {
      title: "Viva Scheduled",
      message: `A viva has been scheduled for your project`,
      read: false,
    },
    leaderAccount._id
  );

  // Notify the teacher
  const teacher = await authRepository.findTeacherById(getCourse.teacher);
  const teacherAccount = await authRepository.findAccountById(teacher.account);
  await notificationService.createNotification(
    {
      title: "Viva Scheduled",
      message: `A viva has been scheduled for ${project.name} project in your course`,
      read: false,
    },
    teacherAccount._id
  );

  // Return the newly created viva details
  return {
    _id: viva._id,
    status: viva.status,
    vivaDate: viva.vivaDate,
  };
};

const updateViva = async (vivaId, updateData) => {
  const { vivaDate } = updateData;

  // Check if vivaDate is provided
  if (vivaDate) {
    // Parse the vivaDate
    const parsedVivaDate = new Date(vivaDate);
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Reset time to midnight to only compare dates

    // Validate that the vivaDate is valid and in the future
    if (isNaN(parsedVivaDate.getTime())) {
      throw new AppError("Invalid vivaDate provided", 400);
    }
    if (parsedVivaDate < today) {
      throw new AppError("vivaDate must be a future date", 400);
    }

    // Update the parsed date in the updateData object
    updateData.vivaDate = parsedVivaDate;
  }

  // Find the viva by ID
  const viva = await vivaRepository.findVivaById(vivaId);
  if (!viva) throw new AppError("Viva Not Found", 400);

  // Proceed to update the viva
  await vivaRepository.updateViva(vivaId, updateData);
};

const sendViva = async (vivaId) => {
  const viva = await vivaRepository.findVivaById(vivaId);
  if (!viva) throw new AppError("Viva Not Found", 400);
  return viva;
};

const getTodaysViva = async (courseId) => {
  const getCourse = await vivaRepository.findCourseById(courseId);
  if (!getCourse) throw new AppError("Course Not Found", 400);

  const vivas = getTodayVivas(getCourse.vivas);
  if (vivas.length === 0) throw new AppError("No Vivas For Today", 400);

  return vivas;
};

const getAllVivas = async (courseId) => {
  const getCourse = await vivaRepository.findCourseById(courseId);
  if (!getCourse) throw new AppError("Course Not Found", 400);

  return getCourse.vivas;
};

const generateVivaQuestions = async (
  projectId,
  numberOfQuestions = 5,
  difficulty = "medium",
  questionType = "general"
) => {
  const genAI = new GoogleGenerativeAI(process.env.GEMENI_API_KEY);
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  // Fetch the project details
  const project = await projectRepository
    .findProjectById(projectId)
    .populate("course");
  if (!project) {
    throw new AppError("Project not found", 404);
  }

  const { name, scope, course } = project;
  const projectRequirements = course.projectRequirements;

  // Construct the AI prompt using project details and user-provided parameters
  const prompt = `
    Generate ${
      numberOfQuestions || 5
    } viva questions based on the following project details:
    Project Name: ${name}
    Project Scope: ${scope}
    Project Requirements: ${projectRequirements}
    Difficulty Level: ${difficulty || "medium"}
    Question Type: ${questionType || "general"}
    Output format: Each question should be represented as an object with 'questionText' field. Format: [{questionText: '...'}, ...]. Should be JSON Array only.
  `;

  try {
    const result = await model.generateContent(prompt);
    let response = result.response;

    // Remove ```json and last ```
    let jsonString = response
      .text()
      .replace(/^```json\s+/, "")
      .replace(/\s+```$/, "");

    // Parse the response into a JSON array
    const jsonArray = JSON.parse(jsonString);

    return jsonArray;
  } catch (err) {
    console.error("Error generating viva questions:", err);
    throw new AppError(
      "Failed to generate viva questions. Please try again later.",
      500
    );
  }
};

module.exports = {
  addViva,
  updateViva,
  sendViva,
  getTodaysViva,
  getAllVivas,
  generateVivaQuestions,
};

/**
 * Represents an application error.
 * @class
 * @extends Error
 */
class AppError extends Error{
    constructor(message,status){
        super()
        this.message=message;
        this.status=status;
    }
}
module.exports= AppError
/**
 * Calculates the score of a quiz based on the given answers and questions.
 *
 * @param {Array} answers - The array of user's answers.
 * @param {Array} questions - The array of quiz questions.
 * @returns {number} - The calculated score of the quiz.
 */
const calculateQuizScore = ( answers, questions) => {
  let score = 0;

  // Iterate through the answers
  for (let i = 0; i < answers.length; i++) {
    const answer = answers[i];
    const question = questions.find(
      (q) => q._id.toString() === answer.question._id.toString()
    );
    if (question && question.correct_option === answer.selectedOption) {
      score += 1;
    }
  }

  return score;
};

module.exports = { calculateQuizScore };
/**
 * A higher-order function to wrap asynchronous route handlers.
 * This ensures that any errors thrown in the asynchronous function
 * are passed to the next middleware (error handler) in the chain.
 *
 * @param {Function} fn - The asynchronous function to be wrapped.
 * @returns {Function} - A new function that wraps the async function
 * and catches any errors, passing them to the next middleware.
 */

function wrapAsync(fn) {
    return function(req, res, next) {
        // Call the asynchronous function and catch any errors
        fn(req, res, next).catch(next); // Pass any caught error to the next middleware
    };
}

module.exports = wrapAsync;

/**
 * Parses a date string in the format "MM/DD/YYYY" and returns a Date object.
 *
 * @param {string} dateString - The date string to be parsed, in the format "MM/DD/YYYY".
 * @returns {Date} - A Date object representing the parsed date.
 */
const parseDate = (dateString) => {
  // Split the date string into an array of [month, day, year] and convert each to a number
  const [month, day, year] = dateString.split("/").map(Number);

  // Create a new Date object
  // Note: JavaScript's Date constructor expects the month to be 0-indexed (i.e., January is 0)
  // The day is incremented by 1 due to the way Date handles date overflow internally
  return new Date(year, month - 1, day);
};

module.exports = {
  parseDate,
};

const fs = require("fs");

/**
 * Deletes a file at the specified file path if it exists.
 *
 * @param {string} filePath - The path to the file to be deleted.
 */
const deleteFileByPath = (filePath) => {
  // Check if the file exists at the given path
  if (fs.existsSync(filePath)) {
    // Attempt to delete the file asynchronously
    fs.unlink(filePath, (err) => {
      if (err) {
        // If an error occurs during deletion, throw the error
        throw err;
      }
    });
  }
};

module.exports = { deleteFileByPath };

/**
 * Extracts the enrollment number from an email address.
 *
 * The enrollment number is expected to follow the pattern "SPXX-XXX-XXX",
 * where "XX" represents two digits and "XXX" represents a combination of letters and digits.
 * 
 * @param {string} email - The email address containing the enrollment number.
 * @returns {string|null} - The extracted enrollment number if found, or null if not found.
 */
function extractEnrollment(email) {
    // Regular expression to match the enrollment number pattern (e.g., SP20-ABC-123)
    const match = email.match(/(sp\d{2}-\w{3}-\d{3})/i);
    
    // Return the matched enrollment number, or null if no match is found
    return match ? match[0] : null;
}

module.exports = {
    extractEnrollment
};

/**
 * Generates a unique 9-character course code consisting of lowercase letters and digits.
 *
 * The function ensures that the generated course code does not already exist in the provided array of objects.
 * 
 * @param {Array} arr - An array of objects where each object should have a `classId` property.
 * @returns {string} - A unique 9-character course code.
 */
const generateCourseCode = (arr) => {
    const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
    let randomString = "";

    // Generate a random 9-character string
    for (let i = 0; i < 9; i++) {
        randomString += characters[Math.floor(Math.random() * characters.length)];
    }

    // Check if the generated code already exists in the array
    for (let item of arr) {
        if (item.classId === randomString) {
            // If it exists, recursively generate a new code
            return generateCourseCode(arr);
        }
    }

    // Return the unique code
    return randomString;
};

module.exports = {
    generateCourseCode
};

const jwt = require('jsonwebtoken');

/**
 * Generates a JSON Web Token (JWT) for a given user ID.
 *
 * @param {string|number} id - The unique identifier of the user for whom the token is being generated.
 * @returns {string} - The generated JWT token, signed with a secret key.
 */
const generateToken = (id) => {
    // Generate a JWT token with the user ID as payload
    // The token is signed with a secret key ("hi") and is set to expire in 30 days
    return jwt.sign({ id }, "hi", { expiresIn: "30d" });
};

module.exports = generateToken;

/**
 * Verifies if the provided email belongs to a teacher at COMSATS.
 *
 * @param {string} email - The email address to be verified.
 * @returns {boolean} - Returns true if the email matches the teacher's email pattern, false otherwise.
 */
const verifyTeacherEmail = (email) => {
    // Regular expression to match teacher emails from COMSATS
    const regex = /^[a-zA-Z0-9._%+-]+@faculty\.comsats\.edu\.pk$/;
    return regex.test(email);
};

/**
 * Verifies if the provided email belongs to a student at COMSATS.
 *
 * @param {string} email - The email address to be verified.
 * @returns {boolean} - Returns true if the email matches the student's email pattern, false otherwise.
 */
const verifyStudentEmail = (email) => {
    // Regular expression to match student emails from COMSATS
    const regex = /^[a-zA-Z0-9._%+-]+@isbstudent\.comsats\.edu\.pk$/;
    return regex.test(email);
};

module.exports = {
    verifyTeacherEmail,
    verifyStudentEmail
};

const bcrypt = require('bcrypt');

/**
 * Compares a plain text password with a hashed password to see if they match.
 *
 * @param {string} password - The plain text password to be compared.
 * @param {string} toCompare - The hashed password to compare against.
 * @returns {Promise<boolean>} - A promise that resolves to true if the passwords match, false otherwise.
 */
const matchPassword = async function (password, toCompare) {
    // Compare the plain text password with the hashed password
    return await bcrypt.compare(password, toCompare);
};

module.exports = matchPassword;

const fs = require("fs");
const path = require("path");

/**
 * Deletes a file from the "profile_pictures" directory in the public folder.
 *
 * @param {string} fileName - The name of the file to be deleted.
 */
const deleteFile = (fileName) => {
  // Construct the full file path using the provided file name
  const filePath = path.join(__dirname, "..", "public", "profile_pictures", fileName);

  // Attempt to delete the file asynchronously
  fs.unlink(filePath, (err) => {
    if (err) {
      // If an error occurs during deletion, throw the error to be handled by the caller
      throw err;
    }
  });
};

module.exports = { deleteFile };

/**
 * Retrieves the latest review from an array of vivas based on their token number.
 *
 * @param {Array} vivas - An array of viva objects, each with a `status`, `tokenNumber`, and `review` property.
 * @returns {Object|boolean} - The latest review object if available, or false if no 'taken' vivas are found.
 */
const getLatestReview = (vivas) => {
    if (vivas.length === 0) {
        return false; // Return false if the array is empty
    }

    let latestViva = null;

    // Find the latest viva with 'taken' status
    for (const viva of vivas) {
        if (viva.status === 'taken') {
            if (!latestViva || viva.tokenNumber > latestViva.tokenNumber) {
                latestViva = viva;
            }
        }
    }

    // Return the review of the latest viva, or false if no 'taken' viva was found
    return latestViva ? latestViva.review : false;
};

/**
 * Calculates the average review scores from an array of vivas.
 *
 * @param {Array} vivas - An array of viva objects, each with a `status` and `review` property.
 * @returns {Object|null} - An object with average review scores or null if no 'taken' vivas are found.
 */
const getAverageReview = (vivas) => {
    const totalReviews = {
        difficulty: 0,
        relevence: 0,
        clarity: 0,
        conceptual: 0,
        overallFeedback: 0
    };
    let numReviews = 0;

    // Accumulate total review scores from 'taken' vivas
    for (const viva of vivas) {
        if (viva.status === 'taken') {
            const review = viva.review;
            totalReviews.difficulty += review.difficulty;
            totalReviews.relevence += review.relevence;
            totalReviews.clarity += review.clarity;
            totalReviews.conceptual += review.conceptual;
            totalReviews.overallFeedback += review.overallFeedback;
            numReviews++;
        }
    }

    // Return null if no 'taken' vivas were found
    if (numReviews === 0) {
        return null;
    }

    // Calculate average review scores
    const averageReview = {
        difficulty: Math.round(totalReviews.difficulty / numReviews),
        relevence: Math.round(totalReviews.relevence / numReviews),
        clarity: Math.round(totalReviews.clarity / numReviews),
        conceptual: Math.round(totalReviews.conceptual / numReviews),
        overallFeedback: Math.round(totalReviews.overallFeedback / numReviews)
    };

    return averageReview;
};

module.exports = {
    getLatestReview,
    getAverageReview
};

/**
 * Adds a specified number of business days to a given start date.
 * Weekends (Saturday and Sunday) are excluded from the count.
 *
 * @param {Date|string} startDate - The start date from which to add business days. Can be a Date object or a date string.
 * @param {number} numDays - The number of business days to add.
 * @returns {string} - The new date in YYYY-MM-DD format after adding the business days.
 */
function addBusinessDays(startDate, numDays) {
    const oneDay = 24 * 60 * 60 * 1000; // One day in milliseconds
    const weekendDays = [6, 0]; // Saturday (6) and Sunday (0)

    const startTimestamp = new Date(startDate).getTime();
    let currentTimestamp = startTimestamp;
    let addedDays = 0;

    while (addedDays < numDays) {
        currentTimestamp += oneDay;
        const currentDate = new Date(currentTimestamp);
        const currentDayOfWeek = currentDate.getDay();

        if (!weekendDays.includes(currentDayOfWeek)) {
            addedDays++;
        }
    }
    
    // Convert back to a date string in YYYY-MM-DD format
    return new Date(currentTimestamp).toISOString().substring(0, 10);
}

/**
 * Generates a unique token for a viva based on the total number of vivas.
 *
 * @param {Array} vivas - An array of viva objects.
 * @returns {number} - The generated viva token.
 */
const generateVivaToken = (vivas) => {
    return vivas.length + 1;
};

/**
 * Determines the next viva date based on the number of existing vivas.
 *
 * @param {Array} vivas - An array of viva objects.
 * @param {Date|string} vivaStartDate - The initial start date for scheduling vivas.
 * @returns {string} - The calculated viva date in YYYY-MM-DD format.
 */
const generateVivaDate = (vivas, vivaStartDate) => {
    if (vivas.length <= 10) {
        return vivaStartDate;
    } else if (vivas.length <= 20) {
        return addBusinessDays(vivaStartDate, 0);
    } else if (vivas.length <= 30) {
        return addBusinessDays(vivaStartDate, 1);
    }
    // Default case if vivas.length > 30
    return addBusinessDays(vivaStartDate, 2);
};

/**
 * Retrieves vivas that are scheduled for today.
 *
 * @param {Array} vivas - An array of viva objects.
 * @returns {Array} - An array of vivas that are scheduled for today.
 */
const getTodayVivas = (vivas) => {
    const today = new Date().toISOString().substring(0, 10);
    const finalVivas = [];

    if (vivas.length === 0) {
        return finalVivas;
    }

    for (const viva of vivas) {
        if (viva.status === 'scheduled' && viva.vivaDate.toISOString().substring(0, 10) === today) {
            finalVivas.push(viva);
        }
    }

    return finalVivas;
};

module.exports = {
    generateVivaToken,
    generateVivaDate,
    getTodayVivas
};

import cv2
import math
import json
from face_detector import FaceMeshDetector
from utils import get_eye_center, detect_pupil
import os


def analyze_image(image_path, model, output_dir):
    """
    Analyze an image to detect mobile phones, people, and face features.
    
    Args:
        image_path (str): Path to the image file.
        model: Object detection model.
        output_dir (str): Directory where output images and results will be saved.
    
    Returns:
        dict: JSON-compatible dictionary with analysis results.
    """
    
    # Load the image from the given path
    img = cv2.imread(image_path)
    image_name = os.path.basename(image_path)  # Extract the image file name
    
    # Use the model to detect objects in the image
    results = model(image_path)
    detected_objects = results[0].boxes.data.numpy()  # Detected object details
    object_names = model.names  # Mapping of class IDs to object names

    # Initialize counts for detected phones and persons
    phone_count = 0
    person_count = 0

    # Iterate through detected objects and count relevant ones
    for obj in detected_objects:
        class_id = int(obj[5])  # Class ID of the detected object
        x1, y1, x2, y2 = map(int, obj[:4])  # Bounding box coordinates

        if object_names[class_id] == 'cell phone':
            phone_count += 1
            # Draw bounding box and label for detected phone
            cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 1)
            cv2.putText(img, 'phone', (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        
        elif object_names[class_id] == 'person':
            person_count += 1
            # Draw bounding box and label for detected person
            cv2.rectangle(img, (x1, y1), (x2, y2), (255, 0, 0), 1)
            cv2.putText(img, 'person', (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)

    # Conditions based on detected people
    extra_person = person_count > 1  # More than one person
    no_person = person_count == 0  # No person detected

    # Initialize face mesh detector
    face_detector = FaceMeshDetector()
    img, faces = face_detector.findFaceMesh(img)
    
    # Initialize result dictionary
    json_result = {
        "mobile_phone": phone_count > 0,
        "extra_person": extra_person,
        "no_person": no_person,
        "mouth_open": False,
        "eye_gaze": "center"
    }

    # If faces are detected, proceed with further analysis
    if faces:
        face = faces[0]  # Assume first detected face for analysis
        nose_tip = face[1]  # Coordinates of the nose tip

        # Define key face points for eyes and mouth
        left_eye_points = [face[i] for i in [33, 133, 160, 159, 158, 144, 145, 153]]
        right_eye_points = [face[i] for i in [362, 385, 387, 386, 374, 373, 390, 249]]
        mouth_upper = face[13]
        mouth_lower = face[14]

        # Calculate center of eyes
        # left_eye_center = get_eye_center(left_eye_points)
        # right_eye_center = get_eye_center(right_eye_points)

        # Detect pupils in eye images
        left_eye_img = img[min([p[1] for p in left_eye_points]):max([p[1] for p in left_eye_points]),
                           min([p[0] for p in left_eye_points]):max([p[0] for p in left_eye_points])]
        right_eye_img = img[min([p[1] for p in right_eye_points]):max([p[1] for p in right_eye_points]),
                            min([p[0] for p in right_eye_points]):max([p[0] for p in right_eye_points])]

        left_pupil = detect_pupil(left_eye_img)
        right_pupil = detect_pupil(right_eye_img)

        # Mark detected pupils on the image
        if left_pupil:
            cv2.circle(left_eye_img, left_pupil, 3, (0, 0, 255), -1)
        if right_pupil:
            cv2.circle(right_eye_img, right_pupil, 3, (0, 0, 255), -1)

        # Calculate mouth length to determine if it is open
        mouth_length = math.hypot(mouth_lower[0] - mouth_upper[0], mouth_lower[1] - mouth_upper[1])
        json_result["mouth_open"] = mouth_length > 5

        # Determine gaze direction based on pupil position
        gaze_direction = "center"
        if left_pupil and right_pupil:
            if left_pupil[0] < left_eye_img.shape[1] // 2 and right_pupil[0] < right_eye_img.shape[1] // 2:
                gaze_direction = "left"
            elif left_pupil[0] > left_eye_img.shape[1] // 2 and right_pupil[0] > right_eye_img.shape[1] // 2:
                gaze_direction = "right"

        json_result["eye_gaze"] = gaze_direction

        # Draw annotations for mouth, eyes, and nose
        cv2.rectangle(img, (min(mouth_upper[0], mouth_lower[0]), min(mouth_upper[1], mouth_lower[1]) - 10),
                      (max(mouth_upper[0], mouth_lower[0]), max(mouth_upper[1], mouth_lower[1]) + 10), (0, 255, 0), 1)
        cv2.putText(img, f"MOUTH {'OPEN' if json_result['mouth_open'] else 'CLOSED'}",
                    (mouth_upper[0], mouth_upper[1] - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

        cv2.putText(img, f"EYE GAZE {gaze_direction.upper()}",
                    (left_eye_points[0][0], left_eye_points[0][1] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)

        # Draw nose tip
        cv2.circle(img, (nose_tip[0], nose_tip[1]), 2, (0, 255, 255), -1)
        cv2.putText(img, "NOSE", (nose_tip[0] + 10, nose_tip[1] - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)

    # Save the annotated image to the output directory
    cv2.imwrite(os.path.join(output_dir, f"result_{image_name}"), img)

    return json_result

from flask import Flask, request, jsonify
from flask_cors import CORS
from dotenv import load_dotenv
import os
from extract_face_encodings import extract_face_encodings
from verify_face import verify_face
from otp_utils import generate_otp, send_otp
import numpy as np
from ultralytics import YOLO
from ai_protoring import analyze_image
import joblib
from cheating_detection import predict_cheating_probability

# Load environment variables from .env file
load_dotenv()

app = Flask(__name__)

# Get the allowed origin from the .env file
allowed_origin = os.getenv('ALLOWED_ORIGIN')

# Configure CORS to allow only the specified origin
CORS(app, resources={r"/*": {"origins": allowed_origin}})

# Load the pre-trained model for detecting fake images
# model = load_model("./models/face_antispoofing_model.keras")
model= YOLO("./models/yolo_custom_model.pt")
model_yolo = YOLO("./models/yolov8x.pt")
loaded_model = joblib.load("./models/cheating_detection_model.pkl")

protoring_output_dir = "C://Users//Dell//OneDrive//Desktop//qamar//Projects//LearnXcellence//server//uploads//protoring_result_db//"

@app.route('/')
def home():
    return jsonify(message="Hello, World!")

@app.route('/register-face', methods=['POST'])
def register_face():
    try:
        # Get the image path from the request
        data = request.json
        image_path = data.get('image_path')
        if not image_path:
            return jsonify(error="No image path provided")
        
        success, result = extract_face_encodings(image_path,model)
        
        if not success:
            return jsonify(success=False,error=result)

        return jsonify(success=True,encoding=result)

    except Exception as e:
        return jsonify(success=False,error=str(e)), 500

@app.route('/verify-face', methods=['POST'])
def verify_face_api():
    try:
        data = request.json
        image_path = data.get('image_path')
        known_face_encoding = data.get('known_face_encoding')
        if not image_path or not known_face_encoding:
            return jsonify(error="Image path or known face encoding not provided"), 400
        
        # Convert the known face encoding from list to numpy array
        known_face_encoding = np.array([float(num) for num in known_face_encoding])
        
        success, result = verify_face(image_path, known_face_encoding,model)

        if not success:
            return jsonify(success=False,error=result)

        return jsonify(success=True,match=result)

    except Exception as e:
        return jsonify(success=False,error=str(e)), 500

@app.route('/generate-otp', methods=['POST'])
def generate_otp_api():
    try:
        data = request.json
        email = data.get('email')
        
        if not email:
            return jsonify(error="Email not provided"), 400
        
        # Generate OTP
        otp = generate_otp()
        
        # Send OTP to email
        try:
            otp = send_otp(email, otp)
            return jsonify(success=True,message="OTP sent successfully",otp=otp)
        except Exception as e:
            return jsonify(succes=False, error=f"Failed to send OTP: {str(e)}"), 500
    except Exception as e:
        return jsonify(error=str(e)), 500

@app.route('/analyze-image', methods=['POST'])
def analyze_image_api():
    try:
        data = request.json
        image_path = data.get('image_path')

        if not image_path or not os.path.exists(image_path):
            return jsonify(error="Image path not provided or does not exist"), 400

        # Call the analyze_image function
        try:
            result_json = analyze_image(image_path, model=model_yolo, output_dir=protoring_output_dir)
            return jsonify(success=True, message="Image analyzed successfully", data=result_json)
        except Exception as e:
            return jsonify(success=False, error=f"Failed to analyze image: {str(e)}"), 500
    except Exception as e:
        return jsonify(error=str(e)), 500

@app.route('/predict-cheating', methods=['POST'])
def predict_cheating_api():
    try:
        data = request.json
        features = data.get('features')

        if not features or not isinstance(features, list) or len(features) != 6:
            return jsonify(error="Features not provided or invalid format"), 400

        try:
            probabilities = predict_cheating_probability(features, loaded_model)
            return jsonify(success=True, message="Prediction successful", data=probabilities)
        except Exception as e:
            return jsonify(success=False, error=f"Failed to predict cheating: {str(e)}"), 500
    except Exception as e:
        return jsonify(error=str(e)), 500
    
if __name__ == '__main__':
    app.run(debug=True)

import pandas as pd

def predict_cheating_probability(features, loaded_model):
    """
    Predict the probability of cheating based on input features.

    Parameters:
    features (list or array-like): A list or array of feature values in the following order:
        [num_images, mobile_phone, extra_person, mouth_open, no_person, eye_left_right]

    Returns:
    dict: A dictionary with probabilities of 'not cheating' and 'cheating', rounded to two decimal places.
    """
    # Define the feature names
    feature_names = ["num_images", "mobile_phone", "extra_person", "mouth_open", "no_person", "eye_left_right"]
    
    # Convert the features into a DataFrame with the correct feature names
    features_df = pd.DataFrame([features], columns=feature_names)
    
    # Get probability predictions
    probabilities = loaded_model.predict_proba(features_df)[0]

    # Return rounded probabilities
    return {
        "cheating_probability": round(probabilities[1] * 100, 2),
        "not_cheating_probability": round(probabilities[0] * 100, 2)
    }

import face_recognition
import cv2
import os
# from test import test
from spoof_detector import is_real_image

def extract_face_encodings(image_path,model):
    """
    Extract face encodings from the given image path.
    
    :param image_path: Path to the image file.
    :return: A tuple containing a success flag, encoding or error message.
    """
    if not image_path:
        return False, "No image path provided"

    if not os.path.exists(image_path):
        return False, "Image not found"

    try:
        # Load the image
        image = face_recognition.load_image_file(image_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
        # Get face encodings
        face_encodings = face_recognition.face_encodings(image)

        if len(face_encodings) == 0:
            return False, "No face detected"
        
        # isReal = test(device_id=0,model_dir="./resources/anti_spoof_models",image_path=image_path)
        isReal = is_real_image(image_path,model,threshold=0.5)
        
        if not isReal:
            return False, "Fake face detected"
            
        face_encoding = face_encodings[0]

        return True, face_encoding.tolist()

    except Exception as e:
        return False, str(e)

import cv2
import mediapipe as mp

class FaceMeshDetector:
    def __init__(self, staticMode=False, maxFaces=2, refineLandmarks=True, minDetectionCon=0.5, minTrackingCon=0.5):
        """
        Initializes the FaceMeshDetector with parameters for face mesh detection.

        :param staticMode: If true, detection is done on every frame.
        :param maxFaces: Maximum number of faces to detect.
        :param refineLandmarks: Refine landmarks for accurate detection.
        :param minDetectionCon: Minimum confidence value for detection.
        :param minTrackingCon: Minimum confidence value for tracking.
        """
        self.staticMode = staticMode
        self.maxFaces = maxFaces
        self.refineLandmarks = refineLandmarks
        self.minDetectionCon = minDetectionCon
        self.minTrackingCon = minTrackingCon

        self.mpDraw = mp.solutions.drawing_utils
        self.mpFaceMesh = mp.solutions.face_mesh
        self.faceMesh = self.mpFaceMesh.FaceMesh(
            self.staticMode,
            self.maxFaces,
            self.refineLandmarks,
            self.minDetectionCon,
            self.minTrackingCon
        )
        self.drawSpec = self.mpDraw.DrawingSpec(thickness=1, circle_radius=1, color=(0, 255, 0))

    def findFaceMesh(self, img):
        """
        Finds the face mesh landmarks in the given image.

        :param img: The image in which to find face mesh.
        :return: The image with drawn face mesh and the list of detected face landmarks.
        """
        imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        results = self.faceMesh.process(imgRGB)
        faces = []
        if results.multi_face_landmarks:
            for facelandmarks in results.multi_face_landmarks:
                face = []
                for id, lm in enumerate(facelandmarks.landmark):
                    ih, iw, ic = img.shape
                    x, y = int(lm.x * iw), int(lm.y * ih)
                    face.append([x, y])
                faces.append(face)
                # Draw the face mesh on the image
                self.mpDraw.draw_landmarks(img, facelandmarks, self.mpFaceMesh.FACEMESH_CONTOURS, self.drawSpec, self.drawSpec)
        return img, faces

import random
import smtplib
from email.mime.text import MIMEText
from dotenv import load_dotenv
import os
import ssl
import logging
import re

# Load environment variables from .env file
load_dotenv()

EMAIL = os.getenv('EMAIL')
PASSWORD = os.getenv('PASSWORD')
SMTP_SERVER = os.getenv('SMTP_SERVER')
SMTP_PORT = os.getenv('SMTP_PORT')

if not all([EMAIL, PASSWORD, SMTP_SERVER, SMTP_PORT]):
    raise RuntimeError("Some environment variables are missing. Please check your .env file.")

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def generate_otp(length=6):
    """Generate a random OTP of given length."""
    digits = "0123456789"
    otp = ''.join(random.choice(digits) for _ in range(length))
    return otp

def is_valid_email(email):
    """Check if the email format is valid."""
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    return re.match(pattern, email) is not None

def send_otp(email, otp):
    """Send the OTP to the given email address using SMTP."""
    if not is_valid_email(email):
        logger.error(f"Invalid email format: {email}")
        raise ValueError("Invalid email address format.")

    subject = "Your OTP Code for Your Email Verification"
    body = f"""
    Dear User,

    Please use the following OTP (One-Time Password) to complete your verification process on LearnXcellence app:

    Security Code: {otp}

    If you did not request this OTP, you can safely ignore this email. Someone might have mistakenly entered your email address.

    Thank you for using LearnXcellence!

    Best regards,
    Team LearnXcellence
    """
    
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = EMAIL
    msg['To'] = email

    context = ssl.create_default_context()
    try:
        with smtplib.SMTP(SMTP_SERVER, int(SMTP_PORT)) as server:
            server.ehlo()
            server.starttls(context=context)
            server.login(EMAIL, PASSWORD)
            server.sendmail(EMAIL, email, msg.as_string())
            logger.info(f"OTP sent successfully to {email}")
            return otp
    except smtplib.SMTPAuthenticationError as e:
        logger.error(f"Authentication error: {e}")
        raise RuntimeError("Authentication failed. Please check your email and password.")
    except smtplib.SMTPConnectError as e:
        logger.error(f"Connection error: {e}")
        raise RuntimeError("Failed to connect to the SMTP server. Please check your server and port.")
    except smtplib.SMTPRecipientsRefused as e:
        logger.error(f"Recipient error: {e}")
        raise RuntimeError("The email recipient was refused. Please check the recipient email address.")
    except smtplib.SMTPSenderRefused as e:
        logger.error(f"Sender error: {e}")
        raise RuntimeError("The sender address was refused. Please check the sender email address.")
    except smtplib.SMTPDataError as e:
        logger.error(f"Data error: {e}")
        raise RuntimeError("The SMTP server responded with an unexpected error.")
    except smtplib.SMTPException as e:
        logger.error(f"SMTP error: {e}")
        raise RuntimeError(f"An error occurred: {str(e)}")

import math

def is_real_image(image_path, model, threshold=0.6):
    """
    Determines if an image is real or fake using a pre-trained model.

    Parameters:
    - image_path (str): Path to the image to be evaluated.
    - model           : Pre-trained model.
    - threshold (float): Threshold for determining if an image is real or fake. Default is 0.6.

    Returns:
    - bool: True if the image is real, False if fake.
    """
    class_names = ["fake", "real"]
    results = model(image_path)
    
    for result in results:
        for box in result.boxes:
            # Confidence
            confidence = math.ceil((box.conf[0] * 100)) / 100
            # Class Name
            class_id = int(box.cls[0])
            
            if confidence > threshold:
                return class_names[class_id] == 'real'
    
    return False

import cv2
import numpy as np

def get_eye_center(eye_points):
    x_coords = [p[0] for p in eye_points]
    y_coords = [p[1] for p in eye_points]
    center_x = sum(x_coords) / len(x_coords)
    center_y = sum(y_coords) / len(y_coords)
    return (int(center_x), int(center_y))

def detect_pupil(eye_img):
    gray_eye = cv2.cvtColor(eye_img, cv2.COLOR_BGR2GRAY)
    
    # Apply Gaussian Blur to reduce noise
    blurred_eye = cv2.GaussianBlur(gray_eye, (7, 7), 0)
    
    # Apply adaptive thresholding
    threshold_eye = cv2.adaptiveThreshold(
        blurred_eye, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
        cv2.THRESH_BINARY_INV, 11, 3
    )
    
    # Find contours
    contours, _ = cv2.findContours(threshold_eye, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    contours = sorted(contours, key=lambda x: cv2.contourArea(x), reverse=True)
    
    for contour in contours:
        (x, y, w, h) = cv2.boundingRect(contour)
        
        # Validate contour: it should be roughly circular and within a reasonable size
        aspect_ratio = w / float(h)
        area = cv2.contourArea(contour)
        
        if 0.8 < aspect_ratio < 1.2 and 50 < area < 200:
            pupil_center = (x + w // 2, y + h // 2)
            return pupil_center
    
    return None

import face_recognition
import cv2
import os
# from test import test
from spoof_detector import is_real_image

# Define a threshold for face matching
FACE_MATCH_THRESHOLD = 0.4


def verify_face(image_path, known_face_encoding, model):
    """
    Verify if the face encoding matches the face in the provided image path.

    :param image_path: Path to the image file.
    :param known_face_encoding: The face encoding to compare with.
    :return: A tuple containing a success flag, result or error message.
    """
    if not image_path:
        return False, "No image path provided"

    if not os.path.exists(image_path):
        return False, "Image not found"

    try:
        # Load the image
        image = face_recognition.load_image_file(image_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
        # Get face encodings
        face_encodings = face_recognition.face_encodings(image)

        if len(face_encodings) == 0:
            return False, "No face detected"

        # isReal = test(device_id=0, model_dir="./resources/anti_spoof_models", image_path=image_path)
        isReal = is_real_image(image_path, model, threshold=0.5)

        if not isReal:
            return False, "Fake face detected"

        # Calculate the distance between the known face encoding and the first face encoding found
        face_distances = face_recognition.face_distance([known_face_encoding], face_encodings[0])
        # Compare the distance to the threshold
        match = face_distances[0] <= FACE_MATCH_THRESHOLD
        
        return match, "Faces match" if match else "Faces do not match."

    except Exception as e:
        return False, str(e)

